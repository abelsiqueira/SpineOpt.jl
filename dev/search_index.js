var documenterSearchIndex = {"docs":
[{"location":"concept_reference/write_mps_file/","page":"-","title":"-","text":"This parameter is deprecated and will be removed in a future version.","category":"page"},{"location":"concept_reference/write_mps_file/","page":"-","title":"-","text":"This parameter controls when to write a diagnostic model file in MPS format. If set to write_mps_always, the model will always be written in MPS format to the current directory. If set to write\\_mps\\_on\\_no\\_solve, the MPS file will be written when the model solve terminates with a status of false.  If set to write\\_mps\\_never, no file will be written","category":"page"},{"location":"concept_reference/demand/","page":"-","title":"-","text":"The demand parameter represents a \"demand\" or a \"load\" of a commodity on a node. It appears in the node injection constraint, with positive values interpreted as \"demand\" or \"load\" for the modelled system, while negative values provide the system with \"influx\" or \"gain\". When the node is part of a group, the fractional_demand parameter can be used to split demand into fractions, when desired. See also: Introduction to groups of objects","category":"page"},{"location":"concept_reference/demand/","page":"-","title":"-","text":"The demand parameter can also be included in custom user_constraints using the demand_coefficient parameter for the node__user_constraint relationship.","category":"page"},{"location":"concept_reference/ramp_down_cost/","page":"-","title":"-","text":"By defining the ramp_down_cost parameter for a specific unit__to_node or unit__from_node relationship, a cost term will be added to the objective function whenever the unit ramps down its activity (i.e., when the ramp_down_unit_flow is nonzero) over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"getting_started/setup_workflow/#Setting-up-a-workflow-for-SpineOpt-in-Spine-Toolbox","page":"Setting up a workflow","title":"Setting up a workflow for SpineOpt in Spine Toolbox","text":"","category":"section"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"The next steps will set up a SpineOpt specific input database by creating a new Spine database, loading a blank SpineOpt template, connecting it to a SpineOpt instance and setting up a database for model results. ","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"Create a new Spine Toolbox project in an empty folder of your choice: File –> New project...\nCreate the input database\nDrag an empty Data store from the toolbar to the Design View. \nGive it a name like \"Input DB\". \nSelect SQL database dialect (sqlite is a local file and works without a server). \nClick New Spine DB in the Data Store Properties window and create a new database (and save it, if it's sqlite).\nFor more information about creating and managing Spine Toolbox database, see the documentation","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"(Image: image)","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"(Image: image)","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"Fill the Input DB with SpineOpt data format either by:\nDrag a tool Load template from the SpineOpt ribbon to the Design View. \nConnect an arrow from the Load template to the new Input DB. \nMake sure the  Load template item from the Design view is selected (then you can edit the properties of that workflow item in the Tool properties window. \nAdd the url link in Available resources to the Tool arguments - you are passing the database address as a command line argument to the load_template.jl script so that it knows where to store the output. \nThen execute the Load template tool. Please note that this process uses SpineOpt to generate the data structure. It takes time, since everything is compiled when running a tool in Julia for the first time in each Julia session. You may also see lot of messages and warnings concernging the compilation, but they should be benign.","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"(Image: image)","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"(Image: image)","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"(Image: image)","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"(Image: image)","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"...or by:\nStart Julia (you can start a separate Julia console in Spine Toolbox: go to Consoles –> Start Julia Console). \nCopy the URL address of the Data Store from the 'Data Store Properties' –> a copy icon at the bottom. \nThen run the following script with the right URL address pasted. The process uses SpineOpt itself to build the database structure. Please note that 'using SpineOpt' for the first time for each Julia session takes time - everything is being compiled.\nKnown issue: On Windows, the backslash between directories need to be changed to a double forward slash.","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"julia> using SpineOpt\n\njulia> SpineOpt.import_data(\"copied URL address, inside these quotes\", SpineOpt.template(), \"Load SpineOpt template\")","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"Drag SpineOpt tool icon to the Design view. \nConnect an arrow from the Input DB to SpineOpt. ","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"(Image: image)","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"Create a database for results\nDrag a new Data store from the toolbar to the Design View. \nYou can rename it to e.g. Results. Select SQL database dialect (sqlite is a local file and works without a server). \nClick New Spine DB in the Data Store Properties window and create a new database (and save it, if it's sqlite). \nConnect an arrow from the SpineOpt to Results.","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"(Image: image)","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"Select SpineOpt tool in the Design view. \nAdd the url link for the input data store and the output data store from Available resources to the Tool arguments (in that order).","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"(Image: image)","category":"page"},{"location":"getting_started/setup_workflow/","page":"Setting up a workflow","title":"Setting up a workflow","text":"SpineOpt would be ready to run, but for the Input DB, which is empty of content (it's just a template that contains a SpineOpt specific data structure). The next step goes through setting up and running a simple toy model.","category":"page"},{"location":"concept_reference/fix_nonspin_units_shut_down/","page":"-","title":"-","text":"The fix_nonspin_units_shut_down parameter simply fixes the value of the nonspin_units_shut_down variable to the provided value. As such, it determines directly how many member units are involved in providing downward reserve commodity flows to the node to which it is linked by the unit__to_node relationship.","category":"page"},{"location":"concept_reference/fix_nonspin_units_shut_down/","page":"-","title":"-","text":"When a single value is selected, this value is kept constant throughout the model. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/fix_ramp_down_unit_flow/","page":"-","title":"-","text":"The fix_ramp_down_unit_flow parameter simply fixes the value of the ramp_down_unit_flow variable to the provided value. It is possible to provide an incomplete timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/nodal_balance_sense/","page":"-","title":"-","text":"nodal_balance_sense determines whether or not a node is able to naturally consume or produce energy. The default value, ==, means that the node is unable to do any of that, and thus it needs to be perfectly balanced. The vale >= means that the node is a sink, that is, it can consume any amounts of energy. The value <= means that the node is a source, that is, it can produce any amounts of energy.","category":"page"},{"location":"concept_reference/unit__unit_constraint/","page":"-","title":"-","text":"unit__user_constraint is a two-dimensional relationship between a unit and a user_constraint. The relationship specifies that a variable or variable(s) associated only with the unit (not a unit_flow for example) are involved in the constraint. For example, the units_on_coefficient defined on unit__user_constraint specifies the coefficient of the unit's units_on variable in the specified user_constraint.","category":"page"},{"location":"concept_reference/unit__unit_constraint/","page":"-","title":"-","text":"See also user_constraint","category":"page"},{"location":"getting_started/example_models/#Example-Models","page":"Example Models","title":"Example Models","text":"","category":"section"},{"location":"getting_started/example_models/","page":"Example Models","title":"Example Models","text":"The SpineOpt.jl repository includes a few ready-made example models based on the case studies performed in the project. These are included in sub-folders under examples\\, where the input data is provided as .json or .sqlite files. This way, you can easily get a feel for how SpineOpt works with pre-made datasets, either through Spine Toolbox, or directly from the Julia REPL. The example models included in the SpineOpt.jl repository are briefly explained in the following sections.","category":"page"},{"location":"getting_started/example_models/#Case-Study-A5-Example","page":"Example Models","title":"Case Study A5 Example","text":"","category":"section"},{"location":"getting_started/example_models/","page":"Example Models","title":"Example Models","text":"TODO","category":"page"},{"location":"concept_reference/max_gap/","page":"-","title":"-","text":"This determines the optimality convergence criterion and is the benders gap tolerance for the master problem in a decomposed investments model. The benders gap is the relative difference between the current objective function upper bound(zupper) and lower bound (zlower) and is defined as 2*(zupper-zlower)/(zupper + zlower). When this value is lower than max_gap the benders algorithm will terminate having achieved satisfactory optimality.","category":"page"},{"location":"concept_reference/representative_periods_mapping/","page":"-","title":"-","text":"For representative periods with seasonal storages, SpineOpt.jl can be interlinked with the package SpinePeriods.jl. SpinePeriods.jl provides the representative_periods_mapping parameter, which maps each non-representative period of the whole optimization window to its representative temporal_block. The map is organized as timeseries (indicating the start of each the non-representative period) with the names of the representative temporal_blocks as entries. ","category":"page"},{"location":"concept_reference/operating_cost/","page":"-","title":"-","text":"By defining the operating_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for operating costs associated with that unit over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/connection_resistance/","page":"-","title":"-","text":"The per unit resistance of a transmission line. Currently unimplemented!","category":"page"},{"location":"concept_reference/model_type/","page":"-","title":"-","text":"This parameter is used, generally, to control model dependent functionality and specify model-level parameters for different models. Currently, the main use is to identify the model objects that represent the master and operational sub problems within a decomposed investment problem structure. To trigger the decomposed structure, a model object with model_type=:spineopt_master must exist and another with model_type=:spineopt_operations must also be present. To deactivate the decomposition functionality, the model_type of the master problem can be set to :spineopt_other.","category":"page"},{"location":"concept_reference/model_type/","page":"-","title":"-","text":"See also Decomposition.","category":"page"},{"location":"concept_reference/compression_factor/","page":"-","title":"-","text":"This parameter is specific to the use of pressure driven gas transfer. To represent a compression between two nodes in the gas network, the compression_factor can be defined. This factor ensures that the pressure of a node is equal to (or lower than) the pressure at the sending node times the compression_factor. The relationship connection__node__node that hosts this parameter should be defined in a way that the first node represents the origin node and the second node represents the compressed node.","category":"page"},{"location":"concept_reference/connection_type_list/","page":"-","title":"-","text":"connection_type_list holds the possible values for the connection_type parameter. See connection_type for more details","category":"page"},{"location":"concept_reference/model__default_investment_stochastic_structure/","page":"-","title":"-","text":"The model__default_investment_stochastic_structure relationship can be used to set model-wide default unit__investment_stochastic_structure, connection__investment_stochastic_structure, and node__investment_stochastic_structure relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific unit__investment_stochastic_structure, connection__investment_stochastic_structure, and node__investment_stochastic_structure relationships take priority over the model__default_investment_stochastic_structure relationship.","category":"page"},{"location":"concept_reference/units_started_up_coefficient/","page":"-","title":"-","text":"The units_started_up_coefficient is an optional parameter that can be used to include the units_started_up variable of a unit in a user_constraint via the unit__user_constraint relationship. Essentially, units_started_up_coefficient appears as a coefficient for the units_started_up variable of the unit in the user constraint.","category":"page"},{"location":"concept_reference/minimum_operating_point/","page":"-","title":"-","text":"The definition of the minimum_operating_point parameter will trigger the creation of the Constraint on minimum operating point. It sets a lower bound on the value of the unit_flow variable for a unit that is online.","category":"page"},{"location":"concept_reference/minimum_operating_point/","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/units_on_coefficient/","page":"-","title":"-","text":"The units_on_coefficient is an optional parameter that can be used to include the units_on variable of a unit in a user_constraint via the unit__user_constraint relationship. Essentially, units_on_coefficient appears as a coefficient for the units_on variable of the unit in the user constraint.","category":"page"},{"location":"concept_reference/curtailment_cost/","page":"-","title":"-","text":"By defining the curtailment_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit's available capacity exceeds its activity (i.e., the unit_flow variable) over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/diff_coeff/","page":"-","title":"-","text":"The diff_coeff parameter represents diffusion of a commodity between the two nodes in the node__node relationship. It appears as a coefficient on the node_state variable in the node injection constraint, essentially representing diffusion power per unit of state. Note that the diff_coeff is interpreted as one-directional, meaning that if one defines","category":"page"},{"location":"concept_reference/diff_coeff/","page":"-","title":"-","text":"diff_coeff(node1=n1, node2=n2),","category":"page"},{"location":"concept_reference/diff_coeff/","page":"-","title":"-","text":"there will only be diffusion from n1 to n2, but not vice versa. Symmetric diffusion is likely used in most cases, requiring defining the diff_coeff both ways","category":"page"},{"location":"concept_reference/diff_coeff/","page":"-","title":"-","text":"diff_coeff(node1=n1, node2=n2) == diff_coeff(node1=n2, node2=n1).","category":"page"},{"location":"concept_reference/max_res_startup_ramp/","page":"-","title":"-","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning upward reserves are provided to a upward_reserve node by contracted offline units holding available to startup. To include the provision of nonspinning upward reserves, the parameter max_res_startup_ramp needs to be defined on the corresponding unit__to_node relationship. This will trigger the generation of the variables nonspin_units_started_up and nonspin_ramp_up_unit_flow and the constraint on maximum upward nonspinning reserve provision. Note that max_res_startup_ramp is given as a fraction of the unit_capacity.","category":"page"},{"location":"concept_reference/max_res_startup_ramp/","page":"-","title":"-","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/ramp_down_limit/","page":"-","title":"-","text":"The definition of the ramp_down_limit parameter will trigger the creation of the Constraint on spinning downward ramps. It will limit the maximum decrease in the unit_flow variable between two consecutive timesteps for which the unit is online.","category":"page"},{"location":"concept_reference/ramp_down_limit/","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/fix_start_up_unit_flow/","page":"-","title":"-","text":"The fix_start_up_unit_flow parameter fixes the value of the start_up_unit_flow to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/fix_start_up_unit_flow/","page":"-","title":"-","text":"Common uses for the parameter include e.g. providing initial values for the start_up_unit_flow, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the start_up_unit_flow variable is only fixed for time steps with defined fix_start_up_unit_flow parameter values.","category":"page"},{"location":"concept_reference/fix_start_up_unit_flow/","page":"-","title":"-","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/fix_start_up_unit_flow/","page":"-","title":"-","text":"Note that the mentioned start_up_unit_flow variable is only included if the parameter max_startup_ramp exist for the correspond unit__to_node or unit__from_node relationship. The usage of ramps is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/fix_storages_invested/","page":"-","title":"-","text":"Used primarily to fix the value of the storages_invested variable which represents the point-in-time storage investment decision variable at a node and how many candidate storages are invested-in in a particular timeslice at the corresponding node.","category":"page"},{"location":"concept_reference/fix_storages_invested/","page":"-","title":"-","text":"See also Investment Optimization, candidate_storages and storage_investment_variable_type","category":"page"},{"location":"concept_reference/shut_down_cost/","page":"-","title":"-","text":"By defining the shut_down_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit shuts down over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/node__temporal_block/","page":"-","title":"-","text":"This relationship links a node to a temporal_block and as such it will determine which temporal block governs the temporal horizon and resolution of the variables associated with this node. Specifically, the resolution of the temporal block will directly imply the duration of the time slices for which both the regular and ramping flow variables and their associated constraints are created.","category":"page"},{"location":"concept_reference/node__temporal_block/","page":"-","title":"-","text":"For a more detailed description of how the temporal structure in SpineOpt can be created, see Temporal Framework.","category":"page"},{"location":"concept_reference/tax_in_unit_flow/","page":"-","title":"-","text":"By defining the tax_in_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with all unit_flow variables with direction to_node over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/min_ratio_out_in_unit_flow/","page":"-","title":"-","text":"The definition of the [min_ratio_out_in_unit_flow] parameter triggers the generation of the constraint_min_ratio_out_in_unit_flow and corresponds to a lower bound of the ratio between out and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/min_ratio_out_in_unit_flow/","page":"-","title":"-","text":"To enforce e.g. a minimum ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ng the min_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_in_out/","page":"-","title":"-","text":"The fix_units_on_coefficient_in_out parameter is an optional coefficient in the unit input-output ratio constraint controlled by the fix_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_in_out/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_out_in, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_in_out and max_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/unit__node__node/","page":"-","title":"-","text":"While the relationships unit__to_node and unit__to_node take care of the automatic generation of the unit_flow variables, the unit__node__node relationships hold the information how the different commodity flows of a unit interact. Only through this relationship and the associated parameters, the topology of a unit, i.e. which intakes lead to which products etc., becomes unambiguous.","category":"page"},{"location":"concept_reference/unit__node__node/","page":"-","title":"-","text":"In almost all cases, at least one of the ..._ratio_... parameters will be defined, e.g. to set a fixed ratio between outgoing and incoming commodity flows of unit (see also e.g. fix_ratio_out_in_unit_flow). Note that the parameters can also be defined on a relationship between groups of objects, e.g. to force a fixed ratio between a group of nodes. In the triggered constraints, this will lead to an aggregation of the individual unit flows.","category":"page"},{"location":"concept_reference/fix_unit_flow_op/","page":"-","title":"-","text":"If operating_points is defined on a certain unit__to_node or unit__from_node flow, the corresponding unit_flow flow variable is decomposed into a number of sub-variables, unit_flow_op one for each operating point, with an additional index, i to reference the specific operating point. fix_unit_flow_op can thus be used to fix the value of one or more of the variables as desired.","category":"page"},{"location":"concept_reference/connection__investment_stochastic_structure/","page":"-","title":"-","text":"The connection__investment_stochastic_structure relationship defines the stochastic_structure of connection-related investment decisions. Essentially, it sets the stochastic_structure used by the connections_invested_available variable of the connection.","category":"page"},{"location":"concept_reference/connection__investment_stochastic_structure/","page":"-","title":"-","text":"The connection__investment_stochastic_structure relationship uses the model__default_investment_stochastic_structure relationship if not defined.","category":"page"},{"location":"concept_reference/upward_reserve/","page":"-","title":"-","text":"If a node has a true is_reserve_node parameter, it will be treated as a reserve node in the model. To define whether the node corresponds to an upward or downward reserve commodity, the upward_reserve or the downward_reserve parameter needs to be set to true, respectively.","category":"page"},{"location":"concept_reference/fix_units_on/","page":"-","title":"-","text":"The fix_units_on parameter simply fixes the value of the units_on variable to the provided value. As such, it determines directly how many members of the specific unit will be online throughout the model when a single value is selected. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/unit__from_node/","page":"-","title":"-","text":"The unit__to_node and unit__from_node unit relationships are core elements of SpineOpt. For each unit__to_node or unit__from_node, a unit_flow variable is automatically added to the model, i.e. a commodity flow of a unit to or from a specific node, respectively.","category":"page"},{"location":"concept_reference/unit__from_node/","page":"-","title":"-","text":"Various parameters can be defined on the unit__from_node relationship, in order to constrain the associated unit flows. In most cases a unit_capacity will be defined for an upper bound on the commodity flows. Apart from that, ramping abilities of a unit can be defined. For further details on ramps see Ramping and Reserves.","category":"page"},{"location":"concept_reference/unit__from_node/","page":"-","title":"-","text":"To associate costs with a certain commodity flows, cost terms, such as fuel_costs and vom_costs, can be included for the unit__from_node relationship.","category":"page"},{"location":"concept_reference/unit__from_node/","page":"-","title":"-","text":"It is important to note, that the parameters associated with the unit__from_node can be defined either for a specific node, or for a group of nodes. Grouping nodes for the described parameters will result in an aggregation of the unit flows for the triggered constraint, e.g. the definition of the unit_capacity on a group of nodes will result in an upper bound on the sum of all individual unit_flows.","category":"page"},{"location":"concept_reference/unit_availability_factor/","page":"-","title":"-","text":"To indicate that a unit is only available to a certain extent or at certain times of the optimization, the unit_availability_factor can be used. A typical use case could be an availability timeseries for a variable renewable energy source. By default the availability factor is set to 1. The availability is, among others, used in the constraint_units_available.","category":"page"},{"location":"concept_reference/min_shutdown_ramp/","page":"-","title":"-","text":"The definition of the min_shutdown_ramp parameter will trigger the creation of the constraint on minimum shutdown ramp. It sets a lower bound on the unit_flow variable for the timestep right before a shutdown.","category":"page"},{"location":"concept_reference/min_shutdown_ramp/","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/fix_connections_invested_available/","page":"-","title":"-","text":"The fix_connections_invested_available parameter represents a forced connection investment.","category":"page"},{"location":"concept_reference/fix_connections_invested_available/","page":"-","title":"-","text":"In other words, it is the fix value of the connections_invested_available variable.","category":"page"},{"location":"concept_reference/stochastic_scenario/","page":"-","title":"-","text":"Essentially, a stochastic_scenario is a label for an alternative period of time, describing one possibility of what might come to pass. They are the basic building blocks of the scenario-based Stochastic Framework in SpineOpt.jl, but aren't really meaningful on their own. Only when combined into a stochastic_structure using the stochastic_structure__stochastic_scenario and parent_stochastic_scenario__child_stochastic_scenario relationships, along with Parameters like the weight_relative_to_parents and stochastic_scenario_end, they become meaningful.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_out_in/","page":"-","title":"-","text":"The fix_units_on_coefficient_out_in parameter is an optional coefficient in the unit output-input ratio constraint controlled by the fix_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_out_in/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_out_in and max_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/Parameters/#Parameters","page":"Parameters","title":"Parameters","text":"","category":"section"},{"location":"concept_reference/Parameters/#balance_type","page":"Parameters","title":"balance_type","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A selector for how the :nodal_balance constraint should be handled.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: balance_type_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: balance_type_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The balance_type parameter determines whether or not a node needs to be balanced, in the classical sense that the sum of flows entering the node is equal to the sum of flows leaving it.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The values balance_type_node (the default) and balance_type_group mean that the node is always balanced. The only exception is if the node belongs in a group that has itself balance_type equal to balance_type_group. The value balance_type_none means that the node doesn't need to be balanced.","category":"page"},{"location":"concept_reference/Parameters/#big_m","page":"Parameters","title":"big_m","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Sufficiently large number used for linearization bilinear terms, e.g. to enforce bidirectional flow for gas pipielines","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1000000","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The big_m parameter is a property of the model object. The bigM method is commonly used for the purpose of recasting non-linear constraints into a mixed-integer reformulation. In SpineOpt, the bigM formulation is used to describe the sign of gas flow through a connection (if a pressure driven gas transfer model is used). The big_m parameter in combination with the binary variable binary_gas_connection_flow is used in the constraints on the gas flow capacity and the fixed node pressure points and ensures that the average flow through a pipeline is only in one direction and is constraint by the fixed pressure points from the outer approximation of the Weymouth equation. See Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling for reference.","category":"page"},{"location":"concept_reference/Parameters/#block_end","page":"Parameters","title":"block_end","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The end time for the temporal_block. Can be given either as a DateTime for a static end point, or as a Duration for an end point relative to the start of the current optimization.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Indicates the end of this temporal block. The default value is equal to a duration of 0. It is useful to distinguish here between two cases: a single solve, or a rolling window optimization.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"single solve When a Date time value is chosen, this is directly the end of the optimization for this temporal block. In a single solve optimization, a combination of block_start and block_end can easily be used to run optimizations that cover only part of the model horizon. Multiple temporal_block objects can then be used to create optimizations for disconnected time periods, which is commonly used in the method of representative days. The default value coincides with the model_end.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"rolling window optimization To create a temporal block that is rolling along with the optimization window, a rolling temporal block, a duration value should be chosen. The block_end parameter will in this case determine the size of the optimization window, with respect to the start of each optimization window. If multiple temporal blocks with different block_end parameters exist, the maximum value will determine the size of the optimization window. Note, this is different from the roll_forward parameter, which determines how much the window moves for after each optimization. For more info, see One single temporal_block. The default value is equal to the roll_forward parameter.","category":"page"},{"location":"concept_reference/Parameters/#block_start","page":"Parameters","title":"block_start","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The start time for the temporal_block. Can be given either as a DateTime for a static start point, or as a Duration for an start point relative to the start of the current optimization.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Indicates the start of this temporal block. The main use of this parameter is to create an offset from the model start. The default value is equal to a duration of 0. It is useful to distinguish here between two cases: a single solve, or a rolling window optimization.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"single solve When a Date time value is chosen, this is directly the start of the optimization for this temporal block. When a duration is chosen, it is added to the model_start to obtain the start of this temporal_block. In the case of a duration, the chosen value directly marks the offset of the optimization with respect to the model_start. The default value for this parameter is the model_start.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"rolling window optimization To create a temporal block that is rolling along with the optimization window, a rolling temporal block, a duration value should be chosen. The temporal block_start will again mark the offset of the optimization start but now with respect to the start of each optimization window.","category":"page"},{"location":"concept_reference/Parameters/#candidate_connections","page":"Parameters","title":"candidate_connections","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The number of connections that may be invested in","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The candidate_connections parameter denotes the possibility of investing on a certain connection.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The default value of nothing means that the connection can't be invested in, because it's already in operation. An integer value represents the maximum investment possible at any point in time, as a factor of the connection_capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"In other words, candidate_connections is the upper bound of the connections_invested_available variable.","category":"page"},{"location":"concept_reference/Parameters/#candidate_storages","page":"Parameters","title":"candidate_storages","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Determines the maximum number of new storages which may be invested in","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Within an investments problem candidate_storages determines the upper bound on the storages investment decision variable in constraint storages_invested_available. In constraint node_state_cap the maximum node state will be the product of the storages investment variable and node_state_cap. Thus, the interpretation of candidate_storages depends on storage_investment_variable_type which determines the investment decision variable type. If storage_investment_variable_type is integer or binary, then candidate_storages represents the maximum number of discrete storages of size node_state_cap that may be invested in at the corresponding node. If storage_investment_variable_type is continuous, candidate_storages is more analagous to a maximum storage capacity with node_state_cap being analagous to a scaling parameter.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that candidate_storages is the main investment switch and setting a value other than none/nothing triggers the creation of the investment variable for storages at the corresponding node. Note that a value of zero will still trigger the variable creation but its value will be fixed to zero. This can be useful if an inspection of the related dual variables will yield the value of this resource.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Investment Optimization and storage_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#candidate_units","page":"Parameters","title":"candidate_units","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Number of units which may be additionally constructed","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Within an investments problem candidate_units determines the upper bound on the unit investment decision variable in constraint units_invested_available. In constraint unit_flow_capacity the maximum unit_flow will be the product of the units_invested_available and the corresponding unit_capacity. Thus, the interpretation of candidate_units depends on unit_investment_variable_type which determines the unit investment decision variable type. If unit_investment_variable_type is integer or binary, then candidate_units represents the maximum number of discrete units that may be invested in. If unit_investment_variable_type is continuous, candidate_units is more analagous to a maximum storage capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that candidate_units is the main investment switch and setting a value other than none/nothing triggers the creation of the investment variable for the unit. Note that a value of zero will still trigger the variable creation but its value will be fixed to zero. This can be useful if an inspection of the related dual variables will yield the value of this resource.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Investment Optimization and unit_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#commodity_lodf_tolerance","page":"Parameters","title":"commodity_lodf_tolerance","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The minimum absolute value of the line outage distribution factor (LODF) that is considered meaningful.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.1","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: commodity","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Given two connections, the line outage distribution factor (LODF) is the fraction of the pre-contingency flow on the first one, that will flow on the second after the contingency. commodity_lodf_tolerance is the minimum absolute value of the LODF that is considered meaningful. Any value below this tolerance (in absolute value) will be treated as zero.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The LODFs are used to model contingencies on some connections and their impact on some other connections. To model contingencies on a connection, set connection_contingency to true; to study the impact of such contingencies on another connection, set connection_monitored to true.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"In addition, define a commodity with commodity_physics set to commodity_physics_lodf, and associate that commodity (via node__commodity) to both connections' nodes (given by connection__to_node and connection__from_node).","category":"page"},{"location":"concept_reference/Parameters/#commodity_physics","page":"Parameters","title":"commodity_physics","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Defines if the commodity follows lodf or ptdf physics.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: commodity_physics_none","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: commodity_physics_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: commodity","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This parameter determines the specific formulation used to carry out dc load flow within a model. To enable power transfer distribution factor (ptdf) based load flow for a network of nodes and connections, all nodes must be related to a commodity with commodity_physics set to  commodity_physics_ptdf. To enable security constraint unit comment based on ptdfs and line outage distribution factors (lodf) all nodes must be related to a commodity with commodity_physics set to commodity_physics_lodf.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also powerflow","category":"page"},{"location":"concept_reference/Parameters/#commodity_ptdf_threshold","page":"Parameters","title":"commodity_ptdf_threshold","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The minimum absolute value of the power transfer distribution factor (PTDF) that is considered meaningful.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0001","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: commodity","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Given a connection and a node, the power transfer distribution factor (PTDF) is the fraction of the flow injected into the node that will flow on the connection. commodity_ptdf_threshold is the minimum absolute value of the PTDF that is considered meaningful. Any value below this threshold (in absolute value) will be treated as zero.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The PTDFs are used to model DC power flow on certain connections. To model DC power flow on a connection, set connection_monitored to true.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"In addition, define a commodity with commodity_physics set to either commodity_physics_ptdf, or commodity_physics_lodf. and associate that commodity (via node__commodity) to both connections' nodes (given by connection__to_node and connection__from_node).","category":"page"},{"location":"concept_reference/Parameters/#compression_factor","page":"Parameters","title":"compression_factor","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The compression factor establishes a compression from an origin node to a receiving node, which are connected through a connection. The first node corresponds to the origin node, the second to the (compressed) destination node. Typically the value is >=1.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This parameter is specific to the use of pressure driven gas transfer. To represent a compression between two nodes in the gas network, the compression_factor can be defined. This factor ensures that the pressure of a node is equal to (or lower than) the pressure at the sending node times the compression_factor. The relationship connection__node__node that hosts this parameter should be defined in a way that the first node represents the origin node and the second node represents the compressed node.","category":"page"},{"location":"concept_reference/Parameters/#connection_availability_factor","page":"Parameters","title":"connection_availability_factor","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Availability of the connection, acting as a multiplier on its connection_capacity. Typically between 0-1.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To indicate that a connection is only available to a certain extent or at certain times of the optimization, the connection_availability_factor can be used. A typical use case could be an availability timeseries for connection with expected outage times. By default the availability factor is set to 1. The availability is, among others, used in the constraint_connection_flow_capacity.","category":"page"},{"location":"concept_reference/Parameters/#connection_capacity","page":"Parameters","title":"connection_capacity","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Limits the connection_flow variable to the to_node. to_node can be a group of nodes, in which case the sum of the connection_flow is constrained.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Defines the upper bound on the corresponding connection_flow variable. If the connection is a candidate connection, the effective connection_flow upper bound is the product of the investment variable, connections_invested_available and connection_capacity. If ptdf based dc load flow is enabled, connection_capacity represents the normal rating of a connection (line) while connection_emergency_capacity represents the maximum post contingency flow.","category":"page"},{"location":"concept_reference/Parameters/#connection_contingency","page":"Parameters","title":"connection_contingency","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A boolean flag for defining a contingency connection.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Specifies that the connection in question is to be included as a contingency when security constrained unit commitment is enabled. When using security constrained unit commitment by setting commodity_physics to commodity_physics_lodf, an N-1 security constraint is created for each monitored line (connection_monitored = true) for each specified contingency (connection_contingency = true).","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also powerflow","category":"page"},{"location":"concept_reference/Parameters/#connection_conv_cap_to_flow","page":"Parameters","title":"connection_conv_cap_to_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for connection_capacity unit conversions in the case the connection_capacity value is incompatible with the desired connection_flow units.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The connection_conv_cap_to_flow can be used to perform the conversion between the measurement unit of the connection_capacity to the measurement unit of the connection_flow variable. The default of this parameter is 1, i.e. assuming that both are given in the same measurement unit.","category":"page"},{"location":"concept_reference/Parameters/#connection_emergency_capacity","page":"Parameters","title":"connection_emergency_capacity","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The maximum post-contingency flow on a monitored connection.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The connection_emergency_capacity parameter represents the maximum post-contingency flow on a monitored connection if ptdf and lodf based security constrained unit commitment is enabled (commodity_physics is set to [commodity_physics_lodf]).","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If you set this value, make sure that you also set connection_monitored to true for the involved connection.","category":"page"},{"location":"concept_reference/Parameters/#connection_flow_coefficient","page":"Parameters","title":"connection_flow_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"defines the user constraint coefficient on the connection flow variable in the to direction","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node__user_constraint and connection__to_node__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The connection_flow_coefficient is an optional parameter that can be used to include the connection_flow variable from or to a node in a user_constraint via the connection__from_node__user_constraint and connection__to_node__user_constraint relationships. Essentially, connection_flow_coefficient appears as a coefficient for the connection_flow variable from or to the node in the user constraint.","category":"page"},{"location":"concept_reference/Parameters/#connection_flow_cost","page":"Parameters","title":"connection_flow_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Variable costs of a flow through a connection. E.g. EUR/MWh of energy throughput.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the connection_flow_cost parameter for a specific connection, a cost term will be added to the objective function that values all connection_flow variables associated with that connection during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#connection_flow_delay","page":"Parameters","title":"connection_flow_delay","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Delays the connection_flows associated with the latter node in respect to the connection_flows associated with the first node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: Dict{String, Any}(\"data\" => \"0h\", \"type\" => \"duration\")","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The connection_flow_delay parameter denotes the amount of time that it takes for the flow to go through a connection. In other words, the flow that enters the connection is only seen at the other side after connection_flow_delay units of time.","category":"page"},{"location":"concept_reference/Parameters/#connection_investment_cost","page":"Parameters","title":"connection_investment_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The per unit investment cost for the connection over the connection_investment_lifetime","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the connection_investment_cost parameter for a specific connection, a cost term will be added to the objective function whenever a connection investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#connection_investment_lifetime","page":"Parameters","title":"connection_investment_lifetime","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Determines the minimum investment lifetime of a connection. Once invested, it remains in service for this long","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"connection_investment_lifetime is the minimum amount of time that a connection has to stay in operation once it's invested-in. Only after that time, the connection can be decomissioned. Note that connection_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/Parameters/#connection_investment_variable_type","page":"Parameters","title":"connection_investment_variable_type","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Determines whether the investment variable is integer variable_type_integer or continuous variable_type_continuous","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: variable_type_integer","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: variable_type_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The connection_investment_variable_type parameter represents the type of the connections_invested_available decision variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The default value, variable_type_integer, means that only integer factors of the connection_capacity can be invested in. The value variable_type_continuous means that any fractional factor can also be invested in. The value variable_type_binary means that only a factor of 1 or zero are possible.","category":"page"},{"location":"concept_reference/Parameters/#connection_linepack_constant","page":"Parameters","title":"connection_linepack_constant","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The linepack constant is a property of gas pipelines and relates the linepack to the pressure of the adjacent nodes.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The linepack constant is a physical property of a connection representing a pipeline and holds information on how the linepack flexibility relates to pressures of the adjacent nodes. If, and only if, this parameter is defined, the linepack flexibility of a pipeline can be modelled. The existence of the parameter triggers the generation of the constraint on line pack storage. The connection_linepack_constant should always be defined on the tuple (connection pipeline, linepack storage node, node group (containing both pressure nodes, i.e. start and end of the pipeline)). See also.","category":"page"},{"location":"concept_reference/Parameters/#connection_monitored","page":"Parameters","title":"connection_monitored","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A boolean flag for defining a contingency connection.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"When using ptdf-based load flow by setting commodity_physics to either commodity_physics_ptdf or commodity_physics_ptdf, a constraint is created for each connection for which connection_monitored = true. Thus, to monitor the ptdf-based flow on a particular connection connection_monitored must be set to true.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also powerflow","category":"page"},{"location":"concept_reference/Parameters/#connection_reactance","page":"Parameters","title":"connection_reactance","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The per unit reactance of a connection.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The per unit reactance of a transmission line. Used in ptdf based dc load flow where the relative reactances of lines determine the ptdfs of the network and in lossless dc powerflow where the flow on a line is given by flow = 1/x(theta_to-theta_from) where x is the reatance of the line, thetato is the voltage angle of the remote node and thetafrom is the voltage angle of the sending node. ","category":"page"},{"location":"concept_reference/Parameters/#connection_reactance_base","page":"Parameters","title":"connection_reactance_base","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If the reactance is given for a p.u.  (e.g. p.u. = 100MW), the connection_reactance_base can be set to perform this conversion (e.g. *100).","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"As the connection_reactance is often given on a per unit basis, often different than the units used elsewhere, the connection_reactance_base parameter serves as a conversion factor, scaling the connection_reactance with its p.u..","category":"page"},{"location":"concept_reference/Parameters/#connection_resistance","page":"Parameters","title":"connection_resistance","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The per unit resistance of a connection.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The per unit resistance of a transmission line. Currently unimplemented!","category":"page"},{"location":"concept_reference/Parameters/#connection_type","page":"Parameters","title":"connection_type","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A selector between a normal and a lossless bidirectional connection.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: connection_type_normal","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: connection_type_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used to control specific pre-processing actions on connections. Currently, the primary purpose of connection_type is to simplify the data that is required to define a simple bi-directional, lossless line. If connection_type=:connection_type_lossless_bidirectional, it is only necessary to specify the following minimum data:","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"relationship: connection__from_node\nrelationship: connection__to_node\nparameter: connection_capacity (defined on connection__from_node and/or connection__to_node)","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If connection_type=:connection_type_lossless_bidirectional the following pre-processing actions are taken:","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"reciprocal connection__from_node and connection__to_node relationships are created if they don't exist\na new connection__node__node relationship is created if none exists already\nfix_ratio_out_in_connection_flow parameter is created with the value of 1 if no existing parameter found (therefore this value can be overridden)\nThe first connection_capacity parameter found is copied to connection__from_nodes and connection__to_nodes without a defined connection_capacity.","category":"page"},{"location":"concept_reference/Parameters/#connections_invested_available_coefficient","page":"Parameters","title":"connections_invested_available_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"coefficient of connections_invested_available in the specific user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#connections_invested_coefficient","page":"Parameters","title":"connections_invested_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"coefficient of connections_invested in the specific user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The connections_invested_coefficient is an optional parameter that can be used to include the connections_invested variable in a user_constraint via the connection__user_constraint relationship. Essentially, connections_invested_coefficient appears as a coefficient for the connections_invested variable in the user constraint.","category":"page"},{"location":"concept_reference/Parameters/#constraint_sense","page":"Parameters","title":"constraint_sense","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A selector for the sense of the user_constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: ==","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: constraint_sense_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The constraint_sense parameter determines the sense of a custom user constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See User constraints for details.","category":"page"},{"location":"concept_reference/Parameters/#curtailment_cost","page":"Parameters","title":"curtailment_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Costs for curtailing generation. Essentially, accrues costs whenever unit_flow not operating at its maximum available capacity. E.g. EUR/MWh","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the curtailment_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit's available capacity exceeds its activity (i.e., the unit_flow variable) over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#cyclic_condition","page":"Parameters","title":"cyclic_condition","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If the cyclic condition is set to true for a storage node, the node_state at the end of the optimization window has to be larger than or equal to the initial storage state.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__temporal_block","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The cyclic_condition parameter is used to enforce that the storage level at the end of the optimization window is higher or equal to the storage level at the beginning optimization. If the cyclic_condition parameter is set to true for a node__temporal_block relationship, and the has_state parameter of the corrresponding node is set to true, the constraint_cyclic_node_state will be triggered.","category":"page"},{"location":"concept_reference/Parameters/#demand","page":"Parameters","title":"demand","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Demand for the commodity of a node. Energy gains can be represented using negative demand.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The demand parameter represents a \"demand\" or a \"load\" of a commodity on a node. It appears in the node injection constraint, with positive values interpreted as \"demand\" or \"load\" for the modelled system, while negative values provide the system with \"influx\" or \"gain\". When the node is part of a group, the fractional_demand parameter can be used to split demand into fractions, when desired. See also: Introduction to groups of objects","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The demand parameter can also be included in custom user_constraints using the demand_coefficient parameter for the node__user_constraint relationship.","category":"page"},{"location":"concept_reference/Parameters/#demand_coefficient","page":"Parameters","title":"demand_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"coefficient of the specified node's demand in the specified user constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The demand_coefficient is an optional parameter that can be used to include the demand of the a node in a user_constraint via the node__user_constraint relationship. Essentially, demand_coefficient appears as a coefficient for the demand parameter of the connected node in the user constraint.","category":"page"},{"location":"concept_reference/Parameters/#diff_coeff","page":"Parameters","title":"diff_coeff","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Commodity diffusion coefficient between two nodes. Effectively, denotes the diffusion power per unit of state from the first node to the second.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The diff_coeff parameter represents diffusion of a commodity between the two nodes in the node__node relationship. It appears as a coefficient on the node_state variable in the node injection constraint, essentially representing diffusion power per unit of state. Note that the diff_coeff is interpreted as one-directional, meaning that if one defines","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"diff_coeff(node1=n1, node2=n2),","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"there will only be diffusion from n1 to n2, but not vice versa. Symmetric diffusion is likely used in most cases, requiring defining the diff_coeff both ways","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"diff_coeff(node1=n1, node2=n2) == diff_coeff(node1=n2, node2=n1).","category":"page"},{"location":"concept_reference/Parameters/#downward_reserve","page":"Parameters","title":"downward_reserve","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Identifier for nodes providing downward reserves","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If a node has a true is_reserve_node parameter, it will be treated as a reserve node in the model. To define whether the node corresponds to an upward or downward reserve commodity, the upward_reserve or the downward_reserve parameter needs to be set to true, respectively.","category":"page"},{"location":"concept_reference/Parameters/#duration_unit","page":"Parameters","title":"duration_unit","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Defines the base temporal unit of the model. Currently supported values are either an hour or a minute.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: hour","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: duration_unit_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The duration_unit parameter specifies the base unit of time in a model. Two values are currently supported, hour and the default minute. E.g. if the duration_unit is set to hour, a Duration of one minute gets converted into 1/60 hours for the calculations.","category":"page"},{"location":"concept_reference/Parameters/#fix_binary_gas_connection_flow","page":"Parameters","title":"fix_binary_gas_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the value of the connection_flow_binary variable, and hence pre-determine the direction of flow in the connection.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The binary flow of a gas pipelines for pressure driven gas transfer is enables through the binary variable binary_gas_connection_flow and the big_m constant. To fix this binary variable, i.e. pre-define the direction of gas through the pipelines, the fix_binary_gas_connection_flow parameter can be used.","category":"page"},{"location":"concept_reference/Parameters/#fix_connection_flow","page":"Parameters","title":"fix_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the value of the connection_flow variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_connection_flow parameter fixes the value of the connection_flow variable.","category":"page"},{"location":"concept_reference/Parameters/#fix_connection_intact_flow","page":"Parameters","title":"fix_connection_intact_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the value of the connection_intact_flow variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node and connection__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_connection_intact_flow parameter can be used to fix the values of the connection_intact_flow variable to preset values. If set to a Scalar type value, the connection_intact_flow variable is fixed to that value for all time steps and stochastic_scenarios. Values for individual time steps can be fixed using TimeSeries type values.","category":"page"},{"location":"concept_reference/Parameters/#fix_connections_invested","page":"Parameters","title":"fix_connections_invested","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Setting a value fixes the connections_invested variable accordingly","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_connections_invested parameter can be used to fix the values of the connections_invested variable to preset values. If set to a Scalar type value, the connections_invested variable is fixed to that value for all time steps and stochastic_scenarios. Values for individual time steps can be fixed using TimeSeries type values.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See Investment Optimization for more information about the investment framework in SpineOpt.jl.","category":"page"},{"location":"concept_reference/Parameters/#fix_connections_invested_available","page":"Parameters","title":"fix_connections_invested_available","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Setting a value fixes the connectionsinvestedavailable variable accordingly","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_connections_invested_available parameter represents a forced connection investment.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"In other words, it is the fix value of the connections_invested_available variable.","category":"page"},{"location":"concept_reference/Parameters/#fix_node_pressure","page":"Parameters","title":"fix_node_pressure","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fixes the corresponding node_pressure variable to the provided value","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"In a pressure driven gas model, gas network nodes are associated with the node_pressure variable. In order to fix the pressure at a certain node or to give intial conditions the fix_node_pressure parameter can be used.","category":"page"},{"location":"concept_reference/Parameters/#fix_node_state","page":"Parameters","title":"fix_node_state","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fixes the corresponding node_state variable to the provided value. Can be used for e.g. fixing boundary conditions.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_node_state parameter simply fixes the value of the node_state variable to the provided value, if one is found. Common uses for the parameter include e.g. providing initial values for node_state variables, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the node_state variables are only fixed for time steps with defined fix_node_state parameter values.","category":"page"},{"location":"concept_reference/Parameters/#fix_node_voltage_angle","page":"Parameters","title":"fix_node_voltage_angle","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fixes the corresponding node_voltage_angle variable to the provided value","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"For a lossless nodal DC power flow network, each node is associated with a node_voltage_angle variable. In order to fix the voltage angle at a certain node or to give initial conditions the fix_node_voltage_angle parameter can be used.","category":"page"},{"location":"concept_reference/Parameters/#fix_nonspin_ramp_down_unit_flow","page":"Parameters","title":"fix_nonspin_ramp_down_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the nonspin_ramp_down_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_nonspin_ramp_down_unit_flow parameter simply fixes the value of the nonspin_ramp_down_unit_flow variable to the provided value. As such, it determines directly how much non-spinning downward reserve commodity flows the relevant unit is providing to the node to which it is linked by the unit__to_node relationship.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"When a single value is selected, this value is kept constant throughout the model. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/Parameters/#fix_nonspin_ramp_up_unit_flow","page":"Parameters","title":"fix_nonspin_ramp_up_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the nonspin_ramp_up_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_nonspin_ramp_up_unit_flow parameter simply fixes the value of the nonspin_ramp_up_unit_flow variable to the provided value. As such, it determines directly how much non-spinning upward reserve commodity flows the relevant unit is providing to the node to which it is linked by the unit__to_node relationship.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"When a single value is selected, this value is kept constant throughout the model. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/Parameters/#fix_nonspin_units_shut_down","page":"Parameters","title":"fix_nonspin_units_shut_down","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the nonspin_units_shut_down variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_nonspin_units_shut_down parameter simply fixes the value of the nonspin_units_shut_down variable to the provided value. As such, it determines directly how many member units are involved in providing downward reserve commodity flows to the node to which it is linked by the unit__to_node relationship.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"When a single value is selected, this value is kept constant throughout the model. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/Parameters/#fix_nonspin_units_started_up","page":"Parameters","title":"fix_nonspin_units_started_up","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the nonspin_units_started_up variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_nonspin_units_started_up parameter simply fixes the value of the nonspin_units_started_up variable to the provided value. As such, it determines directly how many member units are involved in providing upward reserve commodity flows to the node to which it is linked by the unit__to_node relationship.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"When a single value is selected, this value is kept constant throughout the model. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/Parameters/#fix_ramp_down_unit_flow","page":"Parameters","title":"fix_ramp_down_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the ramp_down_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_ramp_down_unit_flow parameter simply fixes the value of the ramp_down_unit_flow variable to the provided value. It is possible to provide an incomplete timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/Parameters/#fix_ramp_up_unit_flow","page":"Parameters","title":"fix_ramp_up_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the ramp_up_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_ramp_up_unit_flow parameter simply fixes the value of the ramp_up_unit_flow variable to the provided value. It is possible to provide an incomplete timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_in_in_unit_flow","page":"Parameters","title":"fix_ratio_in_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the ratio between two unit_flows coming into the unit from the two nodes.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_in_in_unit_flow parameter triggers the generation of the constraint_fix_ratio_in_in_unit_flow and fixes the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of in1 over in2, where in1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right order. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. for a unit u a fixed share of 0.8 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the fix_ratio_in_in_unit_flow parameter would be set to 0.8 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_in_out_unit_flow","page":"Parameters","title":"fix_ratio_in_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the ratio between an incoming unit_flow from the first node and an outgoing unit_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_in_out_unit_flow parameter triggers the generation of the constraint_fix_ratio_in_out_unit_flow and fixes the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the from_node,i i.e. the incoming flows to the unit, and the second node (or group of nodes), represents the to_node i.e. the outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of in over out, where in is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. a fixed ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing flows to the node group el_heat (consisting of the two nodes el and heat), the fix_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_out_in_connection_flow","page":"Parameters","title":"fix_ratio_out_in_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the ratio between the connection_flow from the first node and the connection_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_out_in_connection_flow parameter triggers the generation of the constraint_fix_ratio_out_in_connection_flow and fixes the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection. In most cases the fix_ratio_out_in_connection_flow parameter is set to equal or lower than 1, linking the flows entering to the flows leaving the connection. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the connection_flow variable from the first node in the connection__node__node relationship in a left-to-right order. The parameter can be used to e.g. account for losses over a connection in a certain direction.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. a fixed ratio of 0.8 for a connection conn between its outgoing electricity flow to node el1 and its incoming flows from the node node el2, the fix_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship u__el1__el2.","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_out_in_unit_flow","page":"Parameters","title":"fix_ratio_out_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the ratio between an outgoing unit_flow to the first node and an incoming unit_flow from the second node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_out_in_unit_flow parameter triggers the generation of the constraint_fix_ratio_out_in_unit_flow and fixes the ratio between out and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. a fixed ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ngthe fix_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/Parameters/#fix_ratio_out_out_unit_flow","page":"Parameters","title":"fix_ratio_out_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the ratio between two unit_flows going from the unit into the two nodes.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the fix_ratio_out_out_unit_flow parameter triggers the generation of the constraint_fix_ratio_out_out_unit_flow and fixes the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of out1 over out2, where out1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce a fixed ratio between two products of a unit u, e.g. fixing the share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"concept_reference/Parameters/#fix_shut_down_unit_flow","page":"Parameters","title":"fix_shut_down_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the shut_down_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_shut_down_unit_flow parameter fixes the value of the shut_down_unit_flow to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Common uses for the parameter include e.g. providing initial values for the shut_down_unit_flow, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the shut_down_unit_flow variable is only fixed for time steps with defined fix_shut_down_unit_flow parameter values.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that the mentioned shut_down_unit_flow variable is only included if the parameter max_startup_ramp exist for the correspond unit__to_node or unit__from_node relationship. The usage of ramps is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/Parameters/#fix_start_up_unit_flow","page":"Parameters","title":"fix_start_up_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the start_up_unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_start_up_unit_flow parameter fixes the value of the start_up_unit_flow to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Common uses for the parameter include e.g. providing initial values for the start_up_unit_flow, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the start_up_unit_flow variable is only fixed for time steps with defined fix_start_up_unit_flow parameter values.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that the mentioned start_up_unit_flow variable is only included if the parameter max_startup_ramp exist for the correspond unit__to_node or unit__from_node relationship. The usage of ramps is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/Parameters/#fix_storages_invested","page":"Parameters","title":"fix_storages_invested","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used to fix the value of the storages_invested variable","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used primarily to fix the value of the storages_invested variable which represents the point-in-time storage investment decision variable at a node and how many candidate storages are invested-in in a particular timeslice at the corresponding node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Investment Optimization, candidate_storages and storage_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#fix_storages_invested_available","page":"Parameters","title":"fix_storages_invested_available","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used to fix the value of the storagesinvestedavailable variable","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used primarily to fix the value of the storages_invested_available variable which represents the storages investment decision variable and how many candidate storages are available at the corresponding node, time step and stochastic scenario. Used also in the decomposition framework to communicate the value of the master problem solution variables to the operational sub-problem.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also candidate_storages and Investment Optimization","category":"page"},{"location":"concept_reference/Parameters/#fix_unit_flow","page":"Parameters","title":"fix_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the unit_flow variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_unit_flow parameter fixes the value of the unit_flow variable to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Common uses for the parameter include e.g. providing initial values for the unit_flow variable, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the unit_flow variable is only fixed for time steps with defined fix_unit_flow parameter values.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/Parameters/#fix_unit_flow_op","page":"Parameters","title":"fix_unit_flow_op","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the unit_flow_op variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If operating_points is defined on a certain unit__to_node or unit__from_node flow, the corresponding unit_flow flow variable is decomposed into a number of sub-variables, unit_flow_op one for each operating point, with an additional index, i to reference the specific operating point. fix_unit_flow_op can thus be used to fix the value of one or more of the variables as desired.","category":"page"},{"location":"concept_reference/Parameters/#fix_units_invested","page":"Parameters","title":"fix_units_invested","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the value of the units_invested variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used primarily to fix the value of the units_invested variable which represents the point-in-time unit investment decision variable and how many candidate units are invested-in in a particular timeslice.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Investment Optimization, candidate_units and unit_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#fix_units_invested_available","page":"Parameters","title":"fix_units_invested_available","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the value of the units_invested_available variable","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used primarily to fix the value of the units_invested_available variable which represents the unit investment decision variable and how many candidate units are invested-in and available at the corresponding node, time step and stochastic scenario. Used also in the decomposition framework to communicate the value of the master problem solution variables to the operational sub-problem.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Investment Optimization, candidate_units and unit_investment_variable_type","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on","page":"Parameters","title":"fix_units_on","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fix the value of the units_on variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_units_on parameter simply fixes the value of the units_on variable to the provided value. As such, it determines directly how many members of the specific unit will be online throughout the model when a single value is selected. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on_coefficient_in_in","page":"Parameters","title":"fix_units_on_coefficient_in_in","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the fix_ratio_in_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_units_on_coefficient_in_in parameter is an optional coefficient in the unit input-input ratio constraint controlled by the fix_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_out, fix_units_on_coefficient_out_in, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g. min_units_on_coefficient_in_in and max_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on_coefficient_in_out","page":"Parameters","title":"fix_units_on_coefficient_in_out","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the fix_ratio_in_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_units_on_coefficient_in_out parameter is an optional coefficient in the unit input-output ratio constraint controlled by the fix_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_out_in, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_in_out and max_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on_coefficient_out_in","page":"Parameters","title":"fix_units_on_coefficient_out_in","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the fix_ratio_out_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_units_on_coefficient_out_in parameter is an optional coefficient in the unit output-input ratio constraint controlled by the fix_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_out_in and max_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/Parameters/#fix_units_on_coefficient_out_out","page":"Parameters","title":"fix_units_on_coefficient_out_out","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the fix_ratio_out_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fix_units_on_coefficient_out_out parameter is an optional coefficient in the unit output-output ratio constraint controlled by the fix_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, and fix_units_on_coefficient_out_in, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_out_out and max_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/Parameters/#fixed_pressure_constant_0","page":"Parameters","title":"fixed_pressure_constant_0","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fixed pressure points for pipelines for the outer approximation of the Weymouth approximation. The direction of flow is the first node in the relationship to the second node in the relationship.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"For the MILP representation of pressure driven gas transfer, we use an outer approximation approach as described by Schwele et al.. The Weymouth equation is approximated around fixed pressure points, as described by the constraint on fixed node pressure points, constraining the average flow in each direction dependent on the adjacent node pressures. The second fixed pressure constant, which will be multiplied with the pressure of the destination node, is represented by an Array value of the fixed_pressure_constant_0. The first pressure constant corresponds to the related parameter fixed_pressure_constant_1. Note that the fixed_pressure_constant_0 parameter should be defined on a connection__node__node relationship, for which the first node corresponds to the origin node, while the second node corresponds to the destination node. For a typical gas pipeline, the will be a fixed_pressure_constant_1  for both directions of flow.","category":"page"},{"location":"concept_reference/Parameters/#fixed_pressure_constant_1","page":"Parameters","title":"fixed_pressure_constant_1","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fixed pressure points for pipelines for the outer approximation of the Weymouth approximation. The direction of flow is the first node in the relationship to the second node in the relationship.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"For the MILP representation of pressure driven gas transfer, we use an outer approximation approach as described by Schwele et al.. The Weymouth equation is approximated around fixed pressure points, as described by the constraint on fixed node pressure points, constraining the average flow in each direction dependent on the adjacent node pressures. The first fixed pressure constant, which will be multiplied with the pressure of the origin node, is represented by an Array value of the fixed_pressure_constant_1. The second pressure constant corresponds to the related parameter fixed_pressure_constant_0. Note that the fixed_pressure_constant_1 parameter should be defined on a connection__node__node relationship, for which the first node corresponds to the origin node, while the second node corresponds to the destination node. For a typical gas pipeline, the will be a fixed_pressure_constant_1  for both directions of flow.","category":"page"},{"location":"concept_reference/Parameters/#fom_cost","page":"Parameters","title":"fom_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Fixed operation and maintenance costs of a unit. Essentially, a cost coefficient on the number_of_units and unit_capacity parameters. E.g. EUR/MWh","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the fom_cost parameter for a specific unit, a cost term will be added to the objective function to account for the fixed operation and maintenance costs associated with that unit during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#frac_state_loss","page":"Parameters","title":"frac_state_loss","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Self-discharge coefficient for node_state variables. Effectively, represents the loss power per unit of state.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The frac_state_loss parameter allows setting self-discharge losses for nodes with the node_state variables enabled using the has_state variable. Effectively, the frac_state_loss parameter acts as a coefficient on the node_state variable in the node injection constraint, imposing losses for the node. In simple cases, storage losses are typically fractional, e.g. a frac_state_loss parameter value of 0.01 would represent 1% of node_state lost per unit of time. However, a more general definition of what the frac_state_loss parameter represents in SpineOpt would be loss power per unit of node_state.","category":"page"},{"location":"concept_reference/Parameters/#fractional_demand","page":"Parameters","title":"fractional_demand","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The fraction of a node group's demand applied for the node in question.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Whenever a node is a member of a group, the fractional_demand parameter represents its share of the group's demand.","category":"page"},{"location":"concept_reference/Parameters/#fuel_cost","page":"Parameters","title":"fuel_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Variable fuel costs than can be attributed to a unit_flow. E.g. EUR/MWh","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the fuel_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for costs associated with the unit's fuel usage over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#graph_view_position","page":"Parameters","title":"graph_view_position","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"An optional setting for tweaking the position of the different elements when drawing them via Spine Toolbox Graph View.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection, node and unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__from_node, connection__to_node, unit__from_node__user_constraint, unit__from_node, unit__to_node__user_constraint and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The graph_view_position parameter can be used to fix the positions of various objects and relationships when plotted using the Spine Toolbox Graph View. If not defined, Spine Toolbox simply plots the element in question wherever it sees fit in the graph.","category":"page"},{"location":"concept_reference/Parameters/#has_binary_gas_flow","page":"Parameters","title":"has_binary_gas_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This parameter needs to be set to true in order to represent bidirectional pressure drive gas transfer.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: connection","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This parameter is necessary for the use of pressure driven gas transfer, for which the direction of flow is not known a priori. The parameter has_binary_gas_flow is a booelean method parameter, which - when set to true - triggers the generation of the binary variables binary_gas_connection_flow, which (together with the big_m parameter) forces the average flow through a pipeline to be unidirectional.","category":"page"},{"location":"concept_reference/Parameters/#has_pressure","page":"Parameters","title":"has_pressure","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A boolean flag for whether a node has a node_pressure variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If a node is to represent a node in a pressure driven gas network, the boolean parameter has_pressure should be set true, in order to trigger the generation of the node_pressure variable. The pressure at a certain node can also be constrainted through the parameters max_node_pressure and min_node_pressure. More details on the use of pressure driven gas transfer are described here","category":"page"},{"location":"concept_reference/Parameters/#has_state","page":"Parameters","title":"has_state","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A boolean flag for whether a node has a node_state variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The has_state parameter is simply a Bool flag for whether a node has a node_state variable. By default, it is set to false, so the nodes enforce instantaneous commodity balance according to the nodal balance and node injection constraints. If set to true, the node will have a node_state variable generated for it, allowing for commodity storage at the node. Note that you'll also have to specify a value for the state_coeff parameter, as otherwise the node_state variable has zero commodity capacity.","category":"page"},{"location":"concept_reference/Parameters/#has_voltage_angle","page":"Parameters","title":"has_voltage_angle","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A boolean flag for whether a node has a node_voltage_angle variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"For the use of node-based lossless DC powerflow, each node will be associated with a node_voltage_angle variable. To enable the generation of the variable in the optimization model, the boolean parameter has_voltage_angle should be set true. The voltage angle at a certain node can also be constrained through the parameters max_voltage_angle and min_voltage_angle. More details on the use of  lossless nodal DC power flows are described here","category":"page"},{"location":"concept_reference/Parameters/#is_active","page":"Parameters","title":"is_active","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If false, the object is excluded from the model if the tool filter object activity control is specified","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: true","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: commodity, connection, model, node, output, report, stochastic_scenario, stochastic_structure, temporal_block, unit and user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"is_acive is a universal, utility parameter that is defined for every object class. When used in conjunction with the activity_control feature, the is_active parameter allows one to control whether or not a specific object is active within a model or not. ","category":"page"},{"location":"concept_reference/Parameters/#is_non_spinning","page":"Parameters","title":"is_non_spinning","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A boolean flag for whether a node is acting as a non-spinning reserve","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By setting the parameter is_non_spinning to true, a node is treated as a non-spinning reserve node. Note that this is only to differentiate spinning from non-spinning reserves. It is still necessary to define the is_reserve_node to true. reserve node in the model. To define the maximum reserve provision of a non-spinning reserve flow (defined on a unit__to_node relationship), it is also necessary to define the max_res_startup_ramp and the max_res_shutdown_ramp parameters, respectively. It is also possible to define a minimum reserve provision ramp by defining the parameters min_res_startup_ramp and min_res_shutdown_ramp. The mathematical formulation holds a chapter on Ramping and reserve constraints and the general concept of setting up a model with reserves is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/Parameters/#is_reserve_node","page":"Parameters","title":"is_reserve_node","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A boolean flag for whether a node is acting as a reserve_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By setting the parameter is_reserve_node to true, a node is treated as a reserve node in the model. Units that are linked through a unit__to_node relationship will be able to provide balancing services to the reserve node, but within their technical feasibility. The mathematical formulation holds a chapter on Ramping and reserve constraints and the general concept of setting up a model with reserves is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/Parameters/#max_cum_in_unit_flow_bound","page":"Parameters","title":"max_cum_in_unit_flow_bound","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Set a maximum cumulative upper bound for a unit_flow","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__commodity","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To impose a limit on the cumulative in flows to a unit for the entire modelling horizon, e.g. to enforce limits on emissions, the max_cum_in_unit_flow_bound parameter can be used. Defining this parameter triggers the generation of the constraint_max_cum_in_unit_flow_bound.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Assuming for instance that the total intake of a unit u_A should not exceed 10MWh for the entire modelling horizon, then the max_cum_in_unit_flow_bound would need to take the value 10. (Assuming here that the unit_flow variable is in MW, and the model duration_unit is hours)","category":"page"},{"location":"concept_reference/Parameters/#max_gap","page":"Parameters","title":"max_gap","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Specifies the maximum optimality gap for the model. Currently only used for the master problem within a decomposed structure","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.05","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This determines the optimality convergence criterion and is the benders gap tolerance for the master problem in a decomposed investments model. The benders gap is the relative difference between the current objective function upper bound(zupper) and lower bound (zlower) and is defined as 2*(zupper-zlower)/(zupper + zlower). When this value is lower than max_gap the benders algorithm will terminate having achieved satisfactory optimality.","category":"page"},{"location":"concept_reference/Parameters/#max_iterations","page":"Parameters","title":"max_iterations","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Specifies the maximum number of iterations for the model. Currently only used for the master problem within a decomposed structure","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 10.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"When the model in question is of type :spineopt_master, this determines the maximum number of Benders iterations.","category":"page"},{"location":"concept_reference/Parameters/#max_node_pressure","page":"Parameters","title":"max_node_pressure","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum allowed gas pressure at node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If a node has a node_pressure variable (see also the parameter has_pressure and this chapter), an upper bound on the pressure can be introduced through the max_node_pressure parameter, which triggers the generation of the maxmimum node pressure constraint.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_in_in_unit_flow","page":"Parameters","title":"max_ratio_in_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum ratio between two unit_flows coming into the unit from the two nodes.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_in_in_unit_flow parameter triggers the generation of the constraint_max_ratio_in_in_unit_flow and enforces an upper bound on the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of in1 over in2, where in1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. for a unit u a maximum share of 0.8 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the max_ratio_in_in_unit_flow parameter would be set to 0.8 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_in_out_unit_flow","page":"Parameters","title":"max_ratio_in_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum ratio between an incoming unit_flow from the first node and an outgoing unit_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_in_out_unit_flow parameter triggers the generation of the constraint_max_ratio_in_out_unit_flow and sets an upper bound on the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the from_node, i.e. the incoming flows to the unit, and the second node (or group of nodes), represents the to_node i.e. the outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of in over out, where in is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. a maximum ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing flow to the node group el_heat (consisting of the two nodes el and heat), the max_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_out_in_connection_flow","page":"Parameters","title":"max_ratio_out_in_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum ratio between the connection_flow from the first node and the connection_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_out_in_connection_flow parameter triggers the generation of the constraint_max_ratio_out_in_connection_flow and sets an upper bound on the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the connection_flow variable from the first node in the connection__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. a maximum ratio of 0.8 for a connection conn between its outgoing electricity flow to node commodity1 and its incoming flows from the node node commodity2, the max_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship conn__commodity1__commodity2.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that the ratio can also be defined for connection__node__node relationships where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_out_in_unit_flow","page":"Parameters","title":"max_ratio_out_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum ratio between an outgoing unit_flow to the first node and an incoming unit_flow from the second node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_out_in_unit_flow parameter triggers the generation of the constraint_max_ratio_out_in_unit_flow and enforces an upper bound on the ratio between outgoing and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. a maximum ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ng the max_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/Parameters/#max_ratio_out_out_unit_flow","page":"Parameters","title":"max_ratio_out_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum ratio between two unit_flows going from the unit into the two nodes.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the max_ratio_out_out_unit_flow parameter triggers the generation of the constraint_max_ratio_out_out_unit_flow and sets an upper bound on the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of out1 over out2, where out1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce a maximum ratio between two products of a unit u, e.g. setting the maximum share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"concept_reference/Parameters/#max_res_shutdown_ramp","page":"Parameters","title":"max_res_shutdown_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum non-spinning reserve ramp-down for online units providing reserves during shut-downs","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning downward reserves are provided to a downward_reserve node by contracted units holding available to shutdown. To include the provision of nonspinning downward reserves, the parameter max_res_shutdown_ramp needs to be defined on the corresponding unit__to_node relationship. This will trigger the generation of the variables nonspin_units_shut_down and nonspin_ramp_down_unit_flow and the constraint on maximum downward nonspinning reserve provision. Note that max_res_shutdown_ramp is given as a fraction of the unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/Parameters/#max_res_startup_ramp","page":"Parameters","title":"max_res_startup_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum non-spinning reserve ramp-up for offline units scheduled for reserve provision","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning upward reserves are provided to a upward_reserve node by contracted offline units holding available to startup. To include the provision of nonspinning upward reserves, the parameter max_res_startup_ramp needs to be defined on the corresponding unit__to_node relationship. This will trigger the generation of the variables nonspin_units_started_up and nonspin_ramp_up_unit_flow and the constraint on maximum upward nonspinning reserve provision. Note that max_res_startup_ramp is given as a fraction of the unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/Parameters/#max_shutdown_ramp","page":"Parameters","title":"max_shutdown_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum ramp-down during shutdowns","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the max_shutdown_ramp parameter will trigger the creation of the constraint on maximum shutdown ramp. It sets an upper bound on the unit_flow variable for the timestep right before a shutdown.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/Parameters/#max_startup_ramp","page":"Parameters","title":"max_startup_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum ramp-up during startups","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the max_startup_ramp parameter will trigger the creation of the Constraint on upward start up ramp_up. It sets an upper bound on the unit_flow variable for the timestep right after a startup.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/Parameters/#max_units_on_coefficient_in_in","page":"Parameters","title":"max_units_on_coefficient_in_in","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the max_ratio_in_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The max_units_on_coefficient_in_in parameter is an optional coefficient in the unit input-input ratio constraint controlled by the max_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_out, max_units_on_coefficient_out_in, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_in_in and fix_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/Parameters/#max_units_on_coefficient_in_out","page":"Parameters","title":"max_units_on_coefficient_in_out","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the max_ratio_in_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The max_units_on_coefficient_in_out parameter is an optional coefficient in the unit input-output ratio constraint controlled by the max_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_out_in, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_in_out and fix_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/Parameters/#max_units_on_coefficient_out_in","page":"Parameters","title":"max_units_on_coefficient_out_in","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the max_ratio_out_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The max_units_on_coefficient_out_in parameter is an optional coefficient in the unit output-input ratio constraint controlled by the max_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_in_out, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g. min_units_on_coefficient_out_in and fix_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/Parameters/#max_units_on_coefficient_out_out","page":"Parameters","title":"max_units_on_coefficient_out_out","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the max_ratio_out_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The max_units_on_coefficient_out_out parameter is an optional coefficient in the unit output-output ratio constraint controlled by the max_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_out_in, and max_units_on_coefficient_in_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_out_out and fix_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/Parameters/#max_voltage_angle","page":"Parameters","title":"max_voltage_angle","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum allowed voltage angle at node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If a node has a node_voltage_angle variable (see also the parameter has_voltage_angle and this chapter), an upper bound on the voltage angle can be introduced through the max_voltage_angle parameter, which triggers the generation of the maximum node voltage angle constraint.","category":"page"},{"location":"concept_reference/Parameters/#min_down_time","page":"Parameters","title":"min_down_time","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum downtime of a unit after it shuts down.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the min_down_time parameter will trigger the creation of the Constraint on minimum down time. It sets a lower bound on the period that a unit has to stay offline after a shutdown.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"It can be defined for a unit and will then impose restrictions on the units_on variables that represent the on- or offline status of the unit. The parameter is given as a duration value. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"For a more complete description of unit commmitment restrictions, see Unit commitment.","category":"page"},{"location":"concept_reference/Parameters/#min_node_pressure","page":"Parameters","title":"min_node_pressure","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum allowed gas pressure at node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If a node has a node_pressure variable (see also the parameter has_pressure and this chapter), a lower bound on the pressure can be introduced through the min_node_pressure parameter, which triggers the generation of the minimum node pressure constraint.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_in_in_unit_flow","page":"Parameters","title":"min_ratio_in_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum ratio between two unit_flows coming into the unit from the two nodes.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the min_ratio_in_in_unit_flow parameter triggers the generation of the constraint_min_ratio_in_in_unit_flow and sets a lower bound for the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of in1 over in2, where in1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. for a unit u a minimum share of 0.2 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the min_ratio_in_in_unit_flow parameter would be set to 0.2 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_in_out_unit_flow","page":"Parameters","title":"min_ratio_in_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum ratio between an incoming unit_flow from the first node and an outgoing unit_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the min_ratio_in_out_unit_flow parameter triggers the generation of the constraint_min_ratio_in_out_unit_flow and enforces a lower bound on the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes, see) in this relationship represents the from_node, i.e. the incoming flow to the unit, and the second node (or group of nodes) represents the to_node i.e. the outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of in over out, where in is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. a minimum ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing flow to the node group el_heat (consisting of the two nodes el and heat), the fix_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_out_in_connection_flow","page":"Parameters","title":"min_ratio_out_in_connection_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum ratio between the connection_flow from the first node and the connection_flow to the second node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: connection__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the min_ratio_out_in_connection_flow parameter triggers the generation of the constraint_min_ratio_out_in_connection_flow and sets a lower bound on the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the connection_flow variable from the first node in the connection__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that the ratio can also be defined for connection__node__node relationships, where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. a minimum ratio of 0.2 for a connection conn between its outgoing electricity flow to node commodity1 and its incoming flows from the node node commodity2, the min_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship conn__commodity1__commodity2.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_out_in_unit_flow","page":"Parameters","title":"min_ratio_out_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum ratio between an outgoing unit_flow to the first node and an incoming unit_flow from the second node.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the [min_ratio_out_in_unit_flow] parameter triggers the generation of the constraint_min_ratio_out_in_unit_flow and corresponds to a lower bound of the ratio between out and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce e.g. a minimum ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ng the min_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/Parameters/#min_ratio_out_out_unit_flow","page":"Parameters","title":"min_ratio_out_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum ratio between two unit_flows going from the unit into the two nodes.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the min_ratio_out_out_unit_flow parameter triggers the generation of the constraint_min_ratio_out_out_unit_flow and enforces a lower bound on the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of out1 over out2, where out1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To enforce a minimum ratio between two products of a unit u, e.g. setting the minimum share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"concept_reference/Parameters/#min_res_shutdown_ramp","page":"Parameters","title":"min_res_shutdown_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum non-spinning reserve ramp-down for online units providing reserves during shut-downs","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning downward reserves are provided by contracted units holding available to shutdown to a downward_reserve node. If a unit is scheduled to provide nonspinning reserve, a limit on the minimum amount of reserves provided can be imposed by defining the parameter min_res_shutdown_ramp on a unit__to_node relationship, which triggers the constraint on minimum downward nonspinning reserve provision. The parameter min_res_shutdown_ramp is given as a fraction of the unit_capacity of the corresponding unit__to_node relationship.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that to include the provision of nonspinning downward reserves, the parameter max_res_shutdown_ramp needs to be defined on the corresponding unit__to_node relationship, which triggers the generation of the variables nonspin_units_shut_down and nonspin_ramp_down_unit_flow.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/Parameters/#min_res_startup_ramp","page":"Parameters","title":"min_res_startup_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum non-spinning reserve ramp-up for offline units scheduled for reserve provision","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning upward reserves are provided to an upward_reserve node by contracted offline units holding available to startup. If a unit is scheduled to provide nonspinning reserve, a limit on the minimum amount of reserves provided can be imposed by defining the parameter min_res_startup_ramp on a unit__to_node relationship, which triggers the constraint on minimum upward nonspinning reserve provision. The parameter min_res_startup_ramp is given as a fraction of the unit_capacity of the corresponding unit__to_node relationship.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that to include the provision of nonspinning upward reserves, the parameter max_res_startup_ramp needs to be defined on the corresponding unit__to_node relationship, which triggers the generation of the variables nonspin_units_started_up and nonspin_ramp_up_unit_flow.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/Parameters/#min_shutdown_ramp","page":"Parameters","title":"min_shutdown_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum ramp-up during startups","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the min_shutdown_ramp parameter will trigger the creation of the constraint on minimum shutdown ramp. It sets a lower bound on the unit_flow variable for the timestep right before a shutdown.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/Parameters/#min_startup_ramp","page":"Parameters","title":"min_startup_ramp","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum ramp-up during startups","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the min_startup_ramp parameter will trigger the creation of the constraint on minimum startup ramp. It sets a lower bound on the unit_flow variable for the timestep right after a startup.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/Parameters/#min_units_on_coefficient_in_in","page":"Parameters","title":"min_units_on_coefficient_in_in","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the min_ratio_in_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The min_units_on_coefficient_in_in parameter is an optional coefficient in the unit input-input ratio constraint controlled by the min_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_out, min_units_on_coefficient_out_in, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_in_in and fix_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/Parameters/#min_units_on_coefficient_in_out","page":"Parameters","title":"min_units_on_coefficient_in_out","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the min_ratio_in_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The min_units_on_coefficient_in_out parameter is an optional coefficient in the unit input-output ratio constraint controlled by the min_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_out_in, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g. max_units_on_coefficient_in_out and fix_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/Parameters/#min_units_on_coefficient_out_in","page":"Parameters","title":"min_units_on_coefficient_out_in","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the min_ratio_out_in_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The min_units_on_coefficient_out_in parameter is an optional coefficient in the unit output-input ratio constraint controlled by the min_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_out_in and fix_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/Parameters/#min_units_on_coefficient_out_out","page":"Parameters","title":"min_units_on_coefficient_out_out","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for the units_on variable impacting the min_ratio_out_out_unit_flow constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The min_units_on_coefficient_out_out parameter is an optional coefficient in the unit output-output ratio constraint controlled by the min_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, and min_units_on_coefficient_out_in, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_out_out and fix_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/Parameters/#min_up_time","page":"Parameters","title":"min_up_time","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum uptime of a unit after it starts up.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the min_up_time parameter will trigger the creation of the Constraint on minimum up time. It sets a lower bound on the period that a unit has to stay online after a startup.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"It can be defined for a unit and will then impose restrictions on the units_on variables that represent the on- or offline status of the unit. The parameter is given as a duration value. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"For a more complete description of unit commmitment restrictions, see Unit commitment.","category":"page"},{"location":"concept_reference/Parameters/#min_voltage_angle","page":"Parameters","title":"min_voltage_angle","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum allowed voltage angle at node. ","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If a node has a node_voltage_angle variable (see also the parameter has_voltage_angle and this chapter), a lower bound on the pressure can be introduced through the min_voltage_angle parameter, which triggers the generation of the minimum node voltage angle constraint.","category":"page"},{"location":"concept_reference/Parameters/#minimum_operating_point","page":"Parameters","title":"minimum_operating_point","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum level for the unit_flow relative to the units_on online capacity.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the minimum_operating_point parameter will trigger the creation of the Constraint on minimum operating point. It sets a lower bound on the value of the unit_flow variable for a unit that is online.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/Parameters/#minimum_reserve_activation_time","page":"Parameters","title":"minimum_reserve_activation_time","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Duration a certain reserve product needs to be online/available","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The parameter minimum_reserve_activation_time is the duration a reserve product needs to be online, before it can be replaced by another (slower) reserve product.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"In SpineOpt, the parameter is used to model reserve provision through storages. If a storage provides reserves to a reserve node (see also is_reserve_node) one needs to ensure that the node state is sufficiently high to provide these scheduled reserves as least for the duration of the minimum_reserve_activation_time. The constraint on the minimum node state with reserve provision is triggered by the existence of the minimum_reserve_activation_time. See also Ramping and Reserves","category":"page"},{"location":"concept_reference/Parameters/#model_end","page":"Parameters","title":"model_end","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Defines the last timestamp to be modelled. Rolling optimization terminates after passing this point.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: Dict{String, Any}(\"data\" => \"2000-01-02T00:00:00\", \"type\" => \"date_time\")","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Together with the model_start parameter, it is used to define the temporal horizon of the model. In case of a single solve optimization, the parameter marks the end of the last timestep that is possibly part of the optimization. Note that it poses an upper bound, and that the optimization does not necessarily include this timestamp when the block_end parameters are more stringent.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"In case of a rolling horizon optimization, it will tell to the model to stop rolling forward once an optimization has been performed for which the result of the indicated timestamp has been kept in the final results. For example, assume that a model_end value of 2030-01-01T05:00:00 has been chosen, a block_end of 3h, and a roll_forward of 2h. The roll_forward parameter indicates here that the results of the first two hours of each optimization window are kept as final, therefore the last optimization window will span the timeframe [2030-01-01T04:00:00 - 2030-01-01T06:00:00].","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A DateTime value should be chosen for this parameter. ","category":"page"},{"location":"concept_reference/Parameters/#model_start","page":"Parameters","title":"model_start","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Defines the first timestamp to be modelled. Relative temporal_blocks refer to this value for their start and end.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: Dict{String, Any}(\"data\" => \"2000-01-01T00:00:00\", \"type\" => \"date_time\")","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Together with the model_end parameter, it is used to define the temporal horizon of the model. For a single solve optimization, it marks the timestamp from which the relative offset in a temporal_block is defined by the block_start parameter. In the rolling optimization framework, it does this for the first optimization window.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A DateTime value should be chosen for this parameter. ","category":"page"},{"location":"concept_reference/Parameters/#model_type","page":"Parameters","title":"model_type","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used to identify model objects as relating to the master problem or operational sub problems (default)","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: spineopt_operations","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: model_type_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This parameter is used, generally, to control model dependent functionality and specify model-level parameters for different models. Currently, the main use is to identify the model objects that represent the master and operational sub problems within a decomposed investment problem structure. To trigger the decomposed structure, a model object with model_type=:spineopt_master must exist and another with model_type=:spineopt_operations must also be present. To deactivate the decomposition functionality, the model_type of the master problem can be set to :spineopt_other.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Decomposition.","category":"page"},{"location":"concept_reference/Parameters/#nodal_balance_sense","page":"Parameters","title":"nodal_balance_sense","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A selector for nodal_balance constraint sense.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: ==","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: constraint_sense_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"nodal_balance_sense determines whether or not a node is able to naturally consume or produce energy. The default value, ==, means that the node is unable to do any of that, and thus it needs to be perfectly balanced. The vale >= means that the node is a sink, that is, it can consume any amounts of energy. The value <= means that the node is a source, that is, it can produce any amounts of energy.","category":"page"},{"location":"concept_reference/Parameters/#node_opf_type","page":"Parameters","title":"node_opf_type","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A selector for the reference node (slack bus) when PTDF-based DC load-flow is enabled.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: node_opf_type_normal","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: node_opf_type_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used to identify the reference node (or slack bus) when ptdf based dc load flow is enabled (commodity_physics set to commodity_physics_ptdf or commodity_physics_lodf. To identify the reference node, set node_opf_type = :node_opf_type_reference","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also powerflow.","category":"page"},{"location":"concept_reference/Parameters/#node_slack_penalty","page":"Parameters","title":"node_slack_penalty","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A penalty cost for node_slack_pos and node_slack_neg variables. The slack variables won't be included in the model unless there's a cost defined for them.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"node_slack_penalty triggers the creation of node slack variables, node_slack_pos and node_slack_neg. This allows the model to violate the node_balance constraint with these violations penalised in the objective function with a coefficient equal to node_slack_penalty. If node_slack_penalty = 0 the slack variables are created and violations are unpenalised. If set to none or undefined, the variables are not created and violation of the node_balance constraint is  not possible.","category":"page"},{"location":"concept_reference/Parameters/#node_state_cap","page":"Parameters","title":"node_state_cap","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The maximum permitted value for a node_state variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The node_state_cap parameter represents the maximum allowed value for the node_state variable. Note that in order for a node to have a node_state variable in the first place, the has_state parameter must be set to true. However, if the node has storage investments enabled using the candidate_storages parameter, the node_state_cap parameter acts as a coefficient for the storages_invested_available variable. Essentially, with investments, the node_state_cap parameter represents storage capacity per storage investment.","category":"page"},{"location":"concept_reference/Parameters/#node_state_coefficient","page":"Parameters","title":"node_state_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Coefficient of the specified node's state variable in the specified user constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The node_state_coefficient is an optional parameter that can be used to include the node_state variable of a node in a user_constraint via the node__user_constraint relationship. Essentially, node_state_coefficient appears as a coefficient for the node_state variable of the node in the user constraint.","category":"page"},{"location":"concept_reference/Parameters/#node_state_min","page":"Parameters","title":"node_state_min","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The minimum permitted value for a node_state variable.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The node_state_min parameter sets the lower bound for the node_state variable, if one has been enabled by the has_state parameter. For reserve nodes with minimum_reserve_activation_time, the node_state_min is considered also via a special constraint.","category":"page"},{"location":"concept_reference/Parameters/#number_of_units","page":"Parameters","title":"number_of_units","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Denotes the number of 'sub units' aggregated to form the modelled unit.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Defines how many members a certain unit object represents. Typically this parameter takes a binary (UC) or integer (clustered UC) value. Together with the unit_availability_factor, this will determine the maximum number of members that can be online at any given time. (Thus restricting the units_on variable). It is possible to allow the model to increase the number_of_units itself, through Investment Optimization","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The default value for this parameter is 1.","category":"page"},{"location":"concept_reference/Parameters/#online_variable_type","page":"Parameters","title":"online_variable_type","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A selector for how the units_on variable is represented within the model.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: unit_online_variable_type_linear","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: unit_online_variable_type_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"online_variable_type is a method parameter closely related to the number_of_units and can take the values \"unit_online_variable_type_binary\", \"unit_online_variable_type_integer\", \"unit_online_variable_type_linear\". If the binary value is chosen, the units status is modelled as a binary (classic UC). For clustered unit commitment units, the integer type is applicable. Note that if the parameter is not defined, the default will be linear. If the units status is not crucial, this can reduce the computational burden.","category":"page"},{"location":"concept_reference/Parameters/#operating_points","page":"Parameters","title":"operating_points","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Decomposes the flow variable into a number of separate operating segment variables. Used to in conjunction with unit_incremental_heat_rate and/or user_constraints","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If operating_points is defined as an array type on a certain unit__to_node or unit__from_node flow, the corresponding unit_flow flow variable is decomposed into a number of sub operating segment variables, unit_flow_op one for each operating segment, with an additional index, i to reference the specific operating segment. Each value in the array represents the upper bound of the operating segment, normalized on unit_capacity for the corresponding unit__to_node or unit__from_node flow. operating_points is used in conjunction with unit_incremental_heat_rate where the array dimension must match and is used to define the normalized operating point bounds for the corresponding incremental heat rate. operating_points is also used in conjunction with user_constraint where the array dimension must match any corresponding piecewise linear unit_flow_coefficient. Here operating_points is used also to define the normalized operating point bounds for the corresponding unit_flow_coefficients.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that operating_points is defined on a capacity-normalized basis and the values represent the upper bound of the corresponding operating segment variable. So if operating_points is specified as [0.5, 1], this creates two operating segments, one from zero to 50% of the corresponding unit_capacity and a second from 50% to 100% of the corresponding unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/#output_db_url","page":"Parameters","title":"output_db_url","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Database url for SpineOpt output.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: report","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The output_db_url parameter is the url of the databse to write the results of the model run. It overrides the value of the second argument passed to run_spineopt.","category":"page"},{"location":"concept_reference/Parameters/#overwrite_results_on_rolling","page":"Parameters","title":"overwrite_results_on_rolling","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Whether or not results from further windows should overwrite results from previous ones.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: true","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: report__output","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The overwrite_results_on_rolling allows one to define whether or not results from further optimisation windows should overwrite those from previous ones. This, of course, is relevant only if optimisation windows overlap, which in turn happens whenever there is a temporal_block that goes beyond the length of the window.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If true (the default) then results are written as a time-series. If false, then results are written as a map from analysis time (i.e., the window start) to time-series.","category":"page"},{"location":"concept_reference/Parameters/#ramp_down_cost","page":"Parameters","title":"ramp_down_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Costs of ramping down","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the ramp_down_cost parameter for a specific unit__to_node or unit__from_node relationship, a cost term will be added to the objective function whenever the unit ramps down its activity (i.e., when the ramp_down_unit_flow is nonzero) over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#ramp_down_limit","page":"Parameters","title":"ramp_down_limit","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Limit the maximum ramp-down rate of an online unit, given as a fraction of the unitcapacity. [rampdown_limit] = %/t, e.g. 0.2/h","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the ramp_down_limit parameter will trigger the creation of the Constraint on spinning downward ramps. It will limit the maximum decrease in the unit_flow variable between two consecutive timesteps for which the unit is online.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/Parameters/#ramp_up_cost","page":"Parameters","title":"ramp_up_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Costs of ramping up","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the ramp_up_cost parameter for a specific unit__to_node or unit__from_node relationship, a cost term will be added to the objective function whenever the unit ramps up its activity (i.e., when the ramp_up_unit_flow is nonzero) over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#ramp_up_limit","page":"Parameters","title":"ramp_up_limit","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Limit the maximum ramp-up rate of an online unit, given as a fraction of the unitcapacity. [rampup_limit] = %/t, e.g. 0.2/h","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The definition of the ramp_up_limit parameter will trigger the creation of the Constraint on spinning upwards ramp_up. It limits the maximum increase in the unit_flow variable between two consecutive timesteps for which the unit is online.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"For a more complete description of how ramping restrictions can be implemented, see Ramping and Reserves.","category":"page"},{"location":"concept_reference/Parameters/#representative_periods_mapping","page":"Parameters","title":"representative_periods_mapping","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Mapping from real timelices to their corresponding representative days","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"For representative periods with seasonal storages, SpineOpt.jl can be interlinked with the package SpinePeriods.jl. SpinePeriods.jl provides the representative_periods_mapping parameter, which maps each non-representative period of the whole optimization window to its representative temporal_block. The map is organized as timeseries (indicating the start of each the non-representative period) with the names of the representative temporal_blocks as entries. ","category":"page"},{"location":"concept_reference/Parameters/#reserve_procurement_cost","page":"Parameters","title":"reserve_procurement_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Procurement cost for reserves","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the reserve_procurement_cost parameter for a specific unit__to_node or unit__from_node relationship, a cost term will be added to the objective function whenever that unit is used over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#resolution","page":"Parameters","title":"resolution","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Temporal resolution of the temporal_block. Essentially, divides the period between block_start and block_end into TimeSlices with the input resolution.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: Dict{String, Any}(\"data\" => \"1h\", \"type\" => \"duration\")","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This parameter specifies the resolution of the temporal block, or in other words: the length of the timesteps used in the optimization run. Generally speaking, variables and constraints are generated for each timestep of an optimization. For example, the nodal balance constraint must hold for each timestep.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"An array of duration values can be used to have a resolution that varies with time itself. It can for example be used when uncertainty in one of the inputs rises as the optimization moves away from the model start. Think of a forecast of for instance wind power generation, which might be available in quarter hourly detail for one day in the future, and in hourly detail for the next two days. It is possible to take a quarter hourly resolution for the full horizon of three days. However, by lowering the temporal resolution after the first day, the computational burden is lowered substantially.","category":"page"},{"location":"concept_reference/Parameters/#right_hand_side","page":"Parameters","title":"right_hand_side","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The right-hand side, constant term in a user_constraint. Can be time-dependent and used e.g. for complicated efficiency approximations.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used to specify the right-hand-side, constant term in a user_constraint. See also user_constraint.","category":"page"},{"location":"concept_reference/Parameters/#roll_forward","page":"Parameters","title":"roll_forward","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Defines how much the model moves ahead in time between solves in a rolling optimization. Without this parameter, everything is solved in as a single optimization.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This parameter defines how much the optimization window rolls forward in a rolling horizon optimization and should be expressed as a duration. In a rolling horizon optimization, a (small) part of the model is optimized at each iteration, after which the window rolls forward to optimize a different part. Overlap between consecutive optimization windows is possible. In the practical approaches presented in Temporal Framework, the rolling window optimization will be explained in more detail. The default value of this parameter is the entire model time horizon, which leads to a single optimization for the entire time horizon.","category":"page"},{"location":"concept_reference/Parameters/#shut_down_cost","page":"Parameters","title":"shut_down_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Costs of shutting down a 'sub unit', e.g. EUR/shutdown.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the shut_down_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit shuts down over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#start_up_cost","page":"Parameters","title":"start_up_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Costs of starting up a 'sub unit', e.g. EUR/startup.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the start_up_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit starts up over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#state_coeff","page":"Parameters","title":"state_coeff","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Represents the commodity content of a node_state variable in respect to the unit_flow and connection_flow variables. Essentially, acts as a coefficient on the node_state variable in the :node_injection constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The state_coeff parameter acts as a coefficient for the node_state variable in the node injection constraint. Essentially, it tells how the node_state variable should be treated in relation to the commodity flows and demand, and can be used for e.g. scaling or unit conversions. For most use-cases a state_coeff parameter value of 1.0 should suffice, e.g. having a MWh storage connected to MW flows in a model with hour as the basic unit of time.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that in order for the state_coeff parameter to have an impact, the node must first have a node_state variable to begin with, defined using the has_state parameter. By default, the state_coeff is set to zero as a precaution, so that the user always has to set its value explicitly for it to have an impact on the model.","category":"page"},{"location":"concept_reference/Parameters/#stochastic_scenario_end","page":"Parameters","title":"stochastic_scenario_end","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A Duration for when a stochastic_scenario ends and its child_stochastic_scenarios start. Values are interpreted relative to the start of the current solve, and if no value is given, the stochastic_scenario is assumed to continue indefinitely.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: stochastic_structure__stochastic_scenario","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The stochastic_scenario_end is a Duration-type parameter, defining when a stochastic_scenario ends relative to the start of the current optimization. As it is a parameter for the stochastic_structure__stochastic_scenario relationship, different stochastic_structures can have different values for the same stochastic_scenario, making it possible to define slightly different stochastic_structures using the same stochastic_scenarios. See the Stochastic Framework section for more information about how different stochastic_structures interact in SpineOpt.jl.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"When a stochastic_scenario ends at the point in time defined by the stochastic_scenario_end parameter, it spawns its children according to the parent_stochastic_scenario__child_stochastic_scenario relationship. Note that the children will be inherently assumed to belong to the same stochastic_structure their parent belonged to, even without explicit stochastic_structure__stochastic_scenario relationships! Thus, you might need to define the weight_relative_to_parents parameter for the children.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If no stochastic_scenario_end is defined, the stochastic_scenario is assumed to go on indefinitely.","category":"page"},{"location":"concept_reference/Parameters/#storage_investment_cost","page":"Parameters","title":"storage_investment_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Determines the investment cost per unit state_cap over the investment life of a storage","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the storage_investment_cost parameter for a specific node, a cost term will be added to the objective function whenever a storage investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#storage_investment_lifetime","page":"Parameters","title":"storage_investment_lifetime","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum lifetime for storage investment decisions.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Duration parameter that determines the minimum duration of storage investment decisions. Once a storage has been invested-in, it must remain invested-in for storage_investment_lifetime. Note that storage_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Investment Optimization and candidate_storages","category":"page"},{"location":"concept_reference/Parameters/#storage_investment_variable_type","page":"Parameters","title":"storage_investment_variable_type","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Determines whether the storage investment variable is continuous (usually representing capacity) or integer (representing discrete units invested)","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: variable_type_integer","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: variable_type_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Within an investments problem storage_investment_variable_type determines the storage investment decision variable type. Since a node's node_state will be limited to the product of the investment variable and the corresponding node_state_cap and since candidate_storages represents the upper bound of the storage investment decision variable, storage_investment_variable_type thus determines what the investment decision represents. If storage_investment_variable_type is integer or binary, then candidate_storages represents the maximum number of discrete storages that may be invested-in. If storage_investment_variable_type is continuous, candidate_storages is more analagous to a capacity with node_state_cap being analagous to a scaling parameter. For example, if storage_investment_variable_type = integer, candidate_storages = 4 and node_state_cap = 1000 MWh, then the investment decision is how many 1000h MW storages to build. If storage_investment_variable_type = continuous, candidate_storages = 1000 and node_state_cap = 1 MWh, then the investment decision is how much storage capacity to build. Finally, if storage_investment_variable_type = integer, candidate_storages = 10 and node_state_cap = 100 MWh, then the investment decision is how many 100MWh storage blocks to build.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Investment Optimization and candidate_storages.","category":"page"},{"location":"concept_reference/Parameters/#storages_invested_available_coefficient","page":"Parameters","title":"storages_invested_available_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Coefficient of the specified node's storages invested available variable in the specified user constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#storages_invested_coefficient","page":"Parameters","title":"storages_invested_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Coefficient of the specified node's storage investment variable in the specified user constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: node__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The storages_invested_coefficient is an optional parameter that can be used to include the storages_invested variable in a user_constraint via the node__user_constraint relationship. Essentially, storages_invested_coefficient appears as a coefficient for the storages_invested variable in the user constraint. For more information, see the [User Constraints Concept Reference][#User-Constraints]","category":"page"},{"location":"concept_reference/Parameters/#tax_in_unit_flow","page":"Parameters","title":"tax_in_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Tax costs for incoming unit_flows on this node. E.g. EUR/MWh.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the tax_in_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with all unit_flow variables with direction to_node over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#tax_net_unit_flow","page":"Parameters","title":"tax_net_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Tax costs for net incoming and outgoing unit_flows on this node. Incoming flows accrue positive net taxes, and outgoing flows accrue negative net taxes.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the tax_net_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with the net total of all unit_flow variables with the direction to_node for this specific node minus all unit_flow variables with direction from_node.","category":"page"},{"location":"concept_reference/Parameters/#tax_out_unit_flow","page":"Parameters","title":"tax_out_unit_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Tax costs for outgoing unit_flows from this node. E.g. EUR/MWh.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the tax_out_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with all unit_flow variables with direction from_node over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#unit_availability_factor","page":"Parameters","title":"unit_availability_factor","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Availability of the unit, acting as a multiplier on its unit_capacity. Typically between 0-1.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To indicate that a unit is only available to a certain extent or at certain times of the optimization, the unit_availability_factor can be used. A typical use case could be an availability timeseries for a variable renewable energy source. By default the availability factor is set to 1. The availability is, among others, used in the constraint_units_available.","category":"page"},{"location":"concept_reference/Parameters/#unit_capacity","page":"Parameters","title":"unit_capacity","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Maximum unit_flow capacity of a single 'sub_unit' of the unit.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To set an upper bound on the commodity flow of a unit in a certain direction, the unit_capacity constraint needs to be defined on a unit__to_node or unit__from_node relationship. By defining the parameter, the unit_flow variables to or from a node or a group of nodes will be constrained by the capacity constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that if the unit_capacity parameter is defined on a node group, the sum of all unit_flows within the specified node group will be constrained by the unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/#unit_conv_cap_to_flow","page":"Parameters","title":"unit_conv_cap_to_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Optional coefficient for unit_capacity unit conversions in the case the unit_capacity value is incompatible with the desired unit_flow units.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The unit_conv_cap_to_flow, as defined for a unit__to_node or unit__from_node, allows the user to align between unit_flow variables and the unit_capacity parameter, which may be expressed in different units. An example would be when the unit_capacity is expressed in GWh, while the demand on the node is expressed in MWh. In that case, a unit_conv_cap_to_flow parameter of 1000 would be applicable.  ","category":"page"},{"location":"concept_reference/Parameters/#unit_flow_coefficient","page":"Parameters","title":"unit_flow_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Coefficient of a unit_flow variable for a custom user_constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node__user_constraint and unit__to_node__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The unit_flow_coefficient is an optional parameter that can be used to include the unit_flow or unit_flow_op variables from or to a node in a user_constraint via the unit__from_node__user_constraint and unit__to_node__user_constraint relationships. Essentially, unit_flow_coefficient appears as a coefficient for the unit_flow and unit_flow_op variables from or to the node in the user constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Note that the unit_flow_op variables are a bit of a special case, defined using the operating_points parameter.","category":"page"},{"location":"concept_reference/Parameters/#unit_idle_heat_rate","page":"Parameters","title":"unit_idle_heat_rate","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Flow from node1 per unit time and per units_on that results in no additional flow to node2","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used to implement the no-load or idle heat rate of a unit. This is the y-axis offset of the heat rate function and is the fuel consumed per unit time when a unit is online and that results in no additional output. This is defined on the unit__node__node relationship and it is assumed that the input flow from node 1 represents fuel consumption and the output flow to node 2 is the elecrical output. While the units depend on the data, unit_idle_heat_rate is generally expressed in GJ/hr. Used in conjunction with unit_incremental_heat_rate. unit_idle_heat_rate is only currently considered if unit_incremental_heat_rate is specified. A trivial unit_incremental_heat_rate of zero can be defined if there is no incremental heat rate.","category":"page"},{"location":"concept_reference/Parameters/#unit_incremental_heat_rate","page":"Parameters","title":"unit_incremental_heat_rate","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Standard piecewise incremental heat rate where node1 is assumed to be the fuel and node2 is assumed to be electriciy. Assumed monotonically increasing. Array type or single coefficient where the number of coefficients must match the dimensions of unit_operating_points","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used to implement simple or piecewise linear incremental heat rate functions. Used in the constraint unit_pw_heat_rate - the input fuel flow at node 1 is the sum of the electrical MW output at node 2 times the incremental heat rate over all heat rate segments, plus the unit_idle_heat_rate. The units are detmerined by the data, but generally, incremental heat rates are given in GJ/MWh. Note that the formulation assumes a convex, monitonically increasing heat rate function. The formulation relies on optimality to load the heat rate segments in the correct order and no additional integer variables are created to enforce the correct loading order. The heat rate segment MW operating points are defined by operating_points.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"To implement a simple incremental heat rate function,unit_incremental_heat_rate should be given as a simple scalar representing the incremental heat rate over the entire operating range of the unit. To implement a piecewise linear heat rate function, unit_incremental_heat_rate should be specified as an array type. It is then used in conjunction with the unit parameter operating_points which should also be defined as an array type of equal dimension. When defined as an array type unit_incremental_heat_rate[i] is the effective incremental heat rate between operating_points [i-1] (or zero if i=1) and operating_points[i]. Note that operating_points is defined on a capacity-normalized basis so if operating_points is specified as [0.5, 1], this creates two operating segments, one from zero to 50% of the corresponding unit_capacity and a second from 50% to 100% of the corresponding unit_capacity.","category":"page"},{"location":"concept_reference/Parameters/#unit_investment_cost","page":"Parameters","title":"unit_investment_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Investment cost per 'sub unit' built.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the unit_investment_cost parameter for a specific unit, a cost term will be added to the objective function whenever a unit investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#unit_investment_lifetime","page":"Parameters","title":"unit_investment_lifetime","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Minimum lifetime for unit investment decisions.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Duration parameter that determines the minimum duration of unit investment decisions. Once a unit has been invested-in, it must remain invested-in for unit_investment_lifetime. Note that unit_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Investment Optimization and candidate_units","category":"page"},{"location":"concept_reference/Parameters/#unit_investment_variable_type","page":"Parameters","title":"unit_investment_variable_type","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Determines whether investment variable is integer or continuous.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: unit_investment_variable_type_continuous","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: unit_investment_variable_type_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Within an investments problem unit_investment_variable_type determines the unit investment decision variable type. Since the unit_flows will be limited to the product of the investment variable and the corresponding unit_capacity for each unit_flow and since candidate_units represents the upper bound of the investment decision variable, unit_investment_variable_type thus determines what the investment decision represents. If unit_investment_variable_type is integer or binary, then candidate_units represents the maximum number of discrete units that may be invested. If unit_investment_variable_type is continuous, candidate_units is more analagous to a capacity with unit_capacity being analagous to a scaling parameter. For example, if unit_investment_variable_type = integer, candidate_units = 4 and unit_capacity for a particular unit_flow = 400 MW, then the investment decision is how many 400 MW units to build. If unit_investment_variable_type = continuous, candidate_units = 400 and unit_capacity for a particular unit_flow = 1 MW, then the investment decision is how much capacity if this particular unit to build. Finally, if unit_investment_variable_type = integer, candidate_units = 10 and unit_capacity for a particular unit_flow = 50 MW, then the investment decision is many 50MW blocks of capacity of this particular unit to build.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"See also Investment Optimization and candidate_units","category":"page"},{"location":"concept_reference/Parameters/#unit_start_flow","page":"Parameters","title":"unit_start_flow","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Flow from node1 that is incurred when a unit is started up.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__node__node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Used to implement unit startup fuel consumption where node 1 is assumed to be input fuel and node 2 is assumed to be output elecrical energy. This is a flow from node 1 that is incurred when the value of the variable unitsstartedup is 1 in the corresponding time period. This flow does not result in additional output flow at node 2. Used in conjunction with unit_incremental_heat_rate. unit_start_flow is only currently considered if unit_incremental_heat_rate is specified. A trivial unit_incremental_heat_rate of zero can be defined if there is no incremental heat rate.","category":"page"},{"location":"concept_reference/Parameters/#units_invested_available_coefficient","page":"Parameters","title":"units_invested_available_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Coefficient of the units_invested_available variable in the specified user_constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#units_invested_coefficient","page":"Parameters","title":"units_invested_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Coefficient of the units_invested variable in the specified user_constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The units_invested_coefficient is an optional parameter that can be used to include the units_invested variable in a user_constraint via the unit__user_constraint relationship. Essentially, units_invested_coefficient appears as a coefficient for the units_invested variable in the user constraint. For more information, see the [User Constraints Concept Reference][#User-Constraints]","category":"page"},{"location":"concept_reference/Parameters/#units_on_coefficient","page":"Parameters","title":"units_on_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Coefficient of a units_on variable for a custom user_constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The units_on_coefficient is an optional parameter that can be used to include the units_on variable of a unit in a user_constraint via the unit__user_constraint relationship. Essentially, units_on_coefficient appears as a coefficient for the units_on variable of the unit in the user constraint.","category":"page"},{"location":"concept_reference/Parameters/#units_on_non_anticipativity_time","page":"Parameters","title":"units_on_non_anticipativity_time","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Period of time where the value of the units_on variable has to be fixed to the result from the previous window.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: unit","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The units_on_non_anticipativity_time parameter defines the duration, starting from the begining of the optimisation window, where units_on variables need to be fixed to the result of the previous window.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This is intended to model \"slow\" units whose commitment decision needs to be taken in advance, e.g., in \"day-ahead\" mode, and cannot be changed afterwards.","category":"page"},{"location":"concept_reference/Parameters/#units_started_up_coefficient","page":"Parameters","title":"units_started_up_coefficient","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Coefficient of a units_started_up variable for a custom user_constraint.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 0.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__user_constraint","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The units_started_up_coefficient is an optional parameter that can be used to include the units_started_up variable of a unit in a user_constraint via the unit__user_constraint relationship. Essentially, units_started_up_coefficient appears as a coefficient for the units_started_up variable of the unit in the user constraint.","category":"page"},{"location":"concept_reference/Parameters/#upward_reserve","page":"Parameters","title":"upward_reserve","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Identifier for nodes providing upward reserves","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If a node has a true is_reserve_node parameter, it will be treated as a reserve node in the model. To define whether the node corresponds to an upward or downward reserve commodity, the upward_reserve or the downward_reserve parameter needs to be set to true, respectively.","category":"page"},{"location":"concept_reference/Parameters/#version","page":"Parameters","title":"version","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Current version of the SpineOpt data structure. Modify it at your own risk (but please don't).","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 2","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: settings","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"TODO","category":"page"},{"location":"concept_reference/Parameters/#vom_cost","page":"Parameters","title":"vom_cost","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Variable operating costs of a unit_flow variable. E.g. EUR/MWh.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: unit__from_node and unit__to_node","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"By defining the vom_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for the variable operation and maintenance costs associated with that unit over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/Parameters/#weight","page":"Parameters","title":"weight","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Weighting factor of the temporal block associated with the objective function","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: temporal_block","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The weight variable, defined for a temporal_block object can be used to assign different weights to different temporal periods that are modeled. It basically determines how important a certain temporal period is in the total cost, as it enters the Objective function. The main use of this parameter is for representative periods, where each representative period represents a specific fraction of a year or so.  ","category":"page"},{"location":"concept_reference/Parameters/#weight_relative_to_parents","page":"Parameters","title":"weight_relative_to_parents","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The weight of the stochastic_scenario in the objective function relative to its parents.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: 1.0","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Relationship Classes: stochastic_structure__stochastic_scenario","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The weight_relative_to_parents parameter defines how much weight the stochastic_scenario gets in the Objective function. As a stochastic_structure__stochastic_scenario relationship parameter, different  stochastic_structures can use different weights for the same stochastic_scenario. Note that every stochastic_scenario that appears in the model must have a weight_relative_to_parents defined for it related to the used stochastic_structure! See the Stochastic Framework section for more information about how different stochastic_structures interact in SpineOpt.jl.)","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Since the Stochastic Framework in SpineOpt.jl supports stochastic directed acyclic graphs instead of simple stochastic trees, it is possible to define stochastic_structures with converging stochastic_scenarios. In these cases, the child stochastic_scenarios inherint the weight of all of their parents, and the final weight that will appear in the Objective function is calculated as shown below:","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"# For root `stochastic_scenarios` (meaning no parents)\n\nweight(scenario) = weight_relative_to_parents(scenario)\n\n# If not a root `stochastic_scenario`\n\nweight(scenario) = sum([weight(parent) * weight_relative_to_parents(scenario)] for parent in parents)","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"The above calculation is performed starting from the roots, generation by generation, until the leaves of the stochastic DAG. Thus, the final weight of each stochastic_scenario is dependent on the weight_relative_to_parents Parameters of all its ancestors.","category":"page"},{"location":"concept_reference/Parameters/#write_lodf_file","page":"Parameters","title":"write_lodf_file","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A boolean flag for whether the LODF values should be written to a results file.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If this parameter value is set to true, a diagnostics file containing all the network line outage distributions factors in CSV format will be written to the current directory.","category":"page"},{"location":"concept_reference/Parameters/#write_mps_file","page":"Parameters","title":"write_mps_file","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A selector for writing an .mps file of the model.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: write_mps_file_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This parameter is deprecated and will be removed in a future version.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"This parameter controls when to write a diagnostic model file in MPS format. If set to write_mps_always, the model will always be written in MPS format to the current directory. If set to write\\_mps\\_on\\_no\\_solve, the MPS file will be written when the model solve terminates with a status of false.  If set to write\\_mps\\_never, no file will be written","category":"page"},{"location":"concept_reference/Parameters/#write_ptdf_file","page":"Parameters","title":"write_ptdf_file","text":"","category":"section"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"A boolean flag for whether the LODF values should be written to a results file.","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Default value: false","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Uses Parameter Value Lists: boolean_value_list","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"Related Object Classes: model","category":"page"},{"location":"concept_reference/Parameters/","page":"Parameters","title":"Parameters","text":"If this parameter value is set to true, a diagnostics file containing all the network power transfer distributions factors in CSV format will be written to the current directory.","category":"page"},{"location":"concept_reference/unit__to_node__unit_constraint/","page":"-","title":"-","text":"unit__to_node__user_constraint is a three-dimensional relationship between a unit, a node and a user_constraint. The relationship specifies that the unit_flow variable from the specified unit to the specified node is involved in the specified user_constraint. Parameters on this relationship generally apply to this specific unit_flow variable. For example the parameter unit_flow_coefficient defined on unit__to_node__user_constraint represents the coefficient on the specific unit_flow variable in the specified user_constraint","category":"page"},{"location":"concept_reference/connection_type/","page":"-","title":"-","text":"Used to control specific pre-processing actions on connections. Currently, the primary purpose of connection_type is to simplify the data that is required to define a simple bi-directional, lossless line. If connection_type=:connection_type_lossless_bidirectional, it is only necessary to specify the following minimum data:","category":"page"},{"location":"concept_reference/connection_type/","page":"-","title":"-","text":"relationship: connection__from_node\nrelationship: connection__to_node\nparameter: connection_capacity (defined on connection__from_node and/or connection__to_node)","category":"page"},{"location":"concept_reference/connection_type/","page":"-","title":"-","text":"If connection_type=:connection_type_lossless_bidirectional the following pre-processing actions are taken:","category":"page"},{"location":"concept_reference/connection_type/","page":"-","title":"-","text":"reciprocal connection__from_node and connection__to_node relationships are created if they don't exist\na new connection__node__node relationship is created if none exists already\nfix_ratio_out_in_connection_flow parameter is created with the value of 1 if no existing parameter found (therefore this value can be overridden)\nThe first connection_capacity parameter found is copied to connection__from_nodes and connection__to_nodes without a defined connection_capacity.","category":"page"},{"location":"concept_reference/ramp_up_cost/","page":"-","title":"-","text":"By defining the ramp_up_cost parameter for a specific unit__to_node or unit__from_node relationship, a cost term will be added to the objective function whenever the unit ramps up its activity (i.e., when the ramp_up_unit_flow is nonzero) over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/unit__to_node/","page":"-","title":"-","text":"The unit__to_node and unit__from_node unit relationships are core elements of SpineOpt. For each unit__to_node or unit__from_node, a unit_flow variable is automatically added to the model, i.e. a commodity flow of a unit to or from a specific node, respectively.","category":"page"},{"location":"concept_reference/unit__to_node/","page":"-","title":"-","text":"Various parameters can be defined on the unit__to_node relationship, in order to constrain the associated unit flows. In most cases a unit_capacity will be defined for an upper bound on the commodity flows. Apart from that, ramping abilities of a unit can be defined. For further details on ramps see Ramping and Reserves.","category":"page"},{"location":"concept_reference/unit__to_node/","page":"-","title":"-","text":"To associate costs with a certain commodity flow, cost terms, such as fuel_costs and vom_costs, can be included for the unit__to_node relationship.","category":"page"},{"location":"concept_reference/unit__to_node/","page":"-","title":"-","text":"It is important to note, that the parameters associated with the unit__to_node can be defined either for a specific node, or for a group of nodes. Grouping nodes for the described parameters will result in an aggregation of the unit flows for the triggered constraint, e.g. the definition of the unit_capacity on a group of nodes will result in an upper bound on the sum of all individual unit_flows.","category":"page"},{"location":"concept_reference/connection_investment_cost/","page":"-","title":"-","text":"By defining the connection_investment_cost parameter for a specific connection, a cost term will be added to the objective function whenever a connection investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/min_ratio_in_out_unit_flow/","page":"-","title":"-","text":"The definition of the min_ratio_in_out_unit_flow parameter triggers the generation of the constraint_min_ratio_in_out_unit_flow and enforces a lower bound on the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes, see) in this relationship represents the from_node, i.e. the incoming flow to the unit, and the second node (or group of nodes) represents the to_node i.e. the outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of in over out, where in is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/min_ratio_in_out_unit_flow/","page":"-","title":"-","text":"To enforce e.g. a minimum ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing flow to the node group el_heat (consisting of the two nodes el and heat), the fix_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/#Representative-days-with-seasonal-storages","page":"Representative days with seasonal storages","title":"Representative days with seasonal storages","text":"","category":"section"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/","page":"Representative days with seasonal storages","title":"Representative days with seasonal storages","text":"In order to reduce computational times, representative periods are often used in optimization models. However, this often limits the ability to properly account for seasonal storages.","category":"page"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/","page":"Representative days with seasonal storages","title":"Representative days with seasonal storages","text":"In SpineOpt, we provide functionality to use representative days with seasonal storages in combination with the package SpinePeriods.jl.","category":"page"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/#general_idea_rep_period_seasonal_Storage","page":"Representative days with seasonal storages","title":"General idea","text":"","category":"section"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/","page":"Representative days with seasonal storages","title":"Representative days with seasonal storages","text":"The general idea is to mimick the seasonal effects throughout a non-representative period, e.g. a year of optimization, by introducing a specific sequence of the representative periods. Taking the example of one year to be optimized with representative days and seasonal storages, SpinePeriods.jl provides a mapping of each day of the year to its corresponding representative day. This information is stored in the mapping parameter representative_periods_mapping and is defined on the temporal_block for the whole year. The representative_periods_mapping parameter is a timeseries, pointing the beginning of each day to its corresponding representative day temporal_block, which can also be automatically be generated through SpinePeriods.jl.","category":"page"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/","page":"Representative days with seasonal storages","title":"Representative days with seasonal storages","text":"In SpineOpt, this is interpreted in the following way:","category":"page"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/","page":"Representative days with seasonal storages","title":"Representative days with seasonal storages","text":"All operational variables, with the exception of the node_state variable, are created for each representative period. For each non-representative period, the variables are mapped to their corresponding variable of the representative periods according to the representative_periods_mapping parameter.\nOnly the node_state variables and all investment variables are created for both, representative and non-representative period (of course, depending on the existance of relationships to temporal_blocks).","category":"page"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/#Usage_rep_period_seasonal_Storage","page":"Representative days with seasonal storages","title":"Usage of representative days and seasonal storages for investment problems","text":"","category":"section"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/","page":"Representative days with seasonal storages","title":"Representative days with seasonal storages","text":"To make use of representative days with seasonal storages concept, multiple temporal_block objects need to be created and connected to the system components, holding information about the resolutions in different parts of the model that come into play. As described in the section Temporal Framework, every temporal block needs to be connected to a model object.","category":"page"},{"location":"advanced_concepts/representative_days_w_seasonal_storage/","page":"Representative days with seasonal storages","title":"Representative days with seasonal storages","text":"temporal_block for investments: In order to define the resolution of the investment decisions, a temporal_block relecting the frequency of investment decisions should be introduced. For yearly investment, the resolution of this temporal block would be equal to 1Y. In order to link nodes, units or connections to this investment resolution, the node__investment_temporal_block, unit__investment_temporal_block, or connection__investment_temporal_block relationships need to be defined, respectively. For more details on investments, see also section Investment Optimization\ntemporal_block for representative days: For each representative day, one temporal_block needs to be created, indicating the block_start and block_end of the representative day. The use of disconnected periods is also described in the section Disconnected time periods. The resolution of the representative days corresponds to the resolution of the operational variables, e.g. 1h. In order to associate operational variables with the representative periods, node__temporal_block and units_on__temporal_block relationships need to be created. For convenience, it is also possible to create a group of all representative temporal_blocks and link this group to these relationships. Note that, when using SpinePeriods.jl, the representative temporal blocks are auto-generated.\ntemporal_block for non-representative days: To introduce node_state variables for the entire operational period, a temporal block overarching the entire horizon is created. Note that currently, this temporal block needs to have the same resolution as the representative days, e.g. 1h. In order to associate operational variables with the representative periods, node__temporal_block and units_on__temporal_block relationships need to be created. Note that, as described above, the non-representative variables, will be mapped to their corresponding representative days. To manually introduce the mapping between non-representative and representative periods, instead of using the recommended SpinePeriods.jl, the user must define the mapping parameter representative_periods_mapping by hand, consisting of DateTime indices (indicating the start of each non-representative period, e.g. for a daily mapping 2021-01-01T00:00:00, 2021-01-02T00:00:00 etc.) and the name of the corresponding representative temporal_block as a value.","category":"page"},{"location":"concept_reference/unit_investment_cost/","page":"-","title":"-","text":"By defining the unit_investment_cost parameter for a specific unit, a cost term will be added to the objective function whenever a unit investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/number_of_units/","page":"-","title":"-","text":"Defines how many members a certain unit object represents. Typically this parameter takes a binary (UC) or integer (clustered UC) value. Together with the unit_availability_factor, this will determine the maximum number of members that can be online at any given time. (Thus restricting the units_on variable). It is possible to allow the model to increase the number_of_units itself, through Investment Optimization","category":"page"},{"location":"concept_reference/number_of_units/","page":"-","title":"-","text":"The default value for this parameter is 1.","category":"page"},{"location":"concept_reference/_example/","page":"-","title":"-","text":"AN EXAMPLE DESCRIPTION FOR HOW THE AUTOGENERATION OF CONCEPT REFERENCE BASED ON SPINEOPT TEMPLATE WORKS","category":"page"},{"location":"concept_reference/_example/","page":"-","title":"-","text":"References to other sections, e.g. node are handled like this. Don't use the grave accents around the reference name, as it breaks the reference! Grave accents in Documenter.jl refer to docstrings in the code instead of sections in the documentation.","category":"page"},{"location":"concept_reference/start_up_cost/","page":"-","title":"-","text":"By defining the start_up_cost parameter for a specific unit, a cost term will be added to the objective function whenever this unit starts up over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/report__output/","page":"-","title":"-","text":"The report__output relationship tells which output variables to include in which report when writing SpineOpt output. Note that the reports also need to be connected to a model using the model__report relationship. Without appropriately defined model__report and report__output and relationships, SpineOpt doesn't write any output, so be sure to include at least one report connected to all the output variables of interest in the model!","category":"page"},{"location":"concept_reference/storages_invested_coefficient/","page":"-","title":"-","text":"The storages_invested_coefficient is an optional parameter that can be used to include the storages_invested variable in a user_constraint via the node__user_constraint relationship. Essentially, storages_invested_coefficient appears as a coefficient for the storages_invested variable in the user constraint. For more information, see the [User Constraints Concept Reference][#User-Constraints]","category":"page"},{"location":"concept_reference/output_db_url/","page":"-","title":"-","text":"The output_db_url parameter is the url of the databse to write the results of the model run. It overrides the value of the second argument passed to run_spineopt.","category":"page"},{"location":"concept_reference/connection_reactance_base/","page":"-","title":"-","text":"As the connection_reactance is often given on a per unit basis, often different than the units used elsewhere, the connection_reactance_base parameter serves as a conversion factor, scaling the connection_reactance with its p.u..","category":"page"},{"location":"concept_reference/units_on__stochastic_structure/","page":"-","title":"-","text":"The units_on__stochastic_structure relationship defines the stochastic_structure used by the units_on variable. Essentially, this relationship permits defining a different stochastic_structure for the online decisions regarding the units_on variable, than what is used for the production unit_flow variables. A common use-case is e.g. using only one units_on variable across multiple stochastic_scenarios for the unit_flow variables. Note that only one units_on__stochastic_structure relationship can be defined per unit per model, as interpreted by the units_on__stochastic_structure and model__stochastic_structure relationships.","category":"page"},{"location":"concept_reference/units_on__stochastic_structure/","page":"-","title":"-","text":"The units_on__stochastic_structure relationship uses the model__default_stochastic_structure relationship if not specified.","category":"page"},{"location":"concept_reference/is_non_spinning/","page":"-","title":"-","text":"By setting the parameter is_non_spinning to true, a node is treated as a non-spinning reserve node. Note that this is only to differentiate spinning from non-spinning reserves. It is still necessary to define the is_reserve_node to true. reserve node in the model. To define the maximum reserve provision of a non-spinning reserve flow (defined on a unit__to_node relationship), it is also necessary to define the max_res_startup_ramp and the max_res_shutdown_ramp parameters, respectively. It is also possible to define a minimum reserve provision ramp by defining the parameters min_res_startup_ramp and min_res_shutdown_ramp. The mathematical formulation holds a chapter on Ramping and reserve constraints and the general concept of setting up a model with reserves is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/node__stochastic_structure/","page":"-","title":"-","text":"The node__stochastic_structure relationship defines which stochastic_structure the node uses. Essentially, it sets the stochastic_structure of all the flow variables connected to the node, as well as the potential node_state variable. Note that only one stochastic_structure can be defined per node per model, as interpreted based on the node__stochastic_structure and model__stochastic_structure relationships. Investment variables use dedicated relationships, as detailed in the Investment Optimization section.","category":"page"},{"location":"concept_reference/node__stochastic_structure/","page":"-","title":"-","text":"The node__stochastic_structure relationship uses the model__default_stochastic_structure relationship if not specified.","category":"page"},{"location":"concept_reference/tax_net_unit_flow/","page":"-","title":"-","text":"By defining the tax_net_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with the net total of all unit_flow variables with the direction to_node for this specific node minus all unit_flow variables with direction from_node.","category":"page"},{"location":"concept_reference/report/","page":"-","title":"-","text":"A report is essentially a group of outputs from a model, that gets written into the output database as a result of running SpineOpt. Note that unless appropriate model__report and report__output relationships are defined, SpineOpt doesn't write any output!","category":"page"},{"location":"concept_reference/model_start/","page":"-","title":"-","text":"Together with the model_end parameter, it is used to define the temporal horizon of the model. For a single solve optimization, it marks the timestamp from which the relative offset in a temporal_block is defined by the block_start parameter. In the rolling optimization framework, it does this for the first optimization window.","category":"page"},{"location":"concept_reference/model_start/","page":"-","title":"-","text":"A DateTime value should be chosen for this parameter. ","category":"page"},{"location":"concept_reference/constraint_sense/","page":"-","title":"-","text":"The constraint_sense parameter determines the sense of a custom user constraint.","category":"page"},{"location":"concept_reference/constraint_sense/","page":"-","title":"-","text":"See User constraints for details.","category":"page"},{"location":"concept_reference/connection_flow_coefficient/","page":"-","title":"-","text":"The connection_flow_coefficient is an optional parameter that can be used to include the connection_flow variable from or to a node in a user_constraint via the connection__from_node__user_constraint and connection__to_node__user_constraint relationships. Essentially, connection_flow_coefficient appears as a coefficient for the connection_flow variable from or to the node in the user constraint.","category":"page"},{"location":"concept_reference/fix_unit_flow/","page":"-","title":"-","text":"The fix_unit_flow parameter fixes the value of the unit_flow variable to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/fix_unit_flow/","page":"-","title":"-","text":"Common uses for the parameter include e.g. providing initial values for the unit_flow variable, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the unit_flow variable is only fixed for time steps with defined fix_unit_flow parameter values.","category":"page"},{"location":"concept_reference/fix_unit_flow/","page":"-","title":"-","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/fix_connection_flow/","page":"-","title":"-","text":"The fix_connection_flow parameter fixes the value of the connection_flow variable.","category":"page"},{"location":"concept_reference/connection_contingency/","page":"-","title":"-","text":"Specifies that the connection in question is to be included as a contingency when security constrained unit commitment is enabled. When using security constrained unit commitment by setting commodity_physics to commodity_physics_lodf, an N-1 security constraint is created for each monitored line (connection_monitored = true) for each specified contingency (connection_contingency = true).","category":"page"},{"location":"concept_reference/connection_contingency/","page":"-","title":"-","text":"See also powerflow","category":"page"},{"location":"concept_reference/max_node_pressure/","page":"-","title":"-","text":"If a node has a node_pressure variable (see also the parameter has_pressure and this chapter), an upper bound on the pressure can be introduced through the max_node_pressure parameter, which triggers the generation of the maxmimum node pressure constraint.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_in_in/","page":"-","title":"-","text":"The min_units_on_coefficient_in_in parameter is an optional coefficient in the unit input-input ratio constraint controlled by the min_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_in_in/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_out, min_units_on_coefficient_out_in, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_in_in and fix_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/unit_investment_lifetime/","page":"-","title":"-","text":"Duration parameter that determines the minimum duration of unit investment decisions. Once a unit has been invested-in, it must remain invested-in for unit_investment_lifetime. Note that unit_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/unit_investment_lifetime/","page":"-","title":"-","text":"See also Investment Optimization and candidate_units","category":"page"},{"location":"concept_reference/connection/","page":"-","title":"-","text":"A connection represents a transfer of one commodity over space. For example, an electricity transmission line, a gas pipe, a river branch, can be modelled using a connection.","category":"page"},{"location":"concept_reference/connection/","page":"-","title":"-","text":"A connection always takes commodities from one or more nodes, and releases them to one or more (possibly the same) nodes. The former are specificed through the connection__from_node relationship, and the latter through connection__to_node. Every connection inherits the temporal and stochastic structures from the associated nodes. The model will generate connection_flow variables for every combination of connection, node, direction (from node or to node), time slice, and stochastic scenario, according to the above relationships.","category":"page"},{"location":"concept_reference/connection/","page":"-","title":"-","text":"The operation of the connection is specified through a number of parameter values. For example, the capacity of the connection, as the maximum amount of energy that can enter or leave it, is given by connection_capacity. The conversion ratio of input to output can be specified using any of fix_ratio_out_in_connection_flow, max_ratio_out_in_connection_flow, and min_ratio_out_in_connection_flow parameters in the connection__node__node relationship. The delay on a connection, as the time it takes for the energy to go from one end to the other, is given by connection_flow_delay.","category":"page"},{"location":"concept_reference/fix_shut_down_unit_flow/","page":"-","title":"-","text":"The fix_shut_down_unit_flow parameter fixes the value of the shut_down_unit_flow to the provided value, if the parameter is defined.","category":"page"},{"location":"concept_reference/fix_shut_down_unit_flow/","page":"-","title":"-","text":"Common uses for the parameter include e.g. providing initial values for the shut_down_unit_flow, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the shut_down_unit_flow variable is only fixed for time steps with defined fix_shut_down_unit_flow parameter values.","category":"page"},{"location":"concept_reference/fix_shut_down_unit_flow/","page":"-","title":"-","text":"Other uses can include e.g. a constant or time-varying exogenous commodity flow from or to a unit.","category":"page"},{"location":"concept_reference/fix_shut_down_unit_flow/","page":"-","title":"-","text":"Note that the mentioned shut_down_unit_flow variable is only included if the parameter max_startup_ramp exist for the correspond unit__to_node or unit__from_node relationship. The usage of ramps is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/connection_monitored/","page":"-","title":"-","text":"When using ptdf-based load flow by setting commodity_physics to either commodity_physics_ptdf or commodity_physics_ptdf, a constraint is created for each connection for which connection_monitored = true. Thus, to monitor the ptdf-based flow on a particular connection connection_monitored must be set to true.","category":"page"},{"location":"concept_reference/connection_monitored/","page":"-","title":"-","text":"See also powerflow","category":"page"},{"location":"concept_reference/min_ratio_out_out_unit_flow/","page":"-","title":"-","text":"The definition of the min_ratio_out_out_unit_flow parameter triggers the generation of the constraint_min_ratio_out_out_unit_flow and enforces a lower bound on the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of out1 over out2, where out1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/min_ratio_out_out_unit_flow/","page":"-","title":"-","text":"To enforce a minimum ratio between two products of a unit u, e.g. setting the minimum share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"concept_reference/fix_nonspin_units_started_up/","page":"-","title":"-","text":"The fix_nonspin_units_started_up parameter simply fixes the value of the nonspin_units_started_up variable to the provided value. As such, it determines directly how many member units are involved in providing upward reserve commodity flows to the node to which it is linked by the unit__to_node relationship.","category":"page"},{"location":"concept_reference/fix_nonspin_units_started_up/","page":"-","title":"-","text":"When a single value is selected, this value is kept constant throughout the model. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"getting_started/creating_your_own_model/#Creating-Your-Own-Model","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"This part of the guide shows first an example how to insert objects and their parameter data. Then it shows what other objects, relationships and parameter data needs to be added for a very basic model. Lastly, the model instance is run.","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"This section explains the process of creating a SpineOpt.jl model from scratch in order to give you an understanding of the underlying principles of the data structure, etc. If you simply want to try something out quickly to see results, check out the Example Models section. Furthermore, if you're in a hurry, the Archetypes section provides you with some pre-made templates for the different parts of a SpineOpt.jl model to get you started quickly.","category":"page"},{"location":"getting_started/creating_your_own_model/#Creating-a-SpineOpt-model-instance","page":"Creating Your Own Model","title":"Creating a SpineOpt model instance","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"First, open the database editor by double-clicking the Input DB. \nRight click on model in the Object tree. \nChoose Add objects. \nThen, add a model object by writing a name to the object name field. You can use e.g. instance. \nClick ok.\nThe model object in SpineOpt is an abstraction that represents the model itself. Every SpineOpt database needs to have at least one model object.\nThe model object holds general information about the optimization. The whole range of functionalities is explained in Advanced Concepts chapter - in here a minimal set of parameters is used.","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"(Image: image)","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"(Image: image)","category":"page"},{"location":"getting_started/creating_your_own_model/#Add-parameter-values-to-the-model-instance","page":"Creating Your Own Model","title":"Add parameter values to the model instance","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Select the model object instance from the object tree.\nGo to the Object parameter value tab.\nEvery parameter value belongs to a specific alternative. This allows to hold multiple values for the same parameter of a particular object. The alternative values are used to create scenarios. Choose, Base for all parameter values (Base is required in Spine Toolbox - all other alternatives can be chosen freely).\nThen define a model_start time and a model_end time. \nDouble-click on the empty row under parameter_name and select model_start. \nA None should appear in value column. \nTo asign a start date value, right-click on None and open the editor (cannot be entered directly, since the datatype needs to be changed). \nThe parameter type of model_start is of type Datetime. \nSet the value to e.g. 2019-01-01T00:00:00. \nProceed accordingly for the model_end.  ","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"(Image: image) ","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Further reading on adding parameter values can be found here.","category":"page"},{"location":"getting_started/creating_your_own_model/#Add-other-necessary-objects-and-parameter-data-for-the-objects.","page":"Creating Your Own Model","title":"Add other necessary objects and parameter data for the objects.","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Add all objects and their parameter data by replicating what has been done in the picture below. Do it the same way as explained above with the following caveats.\nWhilst most object names can be freely defined by the user, there is one object name in the example below that needs to be written exactly since it is used internally by SpineOpt: unit_flow. \nThe parameter_name can be selected from a drop down menu.\nThe date time and time series parameter data can be added by using right-click to access the Edit... dialog. When creating the time series, use the fixed resolution with Start time of the model run and with 1h resolution. Then only values need to be entered (or copy pasted) and time stamps come automatically.\nParameter balance_type needs to have value balance_type_none in the gas node, since it allows the node to create energy (natural gas) against a price and therefore the energy balance is not maintained.","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"(Image: image)","category":"page"},{"location":"getting_started/creating_your_own_model/#Define-temporal-and-stochastic-structures","page":"Creating Your Own Model","title":"Define temporal and stochastic structures","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To specify the temporal structure for SpineOpt, you need to define temporal_block objects. Think of a temporal_block as a distinctive way of 'slicing' time across the model horizon.\nTo link the temporal structure to the spatial structure, you need to specify node__temporal_block relationships, establishing which temporal__block applies to each node. This relationship is added by right-clicking the node__temporal_block in the relationship tree and then using the add relationships... dialog. Double clicking on an empty cell gives you the list of valid objects. The relationship name is automatically formed, but you can change it if that is desirable.\nTo keep things simple at this point, let's just define one temporal_block for our model and apply it to all nodes. We add the object hourly_temporal_block of type temporal_block following the same procedure as before and establish node__temporal_block relationships between node_gas and hourly_temporal_block, and electricity_node and hourly_temporal_block.\nIn practical terms, the above means that there energy flows over gas_node and electricity_node for each 'time-slice' comprised in hourly_temporal_block.\nSimilarly with the stochastic structure, each node is assigned a deterministic stochastic_structure. ","category":"page"},{"location":"getting_started/creating_your_own_model/#Define-the-spatial-structure","page":"Creating Your Own Model","title":"Define the spatial structure","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"To specify the spatial structure for SpineOpt, you will need to use the node, unit, and connection objects added before.\nNodes can be understood as spatial aggregators. In combination with units and connections, they form the energy network.\nUnits in SpineOpt represent any kind of conversion process. As one example, a unit can represent a power plant that converts the flow of a commodity fuel into an electricity and/or heat flow.\nConnections on the other hand describe the transport of goods from one location to another. Electricity lines and gas pipelines are examples of such connections. This example does not use connections.\nThe database should have an object gas_turbine for the unit object class and objects node_gas and node_elec for the node object class.\nNext, define how the unit and the nodes interact with each other: create a unit__from_node relationship between gas_turbine and node_gas, and unit__to_node relationships between gas_turbine and node_elec.\nIn practical terms, the above means that there is an energy flow going from node_gas into node_elec, through the gas_turbine.","category":"page"},{"location":"getting_started/creating_your_own_model/#Add-remaining-relationships-and-parameter-data-for-the-relationships.","page":"Creating Your Own Model","title":"Add remaining relationships and parameter data for the relationships.","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Similar to adding the objects and their parameter data, add the relationships and their parameter data based on the picture below. \nThe capacity of the gas_turbine has to be sufficient to meet the highest demand for electricity, otherwise the model will be infeasible (it is possible to set penalty values, but they are not included in this example).\nThe parameter fix_ratio_in_out_unit_flow forces the ratio between an input and output flow to be a constant. This is one way to establish an efficiency for a conversion process.","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"(Image: image)","category":"page"},{"location":"getting_started/creating_your_own_model/#Run-the-model","page":"Creating Your Own Model","title":"Run the model","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Select SpineOpt \nPress Execute selection.","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"(Image: image)","category":"page"},{"location":"getting_started/creating_your_own_model/#If-it-fails","page":"Creating Your Own Model","title":"If it fails","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Double-check that the data is correct\nTry to see what the problem might be\nAsk help from the discussion forum","category":"page"},{"location":"getting_started/creating_your_own_model/#Explore-the-results","page":"Creating Your Own Model","title":"Explore the results","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Double-clicking the Results database.","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"(Image: image) ","category":"page"},{"location":"getting_started/creating_your_own_model/#Create-and-run-scenarios-and-build-the-model-further","page":"Creating Your Own Model","title":"Create and run scenarios and build the model further","text":"","category":"section"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"Create a new alternative\nAdd parameter data for the new alternative\nConnect alternatives under a scenario. Toolbox modifies Base data with the data from the alternatives in the same scenario.\nExecute multiple scenarios in parallel. First run in a new Julia instance will need to compile SpineOpt taking some time.","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"(Image: image)","category":"page"},{"location":"getting_started/creating_your_own_model/","page":"Creating Your Own Model","title":"Creating Your Own Model","text":"(Image: image)","category":"page"},{"location":"concept_reference/unit__investment_temporal_block/","page":"-","title":"-","text":"unit__investment_temporal_block is a two-dimensional relationship between a unit and a temporal_block. This relationship defines the temporal resolution and scope of a unit's investment decision. Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__default_investment_temporal_block is specified and no unit__investment_temporal_block relationship is specified, the model__default_investment_temporal_block relationship will be used. Conversely if unit__investment_temporal_block is specified along with model__temporal_block, this will override model__default_investment_temporal_block for the specified unit.","category":"page"},{"location":"concept_reference/unit__investment_temporal_block/","page":"-","title":"-","text":"See also Investment Optimization","category":"page"},{"location":"concept_reference/write_ptdf_file/","page":"-","title":"-","text":"If this parameter value is set to true, a diagnostics file containing all the network power transfer distributions factors in CSV format will be written to the current directory.","category":"page"},{"location":"concept_reference/max_shutdown_ramp/","page":"-","title":"-","text":"The definition of the max_shutdown_ramp parameter will trigger the creation of the constraint on maximum shutdown ramp. It sets an upper bound on the unit_flow variable for the timestep right before a shutdown.","category":"page"},{"location":"concept_reference/max_shutdown_ramp/","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/max_ratio_in_out_unit_flow/","page":"-","title":"-","text":"The definition of the max_ratio_in_out_unit_flow parameter triggers the generation of the constraint_max_ratio_in_out_unit_flow and sets an upper bound on the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the from_node, i.e. the incoming flows to the unit, and the second node (or group of nodes), represents the to_node i.e. the outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of in over out, where in is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/max_ratio_in_out_unit_flow/","page":"-","title":"-","text":"To enforce e.g. a maximum ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing flow to the node group el_heat (consisting of the two nodes el and heat), the max_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/connection_investment_lifetime/","page":"-","title":"-","text":"connection_investment_lifetime is the minimum amount of time that a connection has to stay in operation once it's invested-in. Only after that time, the connection can be decomissioned. Note that connection_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/unit/","page":"-","title":"-","text":"A unit represents an energy conversion process, where energy of one commodity can be converted into energy of another commodity. For example, a gas turbine, a power plant, or even a load, can be modelled using a unit.","category":"page"},{"location":"concept_reference/unit/","page":"-","title":"-","text":"A unit always takes energy from one or more nodes, and releases energy to one or more (possibly the same) nodes. The former are specificed through the unit__from_node relationship, and the latter through unit__to_node. Every unit has a temporal and stochastic structures given by the units_on__temporal_block and [units_on__stochastic_structure] relationships. The model will generate unit_flow variables for every combination of unit, node, direction (from node or to node), time slice, and stochastic scenario, according to the above relationships.","category":"page"},{"location":"concept_reference/unit/","page":"-","title":"-","text":"The operation of the unit is specified through a number of parameter values. For example, the capacity of the unit, as the maximum amount of energy that can enter or leave it, is given by unit_capacity. The conversion ratio of input to output can be specified using any of fix_ratio_out_in_unit_flow, max_ratio_out_in_unit_flow, and min_ratio_out_in_unit_flow. The variable operating cost is given by vom_cost.","category":"page"},{"location":"concept_reference/fix_ratio_in_in_unit_flow/","page":"-","title":"-","text":"The definition of the fix_ratio_in_in_unit_flow parameter triggers the generation of the constraint_fix_ratio_in_in_unit_flow and fixes the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of in1 over in2, where in1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right order. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply.","category":"page"},{"location":"concept_reference/fix_ratio_in_in_unit_flow/","page":"-","title":"-","text":"To enforce e.g. for a unit u a fixed share of 0.8 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the fix_ratio_in_in_unit_flow parameter would be set to 0.8 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/has_binary_gas_flow/","page":"-","title":"-","text":"This parameter is necessary for the use of pressure driven gas transfer, for which the direction of flow is not known a priori. The parameter has_binary_gas_flow is a booelean method parameter, which - when set to true - triggers the generation of the binary variables binary_gas_connection_flow, which (together with the big_m parameter) forces the average flow through a pipeline to be unidirectional.","category":"page"},{"location":"concept_reference/unit_constraint/","page":"-","title":"-","text":"The user_constraint is a generic data-driven custom constraint, which allows for defining constraints involving multiple units, nodes, or connections. The constraint_sense parameter changes the sense of the user_constraint, while the right_hand_side parameter allows for defining the constant terms of the constraint.","category":"page"},{"location":"concept_reference/unit_constraint/","page":"-","title":"-","text":"Coefficients for the different variables appearing in the user_constraint are defined using relationships, like e.g. unit__from_node__user_constraint and connection__to_node__user_constraint for unit_flow and connection_flow variables, or unit__user_constraint and node__user_constraint for units_on, units_started_up, and node_state variables.","category":"page"},{"location":"concept_reference/unit_constraint/","page":"-","title":"-","text":"For more information, see the dedicated article on User Constraints","category":"page"},{"location":"concept_reference/max_ratio_out_out_unit_flow/","page":"-","title":"-","text":"The definition of the max_ratio_out_out_unit_flow parameter triggers the generation of the constraint_max_ratio_out_out_unit_flow and sets an upper bound on the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of out1 over out2, where out1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/max_ratio_out_out_unit_flow/","page":"-","title":"-","text":"To enforce a maximum ratio between two products of a unit u, e.g. setting the maximum share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"concept_reference/min_node_pressure/","page":"-","title":"-","text":"If a node has a node_pressure variable (see also the parameter has_pressure and this chapter), a lower bound on the pressure can be introduced through the min_node_pressure parameter, which triggers the generation of the minimum node pressure constraint.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Stochastic-Framework","page":"Stochastic Framework","title":"Stochastic Framework","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Scenario-based stochastics in unit commitment and economic dispatch models typically only consider branching scenario trees. However, sometimes the available stochastic data doesn't span over the entire desired modelling horizon, or all the modelled phenomena. Especially with increasing interest in energy system integration and sector coupling, stochastic data of consistent quality and/or length might be hard to come by.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"While these data issues can be circumvented by either cloning stochastic data across multiple scenario branches or generating dummy forecasts, they can result in inflated problem sizes. Furthermore, Ensuring realistic correlations between generated forecasts is extremely difficult, especially across multiple energy sectors.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"The stochastic framework in SpineOpt.jl aims to support stochastic directed acyclic graphs (DAGs) instead of only branching trees, allowing for scenarios to converge later on in the modelled horizon. In addition, the framework allows for slightly different stochastic scenario graphs for different variables, making it easier to define e.g. variables common between all stochastic scenarios.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Key-concepts","page":"Stochastic Framework","title":"Key concepts","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Here, we briefly describe the key concepts required to understand the stochastic framework:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"stochastic_scenario is essentially just a label for an alternative period of time, describing one possiblity of what may come to pass. Even in deterministic modelling with SpineOpt.jl, a single stochastic_scenario is required for labelling the deterministic timeline.\nStochastic DAG is the directed acyclic graph describing the parent_stochastic_scenario__child_stochastic_scenario relationships between the stochastic scenarios. The key difference between a stochastic DAG and a traditional stochastic tree is that the scenarios are allowed to have multiple parents, making it possible to converge scenarios into each other in addition to branching.\nStochastic path is a unique sequence of stochastic scenarios for traversing the stochastic DAG. Every (finite) stochastic DAG has a limited number of full stochastic paths that traverse it from roots (scenarios without parents) to leaves (scenarios without children). Here, we use the term stochastic path to refer to any subset of scenarios within a full stochastic path.\nstochastic_structure is essentially a \"realization\" of the stochastic DAG, with additional information like the stochastic_scenario_end and weight_relative_to_parents Parameters. These become relevant when we start discussing interactions between different stochastic structures.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"<img src=\"../../figs/dag_fullpath_path.svg\" width=\"40%\"/>","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"The above figure presents an example stochastic DAG with the individual stochastic scenarios labelled from s0-s8. An example full stochastic path [s0, s1, s5, s8] is highlighted in red, while an example stochastic path [s2, s4, s7] is highlighted in blue.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#General-idea-in-brief","page":"Stochastic Framework","title":"General idea in brief","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"The major issue with stochastic DAGs compared to stochastic trees, is that indexing constraints that include variables from multiple time steps (henceforth referred to as \"dynamic constraints\") needs rethinking. With stochastic trees, constraints can always be unambiguously indexed using (stochastic_scenario, last_time_step), since all stochastic scenarios only have a single parent. However, this is no longer the case for stochastic DAGs, as illustrated in the figures below:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"<img src=\"../../figs/branching.svg\" width=\"40%\"/>\n<img src=\"../../figs/converging.svg\" width=\"40%\"/>","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"The example on the left illustrates the \"traditional\" indexing in branching stochastic trees, where backtracking through the tree always leads to unambiguous (stochastic_scenario, time_step) indices. The example on the right shows a similar situation in a stochastic DAG, where backtracking through the DAG leads to four different (stochastic_scenario, time_step) indices, and thus requires four constraints to be generated and indexed.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Stochastic-path-indexing","page":"Stochastic Framework","title":"Stochastic path indexing","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"As discussed in the previous section, dynamic constraints in stochastic DAGs cannot be unambiguously indexed using a single (stochastic_scenario, time_step). However, they can be unambiguously indexed using (stochastic_path, time_step), where the stochastic path is the unique sequence of stochastic scenarios traversing the DAG. Since there are only a limited number of ways to traverse the DAG, represented by the full stochastic paths, we can identify the number of unique paths necessary for constraint generation as follows:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Identify all unique full stochastic paths, meaning all the possible ways of traversing the DAG from roots to leaves.\nFind all the stochastic scenarios that are active on all the time steps included in the constraint.\nFind all the unique stochastic paths by intersecting the set of active stochastic scenarios with the full stochastic paths.\nGenerate constraints over each unique stochastic path found in step 3.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-dynamic-constraint-generation","page":"Stochastic Framework","title":"Example dynamic constraint generation","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"<img src=\"../../figs/constraint_paths.svg\" width=\"40%\"/>","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"The above figure shows examples of two different dynamic constraints generated in a stochastic DAG: the red constraint including variables from timesteps t4-t5 and the blue constraint including variables from timesteps t1, t3. The full stochastic paths for traversing the above DAG are as follows:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"[s0, s1, s5, s8]\n[s0, s2, s3, s5, s8]\n[s0, s2, s4, s6, s8]\n[s0, s2, s4, s7, s8]","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"For the red constraint, the stochastic scenarios s5-s8 are active on the time steps t4-t5. All the above full stochastic paths include at least two of the active stochastic scenarios, but full paths 1 and 2 both produce an identical path [s5, s8], so the set of unique stochastic paths for the red constraint becomes:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"[s5, s8]\n[s6, s8]\n[s7, s8]","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"There are no paths [s5, s6], [s5, s7], [s6, s7] since following the DAG one cannot start from s5 and end up in s6, even though these stochastic scenarios are active.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"The blue constraint illustrates a case where the time step range is non-continuous. The active stochastic scenarios on t1, t3 are s1, s2, s4, s5, so again by comparing these to the full stochastic paths we get:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"[s1, s5]\n[s2, s5]\n[s2, s4]","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"In this case, the full stochastic paths 3 and 4 both produce the path [s2, s4], so only three unique constraints need to be generated. Again, the path [s1, s4] is invalid, since the DAG cannot be traversed from s1 to s4.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Interaction-between-different-stochastic-structures","page":"Stochastic Framework","title":"Interaction between different stochastic structures","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Stochastic path indexing in constraints also allows for \"distorting\" the stochastic DAG in different parts of the model. As long as the stochastic DAG itself isn't changed, meaning the parent_stochastic_scenario__child_stochastic_scenario relationships and the resulting full stochastic paths, we can actually define different stochastic structures and still be able to handle constraint generation between them. This is due to the fact that when determining the stochastic paths, it makes no difference whether we're looking at the same stochastic_structure at different time steps, or at two stochastic structures, one of which has been delayed, on the same time step. This is illustrated by the figure below:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"<img src=\"../../figs/delayed_stochastic_paths.svg\" width=\"50%\"/>","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"The above represents constraint generation over two stochastic structures, where the lower stochastic_structure has been delayed in respect to the one above. Nevertheless, the procedure for finding the stochastic paths for the constraints remains identical to the previous example:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Identify all unique full stochastic paths, meaning all the possible ways of traversing the DAG. As long as the DAG remains the same between all the involved stochastic structures, the pathing remains the same.\nFind all the stochastic scenarios that are active on all the stochastic structures and time steps included in the constraint.\nFind all the unique stochastic paths by intersecting the set of active scenarios with the full stochastic paths.\nGenerate constraints over each unique stochastic path found in step 3.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Stochastics-in-the-model-data-structure","page":"Stochastic Framework","title":"Stochastics in the model data structure","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"While the Key concepts and General idea in brief sections go over the stochastic framework in SpineOpt.jl in a more general sense, here we'll go over how to set up stochastics using SpineOpt.jl data structure. Simple step-by-step examples are also provided in the Example of deterministic stochastics, Example of branching stochastics, and Example of converging stochastics sections further below. We won't go into too much detail about the related Object Classes, Relationship Classes, or Parameters, since those can be found in their respective sections. Introductions to these concepts can also be found in the Structural object classes and Structural relationship classes sections, if necessary.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Setting-up-the-stochastic-framework","page":"Stochastic Framework","title":"Setting up the stochastic framework","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"As with all things in SpineOpt.jl, you'll want to start with adding the desired number of objects to the relevant Object Classes, as one cannot define relationships over objects that don't exist. For the stochastic framework, this means creating at least one stochastic_scenario and stochastic_structure object each. This needs to be done even if your model is fully deterministic, as even the deterministic structure needs to be labelled for SpineOpt.jl to recognize that it exists.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Next, if your model has multiple stochastic_scenario objects, you'll want to define how they are related using the parent_stochastic_scenario__child_stochastic_scenario relationship. This relationship essentially defines the stochastic DAG, as well as all the possible stochastic paths, explained in the Key concepts section. Unless the parent_stochastic_scenario__child_stochastic_scenario relationship is defined, there won't be a stochastic DAG, and all stochastic_scenario objects will be assumed to be completely independent of each other.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Now that you've set up the desired stochastic_scenario and stochastic_structure objects, as well as defined the stochastic DAG using the parent_stochastic_scenario__child_stochastic_scenario relationship, it's time to define the properties of the stochastic_structure objects using the stochastic_structure__stochastic_scenario relationship, and the stochastic_scenario_end and weight_relative_to_parents Parameters therein. You'll always have to define at least one stochastic_structure__stochastic_scenario relationship, as the stochastic_structure object is what connects the Systemic object classes to the stochastic framework. stochastic_structure__stochastic_scenario relationship holds two key Parameters:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"weight_relative_to_parents defines the coefficient the corresponding stochastic_scenario has in the Objective function, and needs to be defined for each stochastic_scenario included in the stochastic_structure. The weight is relative to the parents of the [stochastic_scenario], and is calculated as presented below.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"# For root `stochastic_scenarios` (meaning no parents)\n\nweight(scenario) = weight_relative_to_parents(scenario)\n\n# If not a root `stochastic_scenario`\n\nweight(scenario) = sum([weight(parent) * weight_relative_to_parents(scenario)] for parent in parents)","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"stochastic_scenario_end is a Duration type parameter that tells when the stochastic_scenario ends in relation to the start of the current optimization. When defined, the stochastic_scenario ends at the defined point in time, and spawns its children according to parent_stochastic_scenario__child_stochastic_scenario, if any. Note that this means the children are included in the stochastic_structure, even without an explicit relationship! If stochastic_scenario_end isn't defined, the stochastic_scenario is assumed to go on indefinetely.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Finally, with all the pieces in place, we'll need to connect the defined stochastic_structure objects to the desired objects in the Systemic object classes using the Structural relationship classes like  node__stochastic_structure etc. Here, we essentially tell which parts of the modelled system use which stochastic_structure. Since creating each of these relationships individually can be a bit of a pain, there are a few Meta relationship classes like the model__default_stochastic_structure, that can be used to set model-wide defaults that are used if specific relationships are missing.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-deterministic-stochastics","page":"Stochastic Framework","title":"Example of deterministic stochastics","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Here, we'll demonstrate step-by-step how to create the simplest possible stochastic frame: the fully deterministic one. See the Deterministic Stochastic Structure archetype for how the final data structure looks like, as well as how to connect this stochastic_structure to the rest of your model. ","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Create a stochastic_scenario called e.g. realization and a stochastic_structure called e.g. deterministic.\nWe can skip the parent_stochastic_scenario__child_stochastic_scenario relationship, since there isn't a stochastic DAG in this example, and the default behaviour of each stochastic_scenario being independent works for our purposes (only one stochastic_scenario anyhow).\nCreate the stochastic_structure__stochastic_scenario relationship for (deterministic, realization), and set its weight_relative_to_parents parameter to 1. We don't need to define the stochastic_scenario_end parameter, as we want the realization to go on indefinitely.\nRelate the deterministic stochastic_structure to all the desired system objects using the appropriate Structural relationship classes, or use the model-level default Meta relationship classes.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-branching-stochastics","page":"Stochastic Framework","title":"Example of branching stochastics","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Here, we'll demonstrate step-by-step how to create a simple branching stochastic tree, where one scenario branches into three at a specific point in time. See the Branching Stochastic Tree archetype for how the final data structure looks like, as well as how to connect this stochastic_structure to the rest of your model.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Create four stochastic_scenario objects called e.g. realization, forecast1, forecast2, and forecast3, and a stochastic_structure called e.g. branching.\nDefine the stochastic DAG by creating the parent_stochastic_scenario__child_stochastic_scenario relationships for (realization, forecast1), (realization, forecast2), and (realization, forecast3).\nCreate the stochastic_structure__stochastic_scenario relationship for (branching, realization), (branching, forecast1), (branching, forecast2), and (branching, forecast3).\nSet the weight_relative_to_parents parameter to 1 and the stochastic_scenario_end parameter e.g. to 6h for the stochastic_structure__stochastic_scenario relationship (branching, realization). Now, the realization stochastic_scenario will end after 6 hours of time steps, and its children (forecast1, forecast2, and forecast3) will become active.\nSet the weight_relative_to_parents Parameters for the (branching, forecast1), (branching, forecast2), and (branching, forecast3) stochastic_structure__stochastic_scenario relationships to whatever you desire, e.g. 0.33 for equal probabilities across all forecasts.\nRelate the branching stochastic_structure to all the desired system objects using the appropriate Structural relationship classes, or use the model-level default Meta relationship classes.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-converging-stochastics","page":"Stochastic Framework","title":"Example of converging stochastics","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Here, we'll demonstrate step-by-step how to create a simple stochastic DAG, where both branching and converging occurs. This example relies on the previous Example of branching stochastics, but adds another stochastic_scenario at the end, which is a child of the forecast1, forecast2, and forecast3 scenarios. See the Converging Stochastic Tree archetype for how the final data structure looks like, as well as how to connect this stochastic_structure to the rest of your model.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Follow the steps 1-5 in the previous Example of branching stochastics, except call the stochastic_structure something different, e.g. converging.\nCreate a new stochastic_scenario called e.g. converged_forecast.\nAlter the stochastic DAG by creating the parent_stochastic_scenario__child_stochastic_scenario relationships for (forecast1, converged_forecast), (forecast2, converged_forecast), and (forecast3, converged_forecast). Now all three forecasts will converge into a single converged_forecast.\nAdd the stochastic_structure__stochastic_scenario relationship for (converging, converged_forecast), and set its weight_relative_to_parents parameter to 1. Now, all the probability mass in forecast1, forecast2, and forecast3 will be summed up back to the converged_forecast.\nSet the stochastic_scenario_end Parameters of the stochastic_structure__stochastic_scenario relationships (converging, forecast1), (converging, forecast2), and (converging, forecast3) to e.g. 1D, so that all three scenarios end at the same time and the converged_forecast becomes active.\nRelate the converging stochastic_structure to all the desired system objects using the appropriate Structural relationship classes, or use the model-level default Meta relationship classes.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Working-with-stochastic-updating-data","page":"Stochastic Framework","title":"Working with stochastic updating data","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Now that we've discussed how to set up stochastics for SpineOpt, let's focus on stochastic data. The most complex form of input data SpineOpt can currently handle is both stochastic and updating, meaning that the values the parameter takes can depend on both the stochastic_scenario, and the analysis time (first time step) of each solve. However, just stochastic or just updating cases are supported as well, using the same input data format.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"In SpineOpt, stochastic data uses the Map data type from SpineInterface.jl. Essentially, Maps are general indexed data containers, which SpineOpt tries to interpret as stochastic data. Every time SpineOpt calls a parameter, it passes the stochastic_scenario and analysis time as keyword arguments to the parameter, but depending on the parameter type, it doesn't necessarily do anything with that information. For Map type parameters, those keyword arguments are used for navigating the indices of the Map to try and find the corresponding value. If the Map doesn't include the stochastic_scenario index it's looking for, it assumes there's no stochastic information in the Map and carries on to search for analysis time indices. This logic is useful for defining both stochastic and updating data, as well as either case by itself, as shown in the following examples.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-stochastic-data","page":"Stochastic Framework","title":"Example of stochastic data","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"By stochastic data, we mean parameter values that depend only on the stochastic_scenario. In such a case, the input data must be formatted as a Map with the following structure","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"stochastic_scenario value\nscenario1 value1\nscenario2 value2","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"where stochastic_scenario indices are simply Strings corresponding to the names of the stochastic_scenario objects. The values can be whatever data types SpineInterface.jl supports, like Constants, DateTimes, Durations, or TimeSeries. In the above example, the parameter will take value1 in scenario1, and value2 in scenario2. Note that since there's no analysis time index in this example, the values are used regardless of the analysis time.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-updating-data","page":"Stochastic Framework","title":"Example of updating data","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"By updating data, we mean parameter values that depend only on the analysis time. In such a case, the input data must be formatted as a Map with the following structure","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"analysis time value\n2000-01-01T00:00:00 value1\n2000-01-01T12:00:00 value2","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"where the analysis time indices are DateTime values. The values can be whatever data types SpineInterface.jl supports, like Constants, DateTimes, Durations, or TimeSeries. In the above example, the parameter will take value1 if the first time step of the current simulation is between 2000-01-01T00:00:00 and 2000-01-01T12:00:00, and value2 if the first time step of the simulation is after 2000-01-01T12:00:00. Note that since there's no stochastic_scenario index in this example, the values are used regardless of the stochastic_scenario.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Example-of-stochastic-updating-data","page":"Stochastic Framework","title":"Example of stochastic updating data","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"By stochastic updating data, we mean parameter values that depend on both the stochastic_scenario and the analysis time. In such a case, the input data must be formatted as a Map with the following structure","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"stochastic_scenario analysis time value\nscenario1 2000-01-01T00:00:00 value1\nscenario1 2000-01-01T12:00:00 value2\nscenario2 2000-01-01T00:00:00 value3\nscenario2 2000-01-01T12:00:00 value4","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"where the stochastic_scenario indices are simply Strings corresponding to the names of the stochastic_scenario objects, and the analysis time indices are DateTime values. The values can be whatever data types SpineInterface.jl supports, like Constants, DateTimes, Durations, or TimeSeries. In the above example, the parameter will take value1 if the first time step of the current simulation is between 2000-01-01T00:00:00 and 2000-01-01T12:00:00 and the parameter is called in scenario1, and value3 in scenario2. If the first time step of the current simulation is after 2000-01-01T12:00:00, the parameter will take value2 in scenario1, and value4 in scenario2.","category":"page"},{"location":"advanced_concepts/stochastic_framework/#Constraint-generation-with-stochastic-path-indexing","page":"Stochastic Framework","title":"Constraint generation with stochastic path indexing","text":"","category":"section"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Every time a constraint might refer to variables either on different time steps or on different stochastic scenarios (meaning different nodes or units), the constraint needs to use stochastic path indexing in order to be correctly generated for arbitrary stochastic DAGs. In practise, this means following the procedure outlined below:","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Identify all unique full stochastic paths, meaning all the possible ways of traversing the DAG. This is done along with generating the stochastic structure, so no real impact on constraint generation.\nFind all the stochastic scenarios that are active on all the stochastic structures and time slices included in the constraint.\nFind all the unique stochastic paths by intersecting the set of active scenarios with the full stochastic paths.\nGenerate constraints over each unique stochastic path found in step 3.","category":"page"},{"location":"advanced_concepts/stochastic_framework/","page":"Stochastic Framework","title":"Stochastic Framework","text":"Steps 2 and 3 are the crucial ones, and are currently handled by separate constraint_<constraint_name>_indices functions. Essentially, these functions go through all the variables on all the time steps included in the constraint, collect the set of active stochastic_scenarios on each time step, and then determine the unique active stochastic paths on each time step. The functions pre-form the index set over which the constraint is then generated in the add_constraint_<constraint_name> functions.","category":"page"},{"location":"advanced_concepts/unit_commitment/#Unit-commitment","page":"Unit Commitment","title":"Unit commitment","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"To incorporate technical detail about (clustered) unit-commitment statuses of units, the online, started and shutdown status of units can be tracked and constrained in SpineOpt. In the following, relevant relationships and parameters are introduced and the general working principle is described.","category":"page"},{"location":"advanced_concepts/unit_commitment/#Key-concepts-for-unit-commitment","page":"Unit Commitment","title":"Key concepts for unit commitment","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"Here, we briefly describe the key concepts involved in the representation of (clustered) unit commitment models:","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"units_on is an optimization variable that holds information about the on- or offline status of a unit. Unit commitment restrictions will govern how this variable can change through time.","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"units_on__temporal_block is a relationship linking the units_on variable of this unit to a specific temporal_block object. The temporal block holds information on the temporal scope and resolution for which the variable should be optimized.","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"online_variable_type is a method parameter and can take the values unit_online_variable_type_binary, unit_online_variable_type_integer, unit_online_variable_type_linear. If the binary value is chosen, the units status is modelled as a binary (classic UC). For clustered unit commitment units, the integer type is applicable. Note that if the parameter is not defined, the default will be linear. If the units status is not crucial, this can reduce the computational burden.","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"number_of_units defines how many units of a certain unit type are available. Typically this parameter takes a binary (UC) or integer (clustered UC) value. To avoid confusion the following distinction will be made in this document:  unit will be used to identify a Spine unit object, which can have multiple members. Together with the unit_availability_factor, this will determine the maximum number of members that can be online at any given time. (Thus restricting the units_on variable). The default value for this parameter is 1. It is possible to allow the model to increase the number_of_units itself, through Investment Optimization","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"unit_availability_factor: (number value or time series). Is the fraction of the time that this unit is considered to be available, by acting as a multiplier on the capacity. A time series can be used to indicate the intermittent character of renewable generation technologies.","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"min_up_time: (duration value). Sets the minimum time that a unit has to stay online after a startup. Inclusion of this parameter will trigger the creation of the constraint on Minimum up time (basic version)","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"min_down_time: (duration value). Sets the minimum time that a unit has to stay offline after a shutdown. Inclusion of this parameter will trigger the creation of the constraint on Minimum down time (basic version)","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"minimum_operating_point: (number value) limits the minimum value of the unit_flow variable for a unit which is currently online. Inclusion of this parameter will trigger the creation of the Constraint on minimum operating point","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"start_up_cost: \"number value\". Cost associated with starting up a unit.\nshut_down_cost: \"number value\". Cost associated with shutting down a unit.","category":"page"},{"location":"advanced_concepts/unit_commitment/#Illustrative-unit-commitment-examples","page":"Unit Commitment","title":"Illustrative unit commitment examples","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/#Step-1:-defining-the-number-of-members-of-a-unit-type","page":"Unit Commitment","title":"Step 1: defining the number of members of a unit type","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"A spine unit can represent multiple members. This can be incorporated in a model by setting the number_of_units parameter to a specific value. For example, if we define a single unit in a model as follows:","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"unit_1\nnumber_of_units: 2","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"And we link the unit to a certain node_1 with a unit__to_node relationship.","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"unit_1_to__node_1","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"The single spine unit defined here, now represents two members. This means that a single unit_flow variable will be created for this unit, but the restrictions as imposed by the Ramping and Reserves framework will be adapted to reflect the fact that there are two members present, thus doubling the total capacity.","category":"page"},{"location":"advanced_concepts/unit_commitment/#Step-2:-choosing-the-online_variable_type","page":"Unit Commitment","title":"Step 2: choosing the online_variable_type","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"Next, we have to decide the online_variable_type for this unit, which will restrict the kind of values that the units_on variable can take. This basically comes down to deciding if we are working in a classical UC framework (unit_online_variable_type_binary), a clustered UC framework (unit_online_variable_type_integer), or a relaxed clustered UC framework (unit_online_variable_type_linear), in which a non-integer number of units can be online.","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"The classical UC framework can only be applied when the number_of_units equals 1.","category":"page"},{"location":"advanced_concepts/unit_commitment/#Step-3:-imposing-a-minimum-operating-point","page":"Unit Commitment","title":"Step 3: imposing a minimum operating point","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"The output of an online unit to a specific node can be restricted to be above a certain minimum by choosing a value for the minimum_operating_point parameter. This parameter is defined for the unit__to_node relationship, and is given as a fraction of the unit_capacity. If we continue with the example above, and define the following objects, relationships, and parameters:","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"unit_1\nnumber_of_units: 2\nunit_online_variable_type: \"unit_online_variable_type_integer\"\nunit_1_to__node_1\nminimum_operating_point: 0.2\nunit_capacity: 200","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"It can be seen that in this case the unit_flow form unit_1 to node_1 must for any timestep t be larger than units_on(t) * 02 * 200","category":"page"},{"location":"advanced_concepts/unit_commitment/#Step-4:-imposing-a-minimum-up-or-down-time","page":"Unit Commitment","title":"Step 4: imposing a minimum up or down time","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"Spine units can also be restricted in their commitment status with minimum up- or down times by choosing a value for the min_up_time or min_down_time respectively. These parameters are defined for the unit object, and should be duration values. We can continue the example and add a minimum up time for the unit:","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"unit_1\nnumber_of_units: 2\nunit_online_variable_type: \"unit_online_variable_type_integer\"\nmin_up_time: 2h\nunit_1_to__node_1\nminimum_operating_point: 0.2\nunit_capacity: 200","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"Whereas the units_on variable was restricted (before inclusion of the min_up_time parameter) to be smaller than or equal to the number_of_units for any timestep t, it now has to be smaller than or equal to the number_of_units decremented with the units_started_up summed over the timesteps that include t - min_up_time. This implies that a unit which has started up, has to stay online for at least the min_up_time","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"To consider a simple example let's assume that we have a model with a resolution of 1h. Suppose that before t, there is no member of the unit online and in timestep t -> t + 1h, one member starts up. Another member starts up in timestep t + 1h \\-> t + 2h. The first startup, along with the minimum up time of 2 hours implies that the units_on variable of this unit has now changed to 1 in timestep t -> t + 1h and can not go back to 0 in timestep t-> t + 1h -> t + 2h. The second startup further restricts the number of units that are allowed to be online, it can be seen that the following restrictions apply when both startups are combined with the minimum up time of 2h:","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"t-> t + 1h : units_on = 1\nt + 1h -> t + 2h: units_on = 2\nt + 2h-> t + 3h: units_on in 12\nt + 3h-> t + 4h: units_on in 012","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"The minimum down time restrictions operate in very much the same way, they simply impose that units that have been shut down, have to stay offline for the chosen period of time.","category":"page"},{"location":"advanced_concepts/unit_commitment/#Step-5:-allocationg-a-cost-to-startups-or-shutdowns","page":"Unit Commitment","title":"Step 5: allocationg a cost to startups or shutdowns","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"Costs can be allocated to startups or shutdowns by choosing a value for the start_up_cost or shut_down_cost respectively.","category":"page"},{"location":"advanced_concepts/unit_commitment/#Step-6:-defining-unit-availabilities","page":"Unit Commitment","title":"Step 6: defining unit availabilities","text":"","category":"section"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"By defining a unit_availability_factor, the fact that typical members are not available all the time can be reflected in the model.","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"Typically, units are not available 100% of the time, due to scheduled maintenance, unforeseen outages, or other things. This can be incorporated in the model by setting the unit_availability_factor to a fractional value. For each timestep in the model, an upper bound is then imposed on the units_on variable, equal to number_of_units * unit_availability_factor. This parameter can not be used when the online_variable_type is binary. It should also be noted that when the online_variable_type is of integer type, the aforementioned product must be integer as well, since it will determine the value of the units_available parameter which is restricted to integer values. The default value for this parameter is 1.","category":"page"},{"location":"advanced_concepts/unit_commitment/","page":"Unit Commitment","title":"Unit Commitment","text":"The unit_availability_factor can also be taken as a timeseries. By allowing a different availability factor for each timestep in the model, it can perfectly be used to represent intermittent technologies of which the output cannot be fully controlled.","category":"page"},{"location":"concept_reference/commodity_physics/","page":"-","title":"-","text":"This parameter determines the specific formulation used to carry out dc load flow within a model. To enable power transfer distribution factor (ptdf) based load flow for a network of nodes and connections, all nodes must be related to a commodity with commodity_physics set to  commodity_physics_ptdf. To enable security constraint unit comment based on ptdfs and line outage distribution factors (lodf) all nodes must be related to a commodity with commodity_physics set to commodity_physics_lodf.","category":"page"},{"location":"concept_reference/commodity_physics/","page":"-","title":"-","text":"See also powerflow","category":"page"},{"location":"concept_reference/big_m/","page":"-","title":"-","text":"The big_m parameter is a property of the model object. The bigM method is commonly used for the purpose of recasting non-linear constraints into a mixed-integer reformulation. In SpineOpt, the bigM formulation is used to describe the sign of gas flow through a connection (if a pressure driven gas transfer model is used). The big_m parameter in combination with the binary variable binary_gas_connection_flow is used in the constraints on the gas flow capacity and the fixed node pressure points and ensures that the average flow through a pipeline is only in one direction and is constraint by the fixed pressure points from the outer approximation of the Weymouth equation. See Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling for reference.","category":"page"},{"location":"concept_reference/is_active/","page":"-","title":"-","text":"is_acive is a universal, utility parameter that is defined for every object class. When used in conjunction with the activity_control feature, the is_active parameter allows one to control whether or not a specific object is active within a model or not. ","category":"page"},{"location":"concept_reference/vom_cost/","page":"-","title":"-","text":"By defining the vom_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for the variable operation and maintenance costs associated with that unit over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/candidate_storages/","page":"-","title":"-","text":"Within an investments problem candidate_storages determines the upper bound on the storages investment decision variable in constraint storages_invested_available. In constraint node_state_cap the maximum node state will be the product of the storages investment variable and node_state_cap. Thus, the interpretation of candidate_storages depends on storage_investment_variable_type which determines the investment decision variable type. If storage_investment_variable_type is integer or binary, then candidate_storages represents the maximum number of discrete storages of size node_state_cap that may be invested in at the corresponding node. If storage_investment_variable_type is continuous, candidate_storages is more analagous to a maximum storage capacity with node_state_cap being analagous to a scaling parameter.","category":"page"},{"location":"concept_reference/candidate_storages/","page":"-","title":"-","text":"Note that candidate_storages is the main investment switch and setting a value other than none/nothing triggers the creation of the investment variable for storages at the corresponding node. Note that a value of zero will still trigger the variable creation but its value will be fixed to zero. This can be useful if an inspection of the related dual variables will yield the value of this resource.","category":"page"},{"location":"concept_reference/candidate_storages/","page":"-","title":"-","text":"See also Investment Optimization and storage_investment_variable_type","category":"page"},{"location":"concept_reference/max_units_on_coefficient_out_out/","page":"-","title":"-","text":"The max_units_on_coefficient_out_out parameter is an optional coefficient in the unit output-output ratio constraint controlled by the max_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_out_out/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_out_in, and max_units_on_coefficient_in_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_out_out and fix_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/unit_investment_variable_type/","page":"-","title":"-","text":"Within an investments problem unit_investment_variable_type determines the unit investment decision variable type. Since the unit_flows will be limited to the product of the investment variable and the corresponding unit_capacity for each unit_flow and since candidate_units represents the upper bound of the investment decision variable, unit_investment_variable_type thus determines what the investment decision represents. If unit_investment_variable_type is integer or binary, then candidate_units represents the maximum number of discrete units that may be invested. If unit_investment_variable_type is continuous, candidate_units is more analagous to a capacity with unit_capacity being analagous to a scaling parameter. For example, if unit_investment_variable_type = integer, candidate_units = 4 and unit_capacity for a particular unit_flow = 400 MW, then the investment decision is how many 400 MW units to build. If unit_investment_variable_type = continuous, candidate_units = 400 and unit_capacity for a particular unit_flow = 1 MW, then the investment decision is how much capacity if this particular unit to build. Finally, if unit_investment_variable_type = integer, candidate_units = 10 and unit_capacity for a particular unit_flow = 50 MW, then the investment decision is many 50MW blocks of capacity of this particular unit to build.","category":"page"},{"location":"concept_reference/unit_investment_variable_type/","page":"-","title":"-","text":"See also Investment Optimization and candidate_units","category":"page"},{"location":"concept_reference/fix_node_state/","page":"-","title":"-","text":"The fix_node_state parameter simply fixes the value of the node_state variable to the provided value, if one is found. Common uses for the parameter include e.g. providing initial values for node_state variables, by fixing the value on the first modelled time step (or the value before the first modelled time step) using a TimeSeries type parameter value with an appropriate timestamp. Due to the way SpineOpt handles TimeSeries data, the node_state variables are only fixed for time steps with defined fix_node_state parameter values.","category":"page"},{"location":"concept_reference/fix_connections_invested/","page":"-","title":"-","text":"The fix_connections_invested parameter can be used to fix the values of the connections_invested variable to preset values. If set to a Scalar type value, the connections_invested variable is fixed to that value for all time steps and stochastic_scenarios. Values for individual time steps can be fixed using TimeSeries type values.","category":"page"},{"location":"concept_reference/fix_connections_invested/","page":"-","title":"-","text":"See Investment Optimization for more information about the investment framework in SpineOpt.jl.","category":"page"},{"location":"concept_reference/has_voltage_angle/","page":"-","title":"-","text":"For the use of node-based lossless DC powerflow, each node will be associated with a node_voltage_angle variable. To enable the generation of the variable in the optimization model, the boolean parameter has_voltage_angle should be set true. The voltage angle at a certain node can also be constrained through the parameters max_voltage_angle and min_voltage_angle. More details on the use of  lossless nodal DC power flows are described here","category":"page"},{"location":"concept_reference/max_units_on_coefficient_in_out/","page":"-","title":"-","text":"The max_units_on_coefficient_in_out parameter is an optional coefficient in the unit input-output ratio constraint controlled by the max_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_in_out/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_out_in, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_in_out and fix_units_on_coefficient_in_out.","category":"page"},{"location":"concept_reference/storage_investment_variable_type/","page":"-","title":"-","text":"Within an investments problem storage_investment_variable_type determines the storage investment decision variable type. Since a node's node_state will be limited to the product of the investment variable and the corresponding node_state_cap and since candidate_storages represents the upper bound of the storage investment decision variable, storage_investment_variable_type thus determines what the investment decision represents. If storage_investment_variable_type is integer or binary, then candidate_storages represents the maximum number of discrete storages that may be invested-in. If storage_investment_variable_type is continuous, candidate_storages is more analagous to a capacity with node_state_cap being analagous to a scaling parameter. For example, if storage_investment_variable_type = integer, candidate_storages = 4 and node_state_cap = 1000 MWh, then the investment decision is how many 1000h MW storages to build. If storage_investment_variable_type = continuous, candidate_storages = 1000 and node_state_cap = 1 MWh, then the investment decision is how much storage capacity to build. Finally, if storage_investment_variable_type = integer, candidate_storages = 10 and node_state_cap = 100 MWh, then the investment decision is how many 100MWh storage blocks to build.","category":"page"},{"location":"concept_reference/storage_investment_variable_type/","page":"-","title":"-","text":"See also Investment Optimization and candidate_storages.","category":"page"},{"location":"concept_reference/the_basics/#Basics-of-the-model-structure","page":"Basics of the model structure","title":"Basics of the model structure","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"In SpineOpt.jl, the model structure is generated based on the input data, allowing it to be used for a multitude of different problems. Here, we aim to provide you with a basic understanding of the SpineOpt.jl model and data structure, while the Object Classes, Relationship Classes, Parameters, and Parameter Value Lists sections provide more in-depth explanations of each concept.","category":"page"},{"location":"concept_reference/the_basics/#introduction-to-object-classes","page":"Basics of the model structure","title":"Introduction to object classes","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Essentially, Object Classes represents different types of objects or entities that make up the model. For example, every power plant in the model is represented as an object of the object class unit, every power line as an object of the object class connection, and so forth. In order to add any new entity to a model, a new object has to be added to desired object class in the input data.","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Each object class has a very specific purpose in SpineOpt.jl, so understanding their differences is key. The Object Classes can be roughly divided into three distinctive groups, namely Systemic object classes, Structural object classes, and Meta object classes.","category":"page"},{"location":"concept_reference/the_basics/#Systemic-object-classes","page":"Basics of the model structure","title":"Systemic object classes","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"As the name implies, system Object Classes are used to describe the system to be modelled. Essentially, they define what you want to model. These include:","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"commodity represents different goods to be generated, consumed, transported, etc.\nconnection handles the transfer of commodities between nodes.\nnode ensures the balance of the commodity flows, and can be used to store commodities as well.\nunit handles the generation and consumption of commodities.","category":"page"},{"location":"concept_reference/the_basics/#Structural-object-classes","page":"Basics of the model structure","title":"Structural object classes","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Structural Object Classes are used to define the temporal and stochastic structure of the modelled problem, as well as custom User Constraints. Unlike the above system Object Classes, the structural Object Classes are more about how you want to model, instead of strictly what you want to model. These include:","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"stochastic_scenario represents a different forecast or another type of an alternative time period.\nstochastic_structure acts as a handle for a group of stochastic_scenarios with set properties.\ntemporal_block defines a period of time with the desired temporal resolution.\nuser_constraint is an optional custom constraint generated based on the input data.","category":"page"},{"location":"concept_reference/the_basics/#Meta-object-classes","page":"Basics of the model structure","title":"Meta object classes","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Meta Object Classes are used for defining things on the level of models or above, like model output and even multiple models for problem decompositions. These include:","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"model represents an individual model, grouping together all the things relevant for itself.\noutput defines which Variables are output from the model.\nreport groups together multiple output objects.","category":"page"},{"location":"concept_reference/the_basics/#introduction-to-relationship-classes","page":"Basics of the model structure","title":"Introduction to relationship classes","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"While Object Classes define all the objects or entities that make up a model, Relationship Classes define how those entities are related to each other. Thus, Relationship Classes hold no meaning on their own, and always include at least one object class.","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Similar to Object Classes, each relationship class has a very specific purpose in SpineOpt.jl, and understanding the purpose of each relationship class is paramount. The Relationship Classes can be roughly divided into Systemic relationship classes, Structural relationship classes, and Meta relationship classes, again similar to Object Classes.","category":"page"},{"location":"concept_reference/the_basics/#Systemic-relationship-classes","page":"Basics of the model structure","title":"Systemic relationship classes","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Systemic Relationship Classes define how Systemic object classes are related to each other, thus helping define the system to be modelled. Most of these relationships deal with which units and connections interact with which nodes, and how those interactions work. This essentially defines the possible commodity flows to be modelled. Systemic Relationship Classes include:","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"connection__from_node defines which node the connection can transfer a commodity from.\nconnection__to_node defines which node the connection can transfer a commodity to.\nconnection__node__node holds Parameters for connections between two nodes.\nnode__commodity defines which node holds which commodity.\nnode__node holds parameters for direct node-node interactions, like diffusion of commodities.\nunit__commodity defines which commodity the unit handles.\nunit__from_node defines which node the unit can take an input commodity from.\nunit__to_node defines which node the unit can output a commodity to.\nunit__node__node holds parameters for unit interactions between two nodes.","category":"page"},{"location":"concept_reference/the_basics/#Structural-relationship-classes","page":"Basics of the model structure","title":"Structural relationship classes","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Structural Relationship Classes primarily relate Structural object classes to Systemic object classes, defining what structures the individual parts of the system use. These are mostly used to determine the temporal and stochastic structures to be used in different parts of the modelled system, or custom User Constraints.","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"SpineOpt.jl has a very flexible temporal and stochastic structure, explained in detail in the Temporal Framework and Stochastic Framework sections of the documentation. Unfortunately, this flexibility requires quite a few different structural Relationship Classes, the most important of which are the following basic structural Relationship Classes:","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"node__stochastic_structure defines the stochastic_structure used for the node balance.\nnode__temporal_block defines the temporal blocks used for the node balance.\nparent_stochastic_scenario__child_stochastic_scenario defines the stochastic directed acyclic graph (DAG) of the Stochastic Framework.\nstochastic_structure__stochastic_scenario holds parameters for stochastic scenarios in the stochastic_structure.\nunits_on__stochastic_structure defines the stochastic_structure used for the online variable of the unit.\nunits_on__temporal_block defines the temporal blocks used for the online variable of the unit.","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Furthermore, there are also a number of advanced structural Relationship Classes, which are only necessary when using some of the optional features of SpineOpt.jl. For Investment Optimization, the following relationships control the stochastic and temporal structures of the investment variables:","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"connection__investment_stochastic_structure defines the stochastic_structure used for the investment Variables for the connection.\nconnection__investment_temporal_block defines the temporal blocks used for the investment Variables for the connection.user_constraint.\nnode__investment_stochastic_structure defines the stochastic_structure used for the investment Variables for the node.\nnode__investment_temporal_block defines the stochastic_structure used for the investment Variables for the node.\nunit__investment_stochastic_structure defines the stochastic_structure used for the investment Variables for the unit.\nunit__investment_temporal_block defines the temporal blocks used for the investment Variables for the unit.(@ref).","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"For User Constraints, which are essentially generic data-driven custom constraints, the following relationships are used to control which variables are included and with what coefficients:  ","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"connection__from_node__user_constraint holds Parameters for the connection_flow variable from the node in question in the custom user_constraint.\nconnection__to_node__user_constraint holds Parameters for the connection_flow variable to the node in question in the custom user_constraint.\nnode__user_constraint holds Parameters for the node_state variable in the custom user_constraint.\nunit__from_node__user_constraint holds Parameters for the unit_flow variable from the node in question in the custom user_constraint.\nunit__to_node__user_constraint holds Parameters for the unit_flow variable to the node in question in the custom user_constraint.","category":"page"},{"location":"concept_reference/the_basics/#Meta-relationship-classes","page":"Basics of the model structure","title":"Meta relationship classes","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Meta Relationship Classes are used for defining model-level settings, like which temporal blocks or stochastic structures are active, and what the model output is. These include:","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"model__default_investment_stochastic_structure defines a default stochastic_structure to be used for investment Variables when no other definitions exist.\nmodel__default_investment_temporal_block defines a default temporal_block to be used for investment Variables when no other definitions exist.\nmodel__default_stochastic_structure defines a default stochastic_structure to be used for nodes and units when no other definitions exist.\nmodel__default_temporal_block defines a default temporal_block to be used for nodes and units when no other definitions exist.\nmodel__report connects each report to the desired model.\nmodel__stochastic_structure defines which stochastic structures are active in which models.\nmodel__temporal_block defines which temporal blocks are active in which models.\nreport__output defines which outputs are part of which report.","category":"page"},{"location":"concept_reference/the_basics/#introduction-to-parameters","page":"Basics of the model structure","title":"Introduction to parameters","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"While the primary function of Object Classes and Relationship Classes is to define the system to be modelled and it's structure, Parameters exist to constrain them. Every parameter is attributed to at least one object class or relationship class, but some appear in many classes whenever they serve a similar purpose.","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Parameters accept different types of values depending on their purpose, e.g. whether they act as a flag for some specific functionality or appear as a coefficient in Constraints, so understanding each parameter is key. Most coefficient-type Parameters accept constant, time series, and even stochastic time series form input, but there are some exceptions. Most flag-type Parameters, on the other hand, have a restricted list of acceptable values defined by their Parameter Value Lists.","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"The existence of some Constraints is controlled based on if the relevant Parameters are defined. As a rule-of-thumb, a constraint only gets generated if at least one of the Parameters appearing in it is defined, but one should refer to the appropriate Constraints and Parameters sections when in doubt.","category":"page"},{"location":"concept_reference/the_basics/#Introduction-to-groups-of-objects","page":"Basics of the model structure","title":"Introduction to groups of objects","text":"","category":"section"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"Groups of objects are used within SpineOpt for different purposes. To create a group of objects, simply right-click the corresponding Object Class in the Spine Toolbox database editor and select Add object group. Groups are essentially special objects, that act as a single handle for all of its members.","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"On the one hand, groups can be used in order to impose constraints on the aggregation of a variable, e.g. on the sum of multiple unit_flow variables. Constraints based on parameters associated with the unit__node__node, unit__to_node, unit__from_node, connection__node__node, connection__to_node, connection__from_node can generally be used for this kind of flow aggregation by defining the parameters on groups of objects, typically node groups. (with the exception of variable fixing parameters, e.g. fix_unit_flow, fix_connection_flow etc.). See for instance constraint_unit_flow_capacity.","category":"page"},{"location":"concept_reference/the_basics/","page":"Basics of the model structure","title":"Basics of the model structure","text":"On the other hand, a node group can be used to for PTDF based powerflows. Here a node group is used to enforce a nodal balance on system level, while suppressing the node balances at individual nodes. See also balance_type and the node balance constraint.","category":"page"},{"location":"advanced_concepts/user_constraints/#User-Constraints","page":"User Constraints","title":"User Constraints","text":"","category":"section"},{"location":"advanced_concepts/user_constraints/","page":"User Constraints","title":"User Constraints","text":"User constraints allow the user to define arbitrary linear constraints involving most of the problem variables. This section describes this function and how to use it.","category":"page"},{"location":"advanced_concepts/user_constraints/#Key-User-Constraint-Concepts","page":"User Constraints","title":"Key User Constraint Concepts","text":"","category":"section"},{"location":"advanced_concepts/user_constraints/","page":"User Constraints","title":"User Constraints","text":"The basic principle: The basic steps involved in forming a user constraint are:","category":"page"},{"location":"advanced_concepts/user_constraints/","page":"User Constraints","title":"User Constraints","text":"Creating a user constraint object: One creates a new user_constraint object which will be used as a unique handle for the specific constraint and on which constraint-level parameters will be defined.\nSpecify which variables are involved in the constraint: this generally involves creating a relationship involving the user_constraint object. For example, specifying the relationship unit__from_node__user_constraint specifies that the corresponding unit_flow variable is involved in the constraint. The table below contains a complete list of variables and the corresponding relationships to set.\nSpecify the variable coefficients: this will generally involve specifying a parameter named *_coefficient on the relationship defined above to specify the coefficient on that particular variable in the constraint. For example, to define the coefficient on the unit_flow variable, one specifies the unit_flow_coefficient parameter on the approrpriate unit__from_node__user_constraint relationship. The table below contains a complete list of variables and the corresponding coefficient parameters to set.\nSpecify the right-hand-side constant term: The constraint should be formed in conventional form with all constant terms moved to the right-hand side. The right-hand-side constant term is specified by setting the right_hand_side user_constraint parameter.\nSpecify the constraint sense: this is done by setting the constraint_sense user_constraint parameter. The allowed values are ==, >= and <=.\nCoefficients can be defined on some parameters themselves. For example, one may specify a coefficient on a node's demand parameter. This is done by specifying the relationship node__user_constraint and specifying the demand_coefficient parameter on that relationship","category":"page"},{"location":"advanced_concepts/user_constraints/","page":"User Constraints","title":"User Constraints","text":"Piecewise unit_flow coefficients: As described in operating_points, specifying this parameter decomposes the unit_flow variable into a number of sub operating segment variables named unit_flow_op in the model and with an additional index, i for the operating segment. The intention of this functionality is to allow unit_flow coefficients to be defined individually per segment to define a piecewise linear function. To accomplish this, the steps are as described above with the exception that one must define operating_points on the appropriate unit__from_node or unit__to_node as an array type with the dimension corresponding to the number of operating points and then set the unit_flow_coefficient for the appropriate unit__from_node__user_constraint relationship, also as an array type with the same number of elements. Note that if operating points is defined as an array type with more than one elements, unit_flow_coefficient may be defined as either an array or non-array type. However, if operating_points is of non-array type, corresponding unit_flow_coefficients must also be of non-array types.\nVariables, relationships and coefficient guide for user constraints The table below provides guidance regarding what relationships and coefficients to set for various problem variables and parameters.","category":"page"},{"location":"advanced_concepts/user_constraints/","page":"User Constraints","title":"User Constraints","text":"Problem variable / Parameter Name Relationship Parameter\nunit_flow (direction=from_node) unit__from_node__user_constraint unit_flow_coefficient (non-array type)\nunit_flow (direction=to_node) unit__to_node__user_constraint unit_flow_coefficient (non-array type)\nunit_flow_op (direction=from_node) unit__from_node__user_constraint unit_flow_coefficient (array type)\nunit_flow_op (direction=to_node) unit__to_node__user_constraint unit_flow_coefficient (array type)\nconnection_flow (direction=from_node) connection__from_node__user_constraint connection_flow_coefficient\nconnection_flow (direction=to_node) connection__to_node__user_constraint connection_flow_coefficient\nnode_state node__user_constraint node_state_coefficient\nstorages_invested node__user_constraint storages_invested_coefficient\nstorages_invested_available node__user_constraint storages_invested_available_coefficient\ndemand node__user_constraint demand_coefficient\nunits_on unit__user_constraint units_on_coefficient\nunits_started_up unit__user_constraint units_started_up_coefficient\nunits_invested unit__user_constraint units_invested_coefficient\nunits_invested_available unit__user_constraint units_invested_available_coefficient\nconnections_invested connection__user_constraint connections_invested_coefficient\nconnections_invested_available connection__user_constraint connections_invested_available_coefficient","category":"page"},{"location":"concept_reference/unit_online_variable_type_list/","page":"-","title":"-","text":"unit_online_variable_type_list holds the possible values for the type of a unit's commitment status variable which may be chosen from binary, integer, or linear. ","category":"page"},{"location":"concept_reference/model__default_investment_temporal_block/","page":"-","title":"-","text":"model__default_investment_temporal_block is a two-dimensional relationship between a model and a temporal_block. This relationship defines the default temporal resolution and scope for all investment decisions in the model (units, connections and storages). Specifying model__default_investment_temporal_block for a model avoids the need to specify individual node__investment_temporal_block, unit__investment_temporal_block and connection__investment_temporal_block relationships. Conversely, if any of these individual relationships are defined (e.g. connection__investment_temporal_block) along with model__temporal_block, these will override model__default_investment_temporal_block.","category":"page"},{"location":"concept_reference/model__default_investment_temporal_block/","page":"-","title":"-","text":"See also Investment Optimization","category":"page"},{"location":"concept_reference/units_on__temporal_block/","page":"-","title":"-","text":"units_on__temporal_block is a relationship linking the units_on variable of a unit to a specific temporal_block object. As such, this relationship will determine which temporal block governs the on- and offline status of the unit. The temporal block holds information on the temporal scope and resolution for which the variable should be optimized.  ","category":"page"},{"location":"concept_reference/fix_ratio_out_in_unit_flow/","page":"-","title":"-","text":"The definition of the fix_ratio_out_in_unit_flow parameter triggers the generation of the constraint_fix_ratio_out_in_unit_flow and fixes the ratio between out and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right order.","category":"page"},{"location":"concept_reference/fix_ratio_out_in_unit_flow/","page":"-","title":"-","text":"To enforce e.g. a fixed ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ngthe fix_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/weight/","page":"-","title":"-","text":"The weight variable, defined for a temporal_block object can be used to assign different weights to different temporal periods that are modeled. It basically determines how important a certain temporal period is in the total cost, as it enters the Objective function. The main use of this parameter is for representative periods, where each representative period represents a specific fraction of a year or so.  ","category":"page"},{"location":"concept_reference/unit_idle_heat_rate/","page":"-","title":"-","text":"Used to implement the no-load or idle heat rate of a unit. This is the y-axis offset of the heat rate function and is the fuel consumed per unit time when a unit is online and that results in no additional output. This is defined on the unit__node__node relationship and it is assumed that the input flow from node 1 represents fuel consumption and the output flow to node 2 is the elecrical output. While the units depend on the data, unit_idle_heat_rate is generally expressed in GJ/hr. Used in conjunction with unit_incremental_heat_rate. unit_idle_heat_rate is only currently considered if unit_incremental_heat_rate is specified. A trivial unit_incremental_heat_rate of zero can be defined if there is no incremental heat rate.","category":"page"},{"location":"library/#Library","page":"Library","title":"Library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Documentation for SpineOpt.jl.","category":"page"},{"location":"library/#Contents","page":"Library","title":"Contents","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"Pages = [\"library.md\"]\r\nDepth = 3","category":"page"},{"location":"library/#Index","page":"Library","title":"Index","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"","category":"page"},{"location":"library/#Public-interface","page":"Library","title":"Public interface","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"run_spineopt","category":"page"},{"location":"library/#SpineOpt.run_spineopt","page":"Library","title":"SpineOpt.run_spineopt","text":"run_spineopt(url_in, url_out; <keyword arguments>)\n\nRun the SpineOpt from url_in and write report to url_out. At least url_in must point to valid Spine database. A new Spine database is created at url_out if it doesn't exist.\n\nKeyword arguments\n\nwith_optimizer=with_optimizer(Cbc.Optimizer, logLevel=0) is the optimizer factory for building the JuMP model.\n\ncleanup=true tells run_spineopt whether or not convenience functors should be set to nothing after completion.\n\nadd_constraints=m -> nothing is called with the Model object in the first optimization window, and allows adding user contraints.\n\nupdate_constraints=m -> nothing is called in windows 2 to the last, and allows updating contraints added by add_constraints.\n\nlog_level=3 is the log level.\n\n\n\n\n\n","category":"function"},{"location":"library/","page":"Library","title":"Library","text":"TODO","category":"page"},{"location":"library/#Internals","page":"Library","title":"Internals","text":"","category":"section"},{"location":"library/#Variable-library","page":"Library","title":"Variable library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"unit_flow_indices","category":"page"},{"location":"library/","page":"Library","title":"Library","text":"TODO","category":"page"},{"location":"library/#Constraint-library","page":"Library","title":"Constraint library","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"TODO","category":"page"},{"location":"library/#Objective","page":"Library","title":"Objective","text":"","category":"section"},{"location":"library/","page":"Library","title":"Library","text":"TODO","category":"page"},{"location":"concept_reference/fix_ratio_out_out_unit_flow/","page":"-","title":"-","text":"The definition of the fix_ratio_out_out_unit_flow parameter triggers the generation of the constraint_fix_ratio_out_out_unit_flow and fixes the ratio between outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the nodes (or group of nodes) in this relationship represent the to_node's', i.e. outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of out1 over out2, where out1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/fix_ratio_out_out_unit_flow/","page":"-","title":"-","text":"To enforce a fixed ratio between two products of a unit u, e.g. fixing the share of produced electricity flowing to node el  to 0.4 of the production of heat flowing to node heat, the fix_ratio_out_out_unit_flow parameter would be set to 0.4 for the relationship u__el__heat.","category":"page"},{"location":"mathematical_formulation/constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Balance-constraint","page":"Constraints","title":"Balance constraint","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_nodal_balance","page":"Constraints","title":"Nodal balance","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In SpineOpt, node is the place where an energy balance is enforced. As universal aggregators, they are the glue that brings all components of the energy system together. An energy balance is created for each node for all node_stochastic_time_indices, unless the balance_type parameter of the node takes the value balance_type_none or if the node in question is a member of a node group, for which the balance_type is balance_type_group. The parameter nodal_balance_sense defaults to equality, but can be changed to allow overproduction (nodal_balance_sense >=) or underproduction (nodal_balance_sense <=). The energy balance is enforced by the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_injection(nst) \r\n + sum_substack(connnd_inst) in connection_flow_indices  d_out == to_node\r\n v_connection_flow(connnd_inst)\r\n - sum_substack(connnd_outst) in connection_flow_indices  d_out == from_node\r\n v_connection_flow(connnd_outst)\r\n  + v_node_slack_pos(nst) \r\n  - v_node_slack_neg(nst) \r\n ==== \r\n 0 \r\n forall (nst) in node_stochastic_time_indices \r\n p_balance_type(n) = balance_type_none \r\n nexists ng in groups(n)  balance_type_group \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The constraint consists of the node injections, the net connection_flows and node slack variables.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_node_injection","page":"Constraints","title":"Node injection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The node injection itself represents all local production and consumption, represented by the sum of all connected unit flows and the nodal demand. The node injection is created for each node in the network (unless the node is only used for parameter aggregation purposes, see Introduction to groups of objects).","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_injection(nst) \r\n == \r\n + sum_substack(und_inst) in unit_flow_indices  d_out == to_node\r\n v_unit_flow(und_inst)\r\n - sum_substack(und_outst) in unit_flow_indices  d_out == from_node\r\n v_unit_flow(und_outst)\r\n - p_demand(nst)\r\n forall (nst) in node_stochastic_time_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_node_injection2","page":"Constraints","title":"Node injection with storage capability","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"If a node corresponds to a storage node, the parameter has_state should be set to true for this node. In this case the nodal injection will translate to the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_injection(nst) \r\n == \r\n (v_node_state(n s t_before)\r\n - v_node_state(n s t) cdot p_state_coeff(nst)) \r\n    Delta t_after \r\n  - v_node_state(n s t) cdot p_frac_state_loss(nst) \r\n  + sum_substack(n2st) in node_state_indices  exists diff_coeff(n2n)\r\nv_node_state(n2st)\r\n - sum_substack(n2st) in node_state_indices  exists diff_coeff(nn2)\r\nv_node_state(n2st)\r\n + sum_substack(und_inst) in unit_flow_indices  d_out == to_node\r\n v_unit_flow(und_inst)\r\n - sum_substack(und_outst) in unit_flow_indices  d_out == from_node\r\n v_unit_flow(und_outst)\r\n - demand(nst)\r\n forall (nt) in node_time_indices  p_has_state(n)\r\n forall s in stochastic_scenario_path \r\n t_before in t_before_t(t_after=t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that for simplicity, the stochastic path is assumed to be known. In the constraint constraint_node_injection.jl the active stochastic paths of all involved variables is retrieved beforehand.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_node_state_capacity","page":"Constraints","title":"Node state capacity","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"To limit the storage content, the v_node_state variable needs be constrained by the following equation:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_state(n s t)\r\n = p_node_state_cap(n s t)\r\n forall (nst) in node_stochastic_time_indices  \r\n p_has_state(n)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The discharging and charging behavior of storage nodes can be described through unit(s), representing the link between the storage node and the supply node. Note that the dis-/charging efficiencies and capacities are properties of these units. See the capacity constraint and the unit flow ratio constraints","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_cyclic_node_state","page":"Constraints","title":"Cyclic condition on node state variable","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"To ensure that the node state at the end of the optimization is at least the same value as the initial value at the beginning of the optimization (or higher), the cyclic node state constraint can be used by setting the cyclic_condition of a node__temporal_block to true. This triggers the following cyclic constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_state(n s t)\r\n =  v_node_state(n s t)\r\n forall (ntb) in p_cyclic_condition(ntb)  \r\n p_cyclic_condition(ntb) == true\r\n p_has_state(n) \r\n forall (nt_initial) in node_time_indices  \r\n n == n \r\n t_initial == t_before_t(t_after=first(t in tb))\r\n forall (nt_last) in node_time_indices  \r\n n == n \r\n t_last == last(t in tb))\r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Unit-operation","page":"Constraints","title":"Unit operation","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In the following, the operational constraints on the variables associated with units will be elaborated on. The static constraints, in contrast to the dynamic constraints, are addressing constraints without sequential time-coupling. It should however be noted that static constraints can still perform temporal aggregation.","category":"page"},{"location":"mathematical_formulation/constraints/#static-constraints-unit","page":"Constraints","title":"Static constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The fundamental static constraints for units within SpineOpt relate to the relationships between commodity flows from and to units and to limits on the unit flow capacity.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_ratio_unit_flow","page":"Constraints","title":"Conversion constraint / limiting flow shares inprocess / relationship in process","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"A unit can have different commodity flows associated with it. The most simple relationship between these flows is a linear relationship between input and/or output nodes/node groups. SpineOpt holds constraints for each combination of flows and also for the type of relationship, i.e. whether it is a maximum, minimum or fixed ratio between commodity flows. Note that node groups can be used in order to aggregate flows, i.e. to give a ratio between a combination of units flows.","category":"page"},{"location":"mathematical_formulation/constraints/#ratio_out_in","page":"Constraints","title":"Ratios between output and input flows of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"By defining the parameters fix_ratio_out_in_unit_flow, max_ratio_out_in_unit_flow or min_ratio_out_in_unit_flow, a ratio can be set between outgoing and incoming flows from and to a unit. Whenever there is only a single input node and a single output node, this relationship relates to the notion of an efficiency. Also, the ratio equation can for instance be used to relate emissions to input primary fuel flows. In the most general form of the equation, two node groups are defined (an input node group ng_in and an output node group ng_out), and a linear relationship is expressed between both node groups. Note that whenever the relationship is specified between groups of multiple nodes, there remains a degree of freedom regarding the composition of the input node flows within group ng_in  and the output node flows within group ng_out.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The constraint given below enforces a fixed, maximum or minimum ratio between outgoing and incoming unit_flow. Note that the potential node groups, that the parameters  fix_ratio_out_in_unit_flow, max_ratio_out_in_unit_flow and min_ratio_out_in_unit_flow defined on, are getting internally expanded to the members of the node group within the unit_flow_indices.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst_out) in unit_flow_indices  (undst_out)  in  (ung_outto_nodest) v_unit_flow(undst_out) cdot Delta t_out \r\n  \r\n ==  p_fix_ratio_out_in_unit_flow(ung_outng_inst) \r\n = p_max_ratio_out_in_unit_flow(ung_outng_inst) \r\n = p_min_ratio_out_in_unit_flow(ung_outng_inst)\r\n  \r\n cdot sum_substack(undst_in) in unit_flow_indices (undst_in) in (ung_infrom_nodest) v_unit_flow(undst_in) cdot Delta t_in \r\n + p_fixmaxmin_units_on_coefficient_out_in(ung_outng_inst) \r\n sum_substack(ust_units_on) in units_on_indices\r\n (ust_units_on) in (ust) v_units_on(ust_units_on) \r\n cdot min(Delta t_units_onDelta t) \r\n forall (u ng_out ng_in) in ind(p_fixmaxmin_ratio_out_in_unit_flow) \r\n forall t in time_slices forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that a right-hand side constant coefficient associated with the variable units_on can optionally be included, triggered by the existence of the fix_units_on_coefficient_out_in, max_units_on_coefficient_out_in, min_units_on_coefficient_out_in, respectively.","category":"page"},{"location":"mathematical_formulation/constraints/#ratio_in_out","page":"Constraints","title":"Ratios between input and output flows of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Similarly to the ratio between outgoing and incoming unit flows, a ratio can also be defined in reverse between incoming and outgoing flows.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst_in) in unit_flow_indices  (undst_in)  in  (ung_infrom_nodest) v_unit_flow(undst_in) cdot Delta t_in \r\n  \r\n ==  p_fix_ratio_in_out_unit_flow(ung_inng_outst) \r\n = p_max_ratio_in_out_unit_flow(ung_inng_outst) \r\n = p_min_ratio_in_out_unit_flow(ung_inng_outst)\r\n  \r\n cdot sum_substack(undst_out) in unit_flow_indices (undst_in) in (ung_into_nodest) v_unit_flow(undst_out) cdot Delta t_out \r\n + p_fixmaxmin_units_on_coefficient_in_out(ung_inng_outst) \r\n sum_substack(ust_units_on) in units_on_indices\r\n (ust_units_on) in (ust) v_units_on(ust_units_on) \r\n  cdot min(Delta t_units_onDelta t) \r\n forall (u ng_in ng_out) in ind(p_fixmaxmin_ratio_in_out_unit_flow) \r\n forall t in time_slices forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that a right-hand side constant coefficient associated with the variable units_on can optionally be included, triggered by the existence of the fix_units_on_coefficient_in_out, max_units_on_coefficient_in_out, min_units_on_coefficient_in_out, respectively.","category":"page"},{"location":"mathematical_formulation/constraints/#ratio_in_in","page":"Constraints","title":"Ratios between input and input flows of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Similarly to the ratio between outgoing and incoming units flows, one can also define a fixed, maximum or minimum ratio between incoming flows of a units.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst_in1) in unit_flow_indices  (undst_in1)  in  (ung_in1from_nodest) v_unit_flow(undst_in1) cdot Delta t_in1 \r\n  \r\n ==  p_fix_ratio_in_in_unit_flow(ung_in1ng_in2st) \r\n = p_max_ratio_in_in_unit_flow(ung_in1ng_in2st) \r\n = p_min_ratio_in_in_unit_flow(ung_in1ng_in2st)\r\n  \r\n cdot sum_substack(undst_in2) in unit_flow_indices (undst_in2) in (ung_in2from_nodest) v_unit_flow(undst_in2) cdot Delta t_in2 \r\n + p_fixmaxmin_units_on_coefficient_in_in(ung_in1ng_in2st) \r\n sum_substack(ust_units_on) in units_on_indices\r\n (ust_units_on) in (ust) v_units_on(ust_units_on) \r\n  cdot min(Delta t_units_onDelta t) \r\n forall (u ng_in1 ng_in2) in ind(p_fixmaxmin_ratio_in_in_unit_flow) \r\n forall t in time_slices forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that a right-hand side constant coefficient associated with the variable units_on can optionally be included, triggered by the existence of the fix_units_on_coefficient_in_in, max_units_on_coefficient_in_in, min_units_on_coefficient_in_in, respectively.","category":"page"},{"location":"mathematical_formulation/constraints/#ratio_out_out","page":"Constraints","title":"Ratios between output and output flows of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Similarly to the ratio between outgoing and incoming units flows, one can also define a fixed, maximum or minimum ratio between outgoing flows of a units.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst_out1) in unit_flow_indices  (undst_out1)  in  (ung_out1to_nodest) v_unit_flow(undst_out1) cdot Delta t_out1 \r\n  \r\n ==  p_fix_ratio_out_out_unit_flow(ung_out1ng_out2st) \r\n = p_max_ratio_out_out_unit_flow(ung_out1ng_out2st) \r\n = p_min_ratio_out_out_unit_flow(ung_out1ng_out2st)\r\n  \r\n cdot sum_substack(undst_out2) in unit_flow_indices (undst_out2) in (ung_out2to_nodest) v_unit_flow(undst_out2) cdot Delta t_out2 \r\n + p_fixmaxmin_units_on_coefficient_out_out(ung_out1ng_out2st) \r\n sum_substack(ust_units_on) in units_on_indices\r\n (ust_units_on) in (ust) v_units_on(ust_units_on) \r\n  cdot min(Delta t_units_onDelta t) \r\n forall (u ng_out1 ng_out2) in ind(p_fixmaxmin_ratio_out_out_unit_flow) \r\n forall t in time_slices forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that a right-hand side constant coefficient associated with the variable units_on can optionally be included, triggered by the existence of the fix_units_on_coefficient_out_out, max_units_on_coefficient_out_out, min_units_on_coefficient_out_out, respectively.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_unit_flow_capacity","page":"Constraints","title":"Bounds on the unit capacity","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In a multi-commodity setting, there can be different commodities entering/leaving a certain technology/unit. These can be energy-related commodities (e.g., electricity, natural gas, etc.), emissions, or other commodities (e.g., water, steel). The unit_capacity be specified for at least one unit__to_node or unit__from_node relationship, in order to trigger a constraint on the maximum commodity flows to this location in each time step. When desirable, the capacity can be specified for a group of nodes (e.g. combined capacity for multiple products).","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst) in unit_flow_indices  (undst)  in  (ungdst) v_unit_flow(undst) cdot Delta t \r\n = p_unit_capacity(ungdst) \r\n  cdot p_unit_conv_cap_to_flow(ungdst) \r\n  cdot sum_substack(ust_units_on) in units_on_indices\r\n(uDelta t_units_on in (ut) v_units_on(ust_units_on) \r\n cdot min(t_units_onDelta t) \r\n forall (ungd) in ind(p_unit_capacity) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that the conversion factor unit_conv_cap_to_flow has a default value of 1, but can be adjusted in case the unit of measurement for the capacity is different to the unit flows unit of measurement.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"When the unit also provides non-spinning reserves to a reserve node, the corresponding flows are excluded from the capacity constraint and the unit capacity constraint translates to the following inequality:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst) in unit_flow_indices  (undst)  in  (ungdst)  n in is_non_spinning v_unit_flow(undst) cdot Delta t \r\n = p_unit_capacity(ungdst) \r\n  cdot p_unit_conv_cap_to_flow(ungdst) \r\n  cdot sum_substack(ust_units_on) in units_on_indices\r\n(uDelta t_units_on in (ut) v_units_on(ust_units_on) \r\n cdot min(t_units_onDelta t) \r\n forall (ungd) in ind(p_unit_capacity) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Dynamic-constraints","page":"Constraints","title":"Dynamic constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Commitment-constraints","page":"Constraints","title":"Commitment constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For modeling certain technologies/units, it is important to not only have unit_flow variables of different commodities, but also model the online (\"commitment\") status of the unit/technology at every time step. Therefore, an additional variable units_on is introduced. This variable represents the number of online units of that technology (for a normal unit commitment model, this variable might be a binary, for investment planning purposes, this might also be an integer or even a continuous variable). To define the type of a commitment variable, see online_variable_type. Commitment variables will be introduced by the following constraints (with corresponding parameters):","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"constraint on units_on\nconstraint on units_available\nconstraint on the unit state transition\nconstraint on the minimum operating point\nconstraint on minimum down time\nconstraint on minimum up time\nconstraint on ramp rates","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_units_on","page":"Constraints","title":"Bound on online units","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The number of online units need to be restricted to the number of available units:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n  v_units_on(ust) \r\n = v_units_available(ust) \r\n forall (ust) in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_units_available","page":"Constraints","title":"Bound on available units","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The number of available units itself is constrained by the parameters unit_availability_factor and number_of_units, and the variable number of invested units units_invested_available:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_available(ust) \r\n == p_unit_availability_factor(ust) \r\n cdot (p_number_of_units(ust) \r\n + sum_(ust) in units_invested_available_indices v_units_invested_available(ust) ) \r\n forall (ust) in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The investment formulation is described in chapter Investments.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_unit_state_transition","page":"Constraints","title":"Unit state transition","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The units on status is constrained by shutting down and starting up actions. This transition is defined as follows:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_on(ust_after) \r\n - v_units_started_up(ust_after) \r\n + v_units_shut_down(ust_after) \r\n == v_units_on(ust_before) \r\n forall (ust_after) in units_on_indices \r\n forall t_before in t_before_t(t_after=t_after)  t_before in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_minimum_operating_point","page":"Constraints","title":"Constraint on minimum operating point","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The minimum operating point of a unit can be based on the unit_flows of input or output nodes/node groups ng:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst) in unit_flow_indices  (undt)  in  (ungdt) v_unit_flow(undst) cdot Delta t \r\n = p_minimum_operating_point(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n  cdot p_conv_cap_to_flow(ungdst) \r\n  cdot sum_substack(ust_units_on) in units_on_indices (uDelta t_units_on in (ut) v_units_on(ust_units_on) \r\n cdot min(Delta t_units_onDelta t) \r\n forall (ungd) in ind(p_minimum_operating_point) \r\n forall t in t_lowest_resolution(node__temporal_block(node=members(ng)))\r\n  forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that this constraint is always generated for the lowest resolution of all involved members of the node group ng, i.e. the lowest resolution of the involved units flows. This is also why the term min(Delta t_units_onDelta t) is added for the units on variable, in order to dis-/aggregate the units on resolution to the resolution of the unit flows.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_down_time","page":"Constraints","title":"Minimum down time (basic version)","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In order to impose a minimum offline time of a unit, before it can be started up again, the min_down_time parameter needs to be defined, which triggers the generation of the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_available(ust) \r\n - v_units_on(ust) \r\n = sum_substack(ust) in units_on_indices  t =t-p_min_down_time(ust) quad t = t\r\nv_units_shut_down(ust) \r\n forall (ust) in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that for the use reserves the generated minimum down time constraint will include startups for non-spinning reserves.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_up_time","page":"Constraints","title":"Minimum up time (basic version)","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Similarly to the minimum down time constraint, a minimum time that a unit needs to remain online after a startup can be imposed by defining the min_up_time parameter. This will trigger the generation of the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_on(ust) \r\n = sum_substack(ust) in units_on_indices  t =t-p_min_up_time(ust)  t = t\r\nv_units_started_up(ust) \r\n forall (ust) in units_on_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"This constraint can be extended to the use of nonspinning reserves. See also.","category":"page"},{"location":"mathematical_formulation/constraints/#Ramping-and-reserve-constraints","page":"Constraints","title":"Ramping and reserve constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"To include ramping and reserve constraints, it is a pre requisite that minimum operating points and maximum capacity constraints are enforced as described.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For dispatchable units, additional ramping constraints can be introduced. For setting up ramping characteristics of units see Ramping and Reserves. First, the unit flows are split into their online, start-up, shut-down and non-spinning ramping contributions.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_split_ramps","page":"Constraints","title":"Splitting unit flows into ramps","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst_after) in unit_flow_indices  (undt_after)  in  (undt_after) p_is_reserve(n) v_unit_flow(undst_after) \r\n + sum_substack(undst_after) in unit_flow_indices  (undt_after)  in  (undt_after) p_is_reserve(n)  p_upward_reserve(n) v_unit_flow(undst_after) \r\n - sum_substack(undst_after) in unit_flow_indices  (undt_after)  in  (undt_after) p_is_reserve(n)  p_downward_reserve(n) v_unit_flow(undst_after) \r\n - sum_substack(undst_before) in unit_flow_indices  (undt_before)  in  (undt_before) p_is_reserve(n) v_unit_flow(undst_before) \r\n ==  \r\n + sum_substack(undst_after) in ramp_up_unit_flow_indices  (undt_after)  in  (undt_after) v_ramp_up_unit_flow(undst_after)  \r\n + sum_substack(undst_after) in start_up_unit_flow_indices  (undt_after)  in  (undt_after) v_start_up_unit_flow(undst_after) \r\n + sum_substack(undst_after) in nonspin_ramp_up_unit_flow_indices  (undt_after)  in  (undt_after) v_nonspin_ramp_up_unit_flow(undst_after) \r\n - sum_substack(undst_after) in ramp_down_unit_flow_indices  (undt_after)  in  (undt_after) v_ramp_down_unit_flow(undst_after) \r\n - sum_substack(undst_after) in shut_down_unit_flow_indices  (undt_after)  in  (undt_after) v_shut_down_unit_flow(undst_after) \r\n - sum_substack(undst_after) in nonspin_ramp_down_unit_flow_indices  (undt_after)  in  (undt_after) v_nonspin_ramp_down_unit_flow(undst_after) \r\n forall (undst_after) in (\r\n ramp_up_unit_flow_indices\r\n start_up_unit_flow_indices\r\n nonspin_ramp_up_unit_flow_indices \r\n ramp_down_unit_flow_indices\r\n shut_down_unit_flow_indices\r\n nonspin_ramp_down_unit_flow_indices) \r\n forall t_before in t_before_t(t_after=t_after)  t_before in unit_flow_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that each individual tuple of the unit_flow_indices is split into its ramping contributions, if any of the ramping variables exist for this tuple. How to set-up ramps for units is described in Ramping and Reserves.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_ramp_up","page":"Constraints","title":"Constraint on spinning upwards ramp_up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The maximum online ramp up ability of a unit can be constraint by the ramp_up_limit, expressed as a share of the unit_capacity. With this constraint, online (i.e. spinning) ramps can be applied to groups of commodities (e.g. electricity + balancing capacity). Moreover, balancing product might have specific ramping requirements, which can herewith also be enforced.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in ramp_up_unit_flow_indices  (und)  in  (ungd) v_ramp_up_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t)\r\n (v_units_on(ust)\r\n - v_units_started_up(ust)) \r\n min(Delta tDelta t) \r\n cdot p_ramp_up_limit(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_ramp_up_limit)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that only online units that are not started up during this timestep are considered.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_start_up_ramp","page":"Constraints","title":"Constraint on minimum upward start up ramp_up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"To enforce a lower bound on the ramp of a unit during start-up, the min_startup_ramp given as a share of the unit_capacity needs to be defined, which triggers the constraint below. Usually, only non-reserve commodities can have a start-up ramp. However, it is possible to include them, by adding them to the ramp defining node ng.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in start_up_unit_flow_indices  (und)  in  (ungd) v_start_up_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t) v_units_started_up(ust) \r\n cdot p_min_startup_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_min_startup_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_start_up_ramp","page":"Constraints","title":"Constraint on maximum upward start up ramp_up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"This constraint enforces a upper limit on the unit ramp during startup process, triggered by the existence of the max_startup_ramp, which should be given as a share of the unit_capacity. Typically, only  ramp flows to non-reserve nodes are considered during the start-up process. However, it is possible to include them, by adding them to the ramp defining node ng.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in start_up_unit_flow_indices  (und)  in  (ungd) v_start_up_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t) v_units_started_up(ust) \r\n cdot p_max_startup_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_max_startup_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_down_time2","page":"Constraints","title":"Constraint on upward non-spinning start ups","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For non-spinning reserve provision, offline units can be scheduled to provide nonspinning reserves, if they have recovered their minimum down time. If nonspinning reserves are used for a unit, the minimum down-time constraint takes the following form:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_available(ust) \r\n - v_units_on(ust) \r\n = sum_substack(ust) in units_on_indices  t t-p_min_down_time(ust)  t = t\r\nv_units_shut_down(ust) \r\n + sum_substack(unst) in nonspin_units_started_up_indices (ust) in (ust)\r\n  v_nonspin_units_started_up(unst) \r\n forall (ust) in units_on_indices\r\n (unst) in nonspin_units_started_up_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_nonspin_ramp_up","page":"Constraints","title":"Minimum nonspinning ramp up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The nonspinning ramp flows of a units nonspin_ramp_up_unit_flow are dependent on the units holding available for nonspinning reserve provision, i.e. nonspin_units_started_up. A lower bound on these nonspinning reserves can be enforced by defining the min_res_startup_ramp parameter (given as a fraction of the unit_capacity).","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in nonspin_ramp_up_unit_flow_indices  (und)  in (ungd) v_nonspin_ramp_up_unit_flow(undst)  \r\n = \r\n + sum_substack(unst) in nonspin_units_started_up_indices  (un)  in (ung v_nonspin_units_started_up(unst)  \r\n cdot p_min_res_startup_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_min_res_startup_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_nonspin_ramp_up","page":"Constraints","title":"Maximum nonspinning ramp up","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The nonspinning ramp flows of a units nonspin_ramp_up_unit_flow are dependent on the units holding available for nonspinning reserve provision, i.e. nonspin_units_started_up. An upper bound on these nonspinning reserves can be enforced by defining the max_res_startup_ramp parameter (given as a fraction of the unit_capacity).","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in nonspin_ramp_up_unit_flow_indices  (und)  in (ungd) v_nonspin_ramp_up_unit_flow(undst)  \r\n = \r\n + sum_substack(unst) in nonspin_units_started_up_indices  (un)  in (ung v_nonspin_units_started_up(unst)  \r\n cdot p_max_res_startup_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_max_res_startup_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_ramp_down","page":"Constraints","title":"Constraint on spinning downward ramps","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Similarly to the online ramp up capbility of a unit, it is also possible to impose an upper bound on the online ramp down ability of unit by defining a ramp_down_limit, expressed as a share of the unit_capacity.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in ramp_down_unit_flow_indices  (und)  in  (ungd) v_ramp_down_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t)\r\n (v_units_on(ust)\r\n - v_units_started_up(ust)) \r\n cdot p_ramp_down_limit(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_ramp_down_limit)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_shut_down_ramp","page":"Constraints","title":"Lower bound on downward shut-down ramps","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"This constraint enforces a lower bound on the unit ramp during shutdown process. Usually, units will only provide shutdown ramps to non-reserve nodes. However, it is possible to include them, by adding them to the ramp defining node ng. The constraint is triggered by the existence of the min_shutdown_ramp parameter.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in shut_down_unit_flow_indices  (und)  in  (ungd) v_shut_down_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t) v_units_shut_down(ust) \r\n cdot p_min_shutdown_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_min_shutdown_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_shut_down_ramp","page":"Constraints","title":"Upper bound on downward shut-down ramps","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"This constraint enforces an upper bound on the unit ramp during shutdown process. Usually, units will only provide shutdown ramps to non-reserve nodes. However, it is possible to include them, by adding them to the ramp defining node ng. The constraint is triggered by the existence of the max_shutdown_ramp parameter.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in shut_down_unit_flow_indices  (und)  in  (ungd) v_shut_down_unit_flow(undst)  \r\n = \r\n + sum_substack(ust) in units_on_indices  (us) in (us)  tin t_overlap_t(t) v_units_shut_down(ust) \r\n cdot p_max_shutdown_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_max_shutdown_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_up_time2","page":"Constraints","title":"Constraint on upward non-spinning shut-downs","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For non-spinning downward reserves, online units can be scheduled for reserve provision through shut down if they have recovered their minimum up time. If nonspinning reserves are used the minimum up-time constraint becomes:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_on(ust) \r\n = sum_substack(ust) in units_on_indices  t t-p_min_up_time(ust) quad t = t\r\nv_units_started_up(ust) \r\n + sum_substack(unst) in nonspin_units_shut_down_indices  (ust) in (ust)\r\n  v_nonspin_units_shut_down(unst) \r\n forall (ust) in units_on_indices\r\n u in nonspin_units_started_up_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_nonspin_ramp_down","page":"Constraints","title":"Lower bound on the nonspinning downward reserve provision","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"A lower bound on the nonspinning reserve provision of a unit can be imposed by defining the min_res_shutdown_ramp parameter, which leads to the creation of the following constraint in the model:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in nonspin_ramp_down_unit_flow_indices  (undst)  in (undst) v_nonspin_ramp_down_unit_flow(undst)  \r\n = \r\n + sum_substack(unst) in nonspin_units_shut_down_indices  (unst)  in (unst) v_nonspin_units_shut_down(unst)  \r\n cdot p_min_res_shutdown_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_min_res_shutdown_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_nonspin_ramp_down","page":"Constraints","title":"Upper bound on the nonspinning downward reserve provision","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"An upper limit on the nonspinning reserve provision of a unit can be imposed by defining the max_res_shutdown_ramp parameter, which leads to the creation of the following constraint in the model:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(undst) in nonspin_ramp_down_unit_flow_indices  (undst)  in (undst) v_nonspin_ramp_down_unit_flow(undst)  \r\n = \r\n + sum_substack(unst) in nonspin_units_shut_down_indices  (unst)  in (unst) v_nonspin_units_shut_down(unst)  \r\n cdot p_max_res_shutdown_ramp(ungdst) \r\n cdot p_unit_capacity(ungdst) \r\n cdot p_conv_cap_to_flow(ungdst) \r\n forall (ungd) in ind(p_max_res_shutdown_ramp)\r\n forall s in stochastic_path forall t in time_slice\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_res_minimum_node_state","page":"Constraints","title":"Constraint on minimum node state for reserve provision","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Storage nodes can also contribute to the provision of reserves. The amount of balancing contributions is limited by the ramps of the storage unit (see above) and by the node state:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_node_state(n_stor s t)\r\n = p_node_state_min(n_stor s t) \r\n + sum_substack(un_resdst) in unit_flow_indices  u in unit_flow_indicesn=n_stor)  p_is_reserve_node(n_res)  v_unit_flow(un_resdst)  \r\n cdot p_minimum_reserve_activation_time(n_res) \r\n forall (n_storst) in node_stochastic_time_indices  p_has_state(n)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_unit_flow_capacity_w_ramps","page":"Constraints","title":"Bounds on the unit capacity including ramping constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"(Comment 2021-04-29: Currently under development)","category":"page"},{"location":"mathematical_formulation/constraints/#Operating-segments","page":"Constraints","title":"Operating segments","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_operating_point_bounds","page":"Constraints","title":"Operating segments of units","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The unit_flow_op operating segment variable is bounded by the difference between successive operating_points adjusted for unit_capacity","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_unit_flow_op(u n op s t) \r\n  = p_unit_capacity(u n d s t) \r\n  cdot v_units_available(u s t) \r\n  cdot p_unit_conv_cap_to_flow(u n d s t) \r\n cdot bigg(  p_operating_points(u n op s t) \r\n - begincases       \r\n       0                                      textif op = 1\r\n       p_operating_points(u n op-1 s t)  textotherwise\r\n    endcases bigg) \r\n forall (undst) in unit_flow_op_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_operating_point_sum","page":"Constraints","title":"Bounding unit flows by summing over operating segments","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"unit_flow is constrained to be the sum of all operating segment variables, unit_flow_op","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_unit_flow(u n s t) \r\n  = sum_op  v_unit_flow_op(u n op s t) \r\n forall (und) in operating_point_indices \r\n forall (undst) in unit_flow_op_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_unit_pw_heat_rate","page":"Constraints","title":"Unit piecewise incremental heat rate","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n               v_unit_flow(u n_in d s t) \r\n               = sum_op bigg( v_unit_flow_op(u n_out d op s t) \r\n               qquad cdot p_unit_incremental_heat_rate(u n_in n_out op s t) bigg)               \r\n               + v_units_on(u s t) cdot p_unit_idle_heat_rate(u n_in n_out s t) \r\n               + v_units_started_up(u s t) cdot p_unit_start_flow(u n_in n_out s t) \r\n               forall (un_inn_outst) in unit_pw_heat_rate_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Bounds-on-commodity-flows","page":"Constraints","title":"Bounds on commodity flows","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_max_cum_in_unit_flow_bound","page":"Constraints","title":"Upper bound on cumulated unit flows","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"To impose a limit on the cumulative amount of certain commodity flows, a cumulative bound can be set by defining the parameter max_cum_in_unit_flow_bound for entire optimization window:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(undst) in unit_flow_indices  (undt)  in  (ugngd) v_unit_flow(undst) cdot Delta t \r\n = p_max_cum_unit_flow_bound(ugngdst) \r\n forall (ugngd) in ind(p_max_cum_unit_flow_bound)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"(Comment 2021-04-29: Currently under development)","category":"page"},{"location":"mathematical_formulation/constraints/#Network-constraints","page":"Constraints","title":"Network constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#static-constraints-connection","page":"Constraints","title":"Static constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connection_flow_capacity","page":"Constraints","title":"Capacity constraint on connections","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In a multi-commodity setting, there can be different commodities entering/leaving a certain connection. These can be energy-related commodities (e.g., electricity, natural gas, etc.), emissions, or other commodities (e.g., water, steel). The connection_capacity should be specified for at least one connection__to_node or connection__from_node relationship, in order to trigger a constraint on the maximum commodity flows to this location in each time step. When desirable, the capacity can be specified for a group of nodes (e.g. combined capacity for multiple products). Note that the conversion factor connection_conv_cap_to_flow has a default value of 1, but can be adjusted in case the unit of measurement for the capacity is different to the connection flows unit of measurement.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(connndst) in connection_flow_indices  (connndst)  in  (connngdst) v_connection_flow(connndst) cdot Delta t \r\n - sum_substack(connnd_reversest) in connection_flow_indices  (connnst)  in  (connngst)  d_reverse = d v_connection_flow(connnd_reversest) cdot Delta t \r\n = p_connection_capacity(connngdst) \r\n cdot p_connection_availability_factor(connst) \r\n  cdot p_connection_conv_cap_to_flow(connngdst) Delta t\r\n forall (connngd) in ind(p_connection_capacity) \r\n nexists p_candidate_connections(conn)\r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"If the connection is a candidate_connections, i.e. can be invested in, the connection capacity constraint translates to:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(connndst) in connection_flow_indices  (connndst)  in  (connngdst) v_connection_flow(connndst) cdot Delta t \r\n - sum_substack(connnd_reversest) in connection_flow_indices  (connnst)  in  (connngst)  d_reverse = d v_connection_flow(connnd_reversest) cdot Delta t \r\n = p_connection_capacity(connngdst) \r\n cdot p_connection_availability_factor(connst) \r\n  cdot p_connection_conv_cap_to_flow(connngdst) Delta t\r\n cdot sum_substack(connst) in connections_invested_available_indices  (connst)  in  (connst_in_t(t_short)\r\nv_connections_invest_available(conn s t)\r\n forall (connngd) in ind(p_connection_capacity) \r\n exists p_candidate_connections(conn)\r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_ratio_out_in_connection_flow","page":"Constraints","title":"Fixed ratio between outgoing and incoming flows of a connection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"By defining the parameters fix_ratio_out_in_connection_flow, max_ratio_out_in_connection_flow or min_ratio_out_in_connection_flow, a ratio can be set between outgoing and incoming flows from and to a connection.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In the most general form of the equation, two node groups are defined (an input node group ng_in and an output node group ng_out), and a linear relationship is expressed between both node groups. Note that whenever the relationship is specified between groups of multiple nodes, there remains a degree of freedom regarding the composition of the input node flows within group ng_in  and the output node flows within group ng_out.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The constraint given below enforces a fixed, maximum or minimum ratio between outgoing and incoming connection_flow. Note that the potential node groups, that the parameters  fix_ratio_out_in_connection_flow, max_ratio_out_in_connection_flow and min_ratio_out_in_connection_flow are defined on, are getting internally expanded to the members of the node group within the connection_flow_indices.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(connndst_out) in connection_flow_indices  (connndst_out)  in  (connng_outto_nodest) v_connection_flow(connndst_out) cdot Delta t_out \r\n  \r\n ==  p_fix_ratio_out_in_connection_flow(connng_outng_inst) \r\n = p_max_ratio_out_in_connection_flow(connng_outng_inst) \r\n = p_min_ratio_out_in_connection_flow(connng_outng_inst)\r\n  \r\n cdot sum_substack(connndst_in) in connection_flow_indices (connndst_in) in (connng_infrom_nodest) v_connection_flow(connndst_in) cdot Delta t_in \r\n forall (conn ng_out ng_in) in ind(p_fixmaxmin_ratio_out_in_connection_flow) \r\n forall t in time_slices forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Specific-network-representation","page":"Constraints","title":"Specific network representation","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In the following, the different specific network representations are introduced. While the Static constraints find application in any of the different networks, the following equations are specific to the discussed use cases. Currently, SpineOpt incorporated equations for pressure driven gas networks, nodal lossless DC power flows and PTDF based lossless DC power flow.","category":"page"},{"location":"mathematical_formulation/constraints/#pressure-driven-gas-transfer-math","page":"Constraints","title":"Pressure driven gas transfer","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For gas pipelines it can be relevant a pressure driven gas transfer can be modelled, i.e. to account for linepack flexibility. Generally speaking, the main challenges related to pressure driven gas transfers are the non-convexities associated with the Weymouth equation. In SpineOpt, a convexified MILP representation has been implemented, which as been presented in Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling. The approximation approach is based on the Taylor series expansion around fixed pressure points.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In addition to the already known variables, such as connection_flow and node_state, the start and end points of a gas pipeline connection are associated with the variable node_pressure. The variable is triggered by the has_pressure parameter. For more details on how to set up a gas pipeline, see also the advanced concept section on pressure driven gas transfer.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_node_pressure","page":"Constraints","title":"Maximum node pressure","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In order to impose an upper limit on the maximum pressure at a node the maximum node pressure constraint can be included, by defining the parameter max_node_pressure which triggers the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_pressure_indices  (nst)  in  (nst) v_node_pressure(nst) cdot Delta t \r\n = p_max_node_pressure(ngst) cdot Delta t \r\n forall (ng) in ind(p_max_node_pressure) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"As indicated in the equation, the parameter max_node_pressure can also be defined on a node group, in order to impose an upper limit on the aggregated node_pressure within one node group.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_node_pressure","page":"Constraints","title":"Minimum node pressure","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In order to impose a lower limit on the pressure at a node the maximum node pressure constraint can be included, by defining the parameter min_node_pressure which triggers the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_pressure_indices  (nst)  in  (nst) v_node_pressure(nst) cdot Delta t \r\n = p_min_node_pressure(ngst) cdot Delta t \r\n forall (ng) in ind(p_min_node_pressure) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"As indicated in the equation, the parameter min_node_pressure can also be defined on a node group, in order to impose a lower limit on the aggregated node_pressure within one node group.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_compression_factor","page":"Constraints","title":"Constraint on the pressure ratio between two nodes","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"If a compression station is located in between two nodes, the connection is considered to be active and a compression ratio between the two nodes can be imposed. The parameter compression_factor needs to be defined on a connection__node__node relationship, where the first node corresponds the origin node, before the compression, while the second node corresponds to the destination node, after compression. The existence of this parameter will trigger the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_pressure_indices  (nst)  in  (ng2st) v_node_pressure(nst) cdot Delta t \r\n = p_compression_factor(connng1ng2st) \r\n sum_substack(nst) in node_pressure_indices  (nst)  in  (ng1st) v_node_pressure(nst) cdot Delta t \r\n forall (connng1ng2) in ind(p_compression_factor) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_fixed_node_pressure_point","page":"Constraints","title":"Outer approximation through fixed pressure points","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The Weymouth relates the average flows through a connection to the difference between the adjacent squared node pressures.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n   ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2 \r\n     - (v_connection_flow(conn n_destfrom_nodest) + v_connection_flow(conn n_origto_nodest))2)\r\n     cdot\r\n   ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2\r\n     - (v_connection_flow(conn n_destfrom_nodest) + v_connection_flow(conn n_origto_nodest))2 ) \r\n    = K(conn) cdot (v_node_pressure(n_origst)^2 - v_node_pressure(n_destst)^2) \r\n  endaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Which can be rewritten as","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n     ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2 \r\n       - (v_connection_flow(conn n_destfrom_nodest) + v_connection_flow(conn n_origto_nodest))2)\r\n      =  sqrtK(conn) cdot (v_node_pressure(n_origst)^2 - v_node_pressure(n_destst)^2) \r\n     forall (v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2  0\r\n  endaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"and","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"  beginaligned\r\n   ((v_connection_flow(conn n_destfrom_nodest) + v_connection_flow(conn n_origto_nodest))2\r\n   - (v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2) \r\n    = sqrtK(conn) cdot (v_node_pressure(n_destst)^2 - v_node_pressure(n_origst)^2) \r\n     forall (v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2  0\r\n  endaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"where K corresponds to the natural gas flow constant.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The cone described by the Weymouth equation can be outer approximated by a number of tangent planes, using a set of fixed pressure points, as illustrated in Schwele - Integration of Electricity, Natural Gas and Heat Systems With Market-based Coordination. The bigM method is used to replace the sign function.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The linearized version of the Weymouth equation implemented in SpineOpt is given as follows:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n     ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2 \r\n      = p_fixed_pressure_constant_1(connn_orign_destjst) cdot v_node_pressure(n_origst) \r\n     - p_fixed_pressure_constant_0(connn_orign_destjst) cdot v_node_pressure(n_destst) \r\n     + p_big_m cdot (1 - v_binary_gas_connection_flow(conn n_dest to_node s t)) \r\n      forall (conn n_orig n_dest) in ind(p_fixed_pressure_constant_1) \r\n     forall j in 1n(p_fixed_pressure_constant_1(connection=conn node1=n_orig node2=n_dest)) \r\n     p_fixed_pressure_constant_1(conn n_orig n_dest i=j) = 0 \r\n     forall t in time_slices \r\n     forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The parameters fixed_pressure_constant_1 and fixed_pressure_constant_0 should be defined in the database. For each considered fixed pressure point, they can be calculated as follows:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n   p_fixed_pressure_constant_1(connn_orign_destj) \r\n   = K(conn) cdot p_fixed_pressure(n_origj) sqrtp_fixed_pressure(n_origj)^2 - p_fixed_pressure(n_destj)^2\r\n   p_fixed_pressure_constant_0(connn_orign_destj) \r\n   = K(conn) cdot p_fixed_pressure(n_destj) sqrtp_fixed_pressure(n_origj)^2 - p_fixed_pressure(n_destj)^2\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"where K corrsponds to the natural gas flow constant.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The big_m parameter combined with the variable binary_gas_connection_flow together with the equations on unitary gas flow and on the maximum gas flow ensure that the bound on the average flow through the fixed pressure points becomes active, if the flow is in a positive direction for the observed set of connection, node1 and node2.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_connection_unitary_gas_flow","page":"Constraints","title":"Enforcing unidirectional flow","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"As stated above, the flow through a connection can only be in one direction at at time. Whether a flow is active in a certain direction is indicated by the binary_gas_connection_flow variable, which takes a value of 1 if the direction of flow is positive. To ensure that the binary_gas_connection_flow in the opposite direction then takes the value 0, the following constraint is enforced:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_binary_gas_connection_flow(conn n_orig to_node s t)) \r\n = (1 - v_binary_gas_connection_flow(conn n_dest to_node s t)) \r\n forall (ndst) in binary_gas_connection_flow_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_connection_flow_gas_capacity","page":"Constraints","title":"Gas connection flow capacity","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"To enforce that the averge flow of a connection is only in one direction, the flow in the opposite direction is forced to be 0 by the following euqation. For the connection flow in the direction of flow the parameter big_m should be chosen large enough to not become binding.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n     ((v_connection_flow(conn n_origfrom_nodest) + v_connection_flow(conn n_destto_nodest))2 \r\n      =  p_big_m cdot v_binary_gas_connection_flow(conn n_dest to_node s t) \r\n      forall (conn n_orig n_dest) in ind(p_fixed_pressure_constant_1) \r\n     forall t in time_slices \r\n     forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_storage_line_pack","page":"Constraints","title":"Linepack storage flexibility","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In order to account for linepack flexibility, i.e. storage capability of a connection, the linepack storage is linked to the average pressure of the adjacent nodes by the following equation, triggered by the parameter connection_linepack_constant:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n     v_node_state(n_storst) Delta t \r\n      = p_connection_linepack_constant(connn_storn_ngroup) 2 sum_substack(nst) in node_pressure_indices  (nst)  in  (ngst) v_node_pressure(nst) cdot Delta t \r\n      forall (conn n_stor n_ngroup) in ind(p_connection_linepack_constant) \r\n     forall t in time_slices \r\n     forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note that the parameter connection_linepack_constant should be defined on a connection__node__node relationship, where the first node corresponds to the linepack storage node, whereas the second node corresponds to the node group of both start and end nodes of the pipeline.","category":"page"},{"location":"mathematical_formulation/constraints/#nodal-lossless-DC","page":"Constraints","title":"Nodebased lossless DC power flow","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For the implementation of the nodebased loss DC powerflow model, a new variable node_voltage_angle is introduced. See also has_voltage_angle. For further explanation on setting up a database for nodal lossless DC power flow, see the advanced concept chapter on Lossless nodal DC power flows.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_max_node_voltage_angle","page":"Constraints","title":"Maximum node voltage angle","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In order to impose an upper limit on the maximum voltage angle at a node the maximum node voltage angle constraint can be included, by defining the parameter max_voltage_angle which triggers the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_voltage_angle_indices  (nst)  in  (nst) v_node_voltage_angle(nst) cdot Delta t \r\n = p_max_voltage_angle(ngst) \r\n cdot Delta t \r\n forall (ng) in ind(p_max_voltage_angle) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"As indicated in the equation, the parameter max_voltage_angle can also be defined on a node group, in order to impose an upper limit on the aggregated node_voltage_angle within one node group.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_min_node_voltage_angle","page":"Constraints","title":"Minimum node voltage angle","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In order to impose a lower limit on the voltage angle at a node the maximum node voltage angle constraint can be included, by defining the parameter min_voltage_angle which triggers the following constraint:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(nst) in node_voltage_angle_indices  (nst)  in  (nst) v_node_voltage_angle(nst) cdot Delta t \r\n = p_min_voltage_angle(ngst) \r\n cdot Delta t \r\n forall (ng) in ind(p_min_voltage_angle) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"As indicated in the equation, the parameter min_voltage_angle can also be defined on a node group, in order to impose a lower limit on the aggregated node_voltage_angle within one node group.","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_node_voltage_angle","page":"Constraints","title":"Voltage angle to connection flows","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"To link the flow over a connection to the voltage angles of the adjacent nodes, the following constraint is imposed. Note that this constraint is only generated if the parameter connection_reactance is defined for a connection__node__node relationship and if a fix_ratio_out_in_connection_flow is defined for the corresponding connection, node, node tuples.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n + sum_substack(connndst) in connection_flow_indices  d_from == from_node  n in n_from\r\n v_connection_flow(connndst)\r\n - sum_substack(connndst) in connection_flow_indices  d_from == from_node  n in n_to\r\n v_connection_flow(connnst)\r\n = \r\n 1p_connection_reactance(conn) cdot p_connection_reactance_base(conn)\r\n cdot (sum_substack(nst) in node_voltage_angle_indices  (nst)  in  (n_fromst) v_node_voltage_angle(nst) cdot Delta t \r\n - sum_substack(nst) in node_voltage_angle_indices  (nst)  in  (n_tost) v_node_voltage_angle(nst) cdot Delta t \r\n (conn n_to n_from) in indices(p_fix_ratio_out_in_connection_flow)\r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#PTDF-lossless-DC","page":"Constraints","title":"PTDF based DC lossless powerflow","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connection_intact_flow_ptdf","page":"Constraints","title":"Connection intact flow PTDF","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The power transfer distribution factors are a property of the network reactances. ptdf(n, c) represents the fraction of an injection at node n that will flow on connection c. The flow on connection c is then the sum over all nodes of ptdf(n, c)*net_injection(c). connection_intact_flow represents the flow on each line of the network will all candidate connections with PTDF-based flow present in the network.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n               + v_connection_intact_flow(c n_to d_to s t) \r\n               - v_connection_intact_flow(c n_to d_from s t) \r\n               == sum_n_inj Big( v_node_injection(n_inj s t) cdot p_ptdf(c n_inj) Big)               \r\n               forall (cn_tost) in connection_ptdf_flow_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_connection_flow_lodf","page":"Constraints","title":"N-1 post contingency connection flow limits","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The N-1 security constraint for the post-contingency flow on monitored connection, c_mon, upon the outage of contingency connection, c_conn, is formed using line outage distribution factors (lodf). lodf(c_con, c_mon) represents the fraction of the pre-contingency flow on connection c_conn that will flow on c_mon if c_conn is disconnected. If connection c_conn is disconnected, the post-contingency flow on monitored connection connection c_mon is the pre-contingency connection_flow on c_mon plus the line outage distribution factor (lodf) times the pre-contingency connection_flow on c_conn. This post-contingency flow should be less than the connection_emergency_capacity of c_mon.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n               + v_connection_flow(c_mon n_mon_to d_to s t) \r\n               - v_connection_flow(c_mon n_mon_to d_from s t) \r\n               + p_lodf(c_conn c_mon) cdot big(               \r\n               quad + v_connection_flow(c_conn n_conn_to d_to s t) \r\n               quad - v_connection_flow(c_conn n_conn_to d_from s t) big) \r\n                min( p_connection_emergency_capacity(c_mon n_conn_to d_to s t) p_connection_emergency_capacity(c_mon n_conn_to d_froms t)) \r\n               forall (c_mon c_conn s t) in constraint_connection_flow_lodf_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Investments","page":"Constraints","title":"Investments","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#Investments-in-units","page":"Constraints","title":"Investments in units","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_unit_lifetime","page":"Constraints","title":"Economic lifetime of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Enforces the minimum duration of a unit's investment decision. Once a unit has been invested-in, it must remain invested-in for unit_investment_lifetime.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_invested_available(ust) \r\n = sum_substack(ust) in units_invested_available_indices  t =t-p_unit_investment_lifetime(ust)  t = t\r\nv_units_invested(ust) \r\n forall (ust) in unit_investment_lifetime_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Technical-lifetime-of-a-unit","page":"Constraints","title":"Technical lifetime of a unit","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"(Comment 2021-04-29: Currently under development)","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_units_invested_available","page":"Constraints","title":"Available Investment Units","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The number of available invested-in units at any point in time is less than the number of investment candidate units.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_invested_available(ust) \r\n  p_candidate_units(ust) \r\n forall u in candidate_units_indices \r\n forall (ust) in units_invested_available_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_units_invested_transition","page":"Constraints","title":"Investment transfer","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"units_invested represents the point-in-time decision to invest in a unit or not while units_invested_available represents the invested-in units that are available in a specific timeslice. This constraint enforces the relationship between units_invested, units_invested_available and units_mothballed in adjacent timeslices.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_units_invested_available(ust_after) \r\n - v_units_invested(ust_after) \r\n + v_units_monthballed(ust_after) \r\n == v_units_invested_available(ust_before) \r\n forall (ust_after) in units_invested_available_indices \r\n forall t_before in t_before_t(t_after=t_after)  t_before in units_invested_available_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Investments-in-connections","page":"Constraints","title":"Investments in connections","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_connections_invested_available","page":"Constraints","title":"Available invested-in connections","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The number of available invested-in connections at any point in time is less than the number of investment candidate connections.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_connections_invested_available(cst) \r\n  p_candidate_connections(cst) \r\n forall c in candidate_connections_indices \r\n forall (cst) in connections_invested_available_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_connections_invested_transition","page":"Constraints","title":"Transfer of previous investments","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"connections_invested represents the point-in-time decision to invest in a connection or not while connections_invested_available represents the invested-in connections that are available in a specific timeslice. This constraint enforces the relationship between connections_invested, connections_invested_available and connections_decommissioned in adjacent timeslices.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_connections_invested_available(cst_after) \r\n - v_connections_invested(cst_after) \r\n + v_connections_decommissioned(cst_after) \r\n == v_connections_invested_available(cst_before) \r\n forall (cst_after) in connections_invested_available_indices \r\n forall t_before in t_before_t(t_after=t_after)  t_before in connections_invested_available_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_connection_flow_intact_flow","page":"Constraints","title":"Intact network ptdf-based flows on connections","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Enforces the relationship between connection_intact_flow (flow with all investments assumed in force) and connection_flow connection_intact_flow is the flow on all lines with all investments assumed in place. This constraint ensures that the connection_flow is connection_intact_flow plus additional flow contributions from investment connections that are not invested in.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n               + v_connection_flow(c n_to d_from s t) \r\n               - v_connection_flow(c n_to d_to s t) \r\n               - v_connection_intact_flow(c n_to d_from s t) \r\n               + v_connection_intact_flow(c n_to d_to s t) \r\n               ==\r\n               sum_c_candidate n_to_candidate p_lodf(c_candidate c) cdot Big( \r\n               qquad + v_connection_flow(c_candidate n_to_candidate d_from s t) \r\n               qquad - v_connection_flow(c_candidate n_to_candidate d_to s t) \r\n               qquad - v_connection_intact_flow(c_candidate n_to_candidate d_from s t) \r\n               qquad + v_connection_intact_flow(c_candidate n_to_candidate d_to s t)  Big)               \r\n               forall (cn_tost) in connection_flow_intact_flow_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_connection_intact_flow_capacity","page":"Constraints","title":"Intact connection flows capacity","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Similarly to constraint_connection_flow_capacity, limits connection_intact_flow according to connection_capacity","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n sum_substack(connndst) in connection_intact_flow_indices  (connndst)  in  (connngdst) v_connection_intact_flow(connndst) cdot Delta t \r\n - sum_substack(connnd_reversest) in connection_intact_flow_indices  (connnst)  in  (connngst)  d_reverse = d v_connection_intact_flow(connnd_reversest) cdot Delta t \r\n = p_connection_capacity(connngdst) \r\n cdot p_connection_availability_factor(connst) \r\n  cdot p_connection_conv_cap_to_flow(connngdst) Delta t\r\n forall (connngd) in ind(p_connection_capacity) \r\n forall t in time_slices \r\n forall s in stochastic_path\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_ratio_out_in_connection_intact_flow","page":"Constraints","title":"Fixed ratio between outgoing and incoming intact flows of a connection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For ptdf-based lossless DC power flow, ensures that the output flow to the to_node equals the input flow from the from_node.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned              \r\n               + v_connection_intact_flow(c n_out d_to s t) \r\n               ==\r\n               + v_connection_intact_flow(c n_in d_from s t)               \r\n               forall (cn_inn_outst) in connection_intact_flow_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_candidate_connection_flow_lb","page":"Constraints","title":"Lower bound on candidate connection flow","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For candidate connections with PTDF-based poweflow, together with constraint_candidate_connection_flow_ub, this constraint ensures that connection_flow is zero if the candidate connection is not invested-in and equals connection_intact_flow otherwise.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned              \r\n               + v_connection_flow(c n d s t) \r\n               =\r\n               + v_connection_intact_flow(c n d s t)               \r\n               - p_connection_capacity(c n d s t) cdot (p_candidate_connections(c s t) - v_connections_invested_available(c s t))         \r\n               forall (cndst) in constraint_candidate_connection_flow_lb_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_candidate_connection_flow_ub","page":"Constraints","title":"Upper bound on candidate connection flow","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For candidate connections with PTDF-based poweflow, together with constraint_candidate_connection_flow_lb, this constraint ensures that connection_flow is zero if the candidate connection is not invested-in and equals connection_intact_flow otherwise.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned              \r\n               + v_connection_flow(c n d s t) \r\n               =\r\n               + v_connection_intact_flow(c n d s t)               \r\n              \r\n               forall (cndst) in constraint_candidate_connection_flow_ub_indices \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_connection_lifetime","page":"Constraints","title":"Economic lifetime of a connection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Enforces the minimum duration of a connection's investment decision. Once a connection has been invested-in, it must remain invested-in for connection_investment_lifetime.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_connections_invested_available(cst) \r\n = sum_substack(cst) in connections_invested_available_indices  t =t-p_connection_investment_lifetime(cst)  t = t\r\nv_connections_invested(cst) \r\n forall (cst) in connection_investment_lifetime_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Technical-lifetime-of-a-connection","page":"Constraints","title":"Technical lifetime of a connection","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"(Comment 2021-04-29: Currently under development)","category":"page"},{"location":"mathematical_formulation/constraints/#Investments-in-storages","page":"Constraints","title":"Investments in storages","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note: can we actually invest in nodes that are not storages? (e.g. new location)","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_storages_invested_available","page":"Constraints","title":"Available invested storages","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The number of available invested-in storages at node n at any point in time is less than the number of investment candidate storages at that node.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_storages_invested_available(nst) \r\n  p_candidate_storages(nst) \r\n forall (n) in candidate_storages_indices \r\n forall (nst) in storages_invested_available_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_storages_invested_transition","page":"Constraints","title":"Storage capacity transfer? ","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"storages_invested represents the point-in-time decision to invest in storage at a node, n or not while storages_invested_available represents the invested-in storages that are available at a node in a specific timeslice. This constraint enforces the relationship between storages_invested, storages_invested_available and storages_decommissioned in adjacent timeslices.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_storages_invested_available(nst_after) \r\n - v_storages_invested(nst_after) \r\n + v_storages_decommissioned(nst_after) \r\n == v_storages_invested_available(nst_before) \r\n forall (nst_after) in storages_invested_available_indices \r\n forall t_before in t_before_t(t_after=t_after)  t_before in storages_invested_available_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_storage_lifetime","page":"Constraints","title":"Economic lifetime of a storage","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Enforces the minimum duration of a storage investment decision at node n. Once a storage has been invested-in, it must remain invested-in for storage_investment_lifetime.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n v_storages_invested_available(nst) \r\n = sum_substack(nst) in storages_invested_available_indices  t =t-p_storage_investment_lifetime(nst)  t = t\r\nv_storages_invested(nst) \r\n forall (nst) in storage_investment_lifetime_indices\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/#Technical-lifetime-of-a-storage","page":"Constraints","title":"Technical lifetime of a storage","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"(Comment 2021-04-29: Currently under development)","category":"page"},{"location":"mathematical_formulation/constraints/#Capacity-transfer","page":"Constraints","title":"Capacity transfer","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"(Comment 2021-04-29: Currently under development)","category":"page"},{"location":"mathematical_formulation/constraints/#Early-retirement-of-capacity","page":"Constraints","title":"Early retirement of capacity","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"(Comment 2021-04-29: Currently under development)","category":"page"},{"location":"mathematical_formulation/constraints/#benders_decomposition","page":"Constraints","title":"Benders decomposition","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"This section describes the high-level formulation of the benders-decomposed problem.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Taking the simple example of minimising capacity and operating cost for a fleet of units with a linear cost coefficient operational_cost_u :","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\nminimise\r\n\r\n+ sum_u p_unit_investment_cost(u) cdot v_units_invested(u)\r\n+ sum_u n t p_operational_cost cdot v_unit_flow(u n t)\r\nsubject to\r\n\r\nflow_unt le p_unit_capacity(u n t) cdot (v_units_available + v_units_invested_available(u n t))\r\nsum_unt v_unit_flow(ut) = p_demand(n t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"So this is a single problem that can't be decoupled over t because the investment variables units_invested_available couple the timesteps together. If units_invested_available were a constant in the problem, then all t's could be solved individually. This is the basic idea in Benders decomposition. We decompose the problem into a master problem and sub problems with the master problem optimising the coupling investment variables which are treated as constants in the sub problems.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The master problem in the initial benders iteration is simply to minimise total investment costs:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\nminimise Z\r\n\r\nZ ge sum_u p_unit_investment_cost(u) cdot v_units_invested(u)\r\nendaligned\r\n","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The solution to this problem yields values for the investment variables which are fixed as overlineunits_invested_u in the sub problem and will be zero in the first iteration.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The sub problem for benders iteration b then becomes :","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\nminimise\r\n\r\nobj_b = + sum_unt p_operational_cost(u) cdot v_unit_flow(unt)\r\nsubject to\r\n\r\nv_unit_flow(unt) le p_unit_capacity(u) cdot (v_units_available(ut) + p_units_invested_available(u t)) qquad mu_but \r\nsum_unt v_unit_flow(u n t) = p_demand(n t) \r\n\r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"This sub problem can be solved individually for each t. This is pretty trivial in this small example but if we consider a single t to be a single rolling horizon instead, decoupling the investment variables means that each rolling horizon can be solved individually rather than having to solve the entire model horizon as a single problem.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"mu_ut","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"is the marginal value of the capacity constraint and can be interpreted as the decrease in the objective function at time t for an additional MW of flow from unit u. This information is used to construct a benders cut which represents the reduction in the sub problem objective function which is possible in this benders iteration by adjusting the variable units_investment. This is effectively the decrease in operating costs possible by adding another unit of type u and is expressed as :","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"obj_b + sum_utp_unit_capacity(unt) cdot mu_but cdot (v_units_invested(ut) - p_units_invested(ubt))","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"In the first benders iteration, the value of the investment variables will have been zero so p_units_invested(ubt) will have the value of zero and thus the expression represents the total reduction in cost from an addition of a new unit of type u. This Benders cut is added to the master problem which then becomes, for each subsequent benders iteration, b:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\nminimise Z\r\n\r\nZ ge sum_ut p_unit_investment_cost(u) cdot v_units_invested(ut)\r\nsubject to\r\n\r\nZ ge + sum_u p_unit_investment_cost(u) cdot v_units_invested(ut)\r\n + sum_utp_unit_capacity(ut) cdot mu_but cdot (v_units_invested(ut) - p_units_invested(ubt)) qquad forall b \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Note the benders cuts are added as inequalities because they represent an upper bound on the value we are going to get from adjusting the master problem variables in that benders iteration. If we consider the example of renewable generation - because it's marginal cost is zero, on the first benders iteration, it could look like there would be a lot of value in increasing the capacity because of the marginal values from the sub problems. However, when the capacity variables are increased accordingly and curtailment occurs in the sub-problems, the marginal values will be zero when curtailment occurs and so, other resources may become optimal in subsequent iterations.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"This is a simple example but it illustrates the general strategy. The algorithm pseudo code looks something like this:","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"  initialise master problem\r\n  initialise sub problem\r\n  solve first master problem\r\n  create master problem variable time series\r\n  solve rolling spine opt model\r\n  save zipped marginal values\r\n  while master problem not converged\r\n      update master problem\r\n      solve master problem\r\n      update master problem variable timeseries for benders iteration b\r\n      rewind sub problem\r\n      update sub problem\r\n      solve rolling spine opt model\r\n      save zipped marginal values\r\n      test for convergence\r\n  end","category":"page"},{"location":"mathematical_formulation/constraints/#constraint_mp_any_invested_cuts","page":"Constraints","title":"Benders cuts","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The benders cuts for the problem including all investments in candidate connections, storages and units is given below.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\nv_objective_lower_bound(b)\r\n=\r\n + sum_ust p_units_invested_available_mv(utb) cdot lbrack v_units_invested_available(ust)-p_units_invested_available_bi(utb) rbrack \r\n + sum_cst p_connections_invested_available_mv(ctb) cdot lbrack v_connections_invested_available(cst)-p_connections_invested_available_bi(ctb) rbrack \r\n + sum_nst p_storages_invested_available_mv(ntb) cdot lbrack v_storages_invested_available(nst)-p_storages_invested_available_bi(ntb) rbrack \r\nendaligned","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"where","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"p_units_invested_available_mv","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"is the reduced cost of the units_invested_available fixed sub-problem variable, representing the reduction in operating costs possible from an investment in a unit of this type,   p_connections_invested_available_mv is the reduced cost of the connections_invested_available fixed sub-problem variable, representing the reduction in operating costs possible from an investment in a connection of this type,   p_storages_invested_available_mv is the reduced cost of the storages_invested_available fixed sub-problem variable, representing the reduction in operating costs possible from an investment in a storage of this type,   p_units_invested_available_bi(utb) is the value of the fixed sub problem variable units_invested_available(u,t) in benders iteration b,   p_connections_invested_available_bi(ctb) is the value of the fixed sub problem variable connections_invested_available(c,t) in benders iteration b and   p_storages_invested_available_bi(ntb) is the value of the fixed sub problem variable storages_invested_available(n,t) in benders iteration b","category":"page"},{"location":"mathematical_formulation/constraints/#User-constraints","page":"Constraints","title":"User constraints","text":"","category":"section"},{"location":"mathematical_formulation/constraints/#constraint_user_constraint","page":"Constraints","title":"User constraint","text":"","category":"section"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"The user_constraint is a generic data-driven custom constraint, which allows for defining constraints involving multiple units, nodes, or connections. The constraint_sense parameter changes the sense of the user_constraint, while the right_hand_side parameter allows for defining the constant terms of the constraint.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"Coefficients for the different variables appearing in the user_constraint are defined using relationships, like e.g. unit__from_node__user_constraint and connection__to_node__user_constraint for unit_flow and connection_flow variables, or unit__user_constraint and node__user_constraint for units_on, units_started_up, and node_state variables.","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"For more information, see the dedicated article on User Constraints","category":"page"},{"location":"mathematical_formulation/constraints/","page":"Constraints","title":"Constraints","text":"beginaligned\r\n+sum_substackun in unit__node__user_constraint(uc)ts \r\n begincases       \r\n  beginaligned\r\n       sum_substackop v_unit_flow_op(undopst) cdot p_unit_flow_coefficient(unopucst) qquad  textif  vert operating_points(u)vert  1       \r\n       v_unit_flow(undst) cdot p_unit_flow_coefficient(unucst) qquad textotherwise       \r\n  endaligned\r\n  endcases\r\n+sum_substacku in unit__user_constraint(uc)ts v_units_started_up(ust) cdot p_units_started_up_coefficient(uucst)\r\n+sum_substacku in unit__user_constraint(uc)ts v_units_on(ust) cdot p_units_on_coefficient(uucst)\r\n+sum_substackcn in connection__node__user_constraint(uc)ts v_connection_flow(cndst) cdot p_connection_flow_coefficient(cnucst)\r\n+sum_substackn in node__user_constraint(uc)ts v_node_state(nst) cdot p_node_state_coefficient(nucst)\r\n+sum_substackn in node__user_constraint(uc)ts p_demand(nst) cdot p_demand_coefficient(nucst)\r\n begincases  \r\n  beginaligned     \r\n       == qquad textif  p_constraint_sense(uc) text= ==\r\n       = qquad textif  p_constraint_sense(uc) text= =\r\n       = qquad textotherwise\r\n  endaligned\r\n  endcases\r\n+p_right_hand_side(ucts)\r\nforall ucts in constraint_user_constraint_indices\r\nendaligned","category":"page"},{"location":"concept_reference/min_startup_ramp/","page":"-","title":"-","text":"The definition of the min_startup_ramp parameter will trigger the creation of the constraint on minimum startup ramp. It sets a lower bound on the unit_flow variable for the timestep right after a startup.","category":"page"},{"location":"concept_reference/min_startup_ramp/","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/Object Classes/#Object-Classes","page":"Object Classes","title":"Object Classes","text":"","category":"section"},{"location":"concept_reference/Object Classes/#commodity","page":"Object Classes","title":"commodity","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A good or product that can be consumed, produced, traded. E.g., electricity, oil, gas, water...","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: commodity_lodf_tolerance, commodity_physics, commodity_ptdf_threshold and is_active","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: node__commodity and unit__commodity","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Commodities correspond to the type of energy traded. When associated with a node through the node__commodity relationship, a specific form of energy, i.e. commodity, can be associated with a specific location. Furthermore, by linking commodities with units, it is possible to track the flows of a certain commodity and impose limitations on the use of a certain commodity (See also max_cum_in_unit_flow_bound). For the representation of specific commodity physics, related to e.g. the representation of the electric network, designated parameters can be defined to enforce commodity specific behaviour. (See also commodity_physics)","category":"page"},{"location":"concept_reference/Object Classes/#connection","page":"Object Classes","title":"connection","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A transfer of commodities between nodes. E.g. electricity line, gas pipeline...","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: candidate_connections, connection_availability_factor, connection_contingency, connection_flow_cost, connection_investment_cost, connection_investment_lifetime, connection_investment_variable_type, connection_monitored, connection_reactance_base, connection_reactance, connection_resistance, connection_type, fix_connections_invested_available, fix_connections_invested, graph_view_position, has_binary_gas_flow and is_active","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__from_node__user_constraint, connection__from_node, connection__investment_stochastic_structure, connection__investment_temporal_block, connection__node__node, connection__to_node__user_constraint, connection__to_node and connection__user_constraint","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A connection represents a transfer of one commodity over space. For example, an electricity transmission line, a gas pipe, a river branch, can be modelled using a connection.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A connection always takes commodities from one or more nodes, and releases them to one or more (possibly the same) nodes. The former are specificed through the connection__from_node relationship, and the latter through connection__to_node. Every connection inherits the temporal and stochastic structures from the associated nodes. The model will generate connection_flow variables for every combination of connection, node, direction (from node or to node), time slice, and stochastic scenario, according to the above relationships.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"The operation of the connection is specified through a number of parameter values. For example, the capacity of the connection, as the maximum amount of energy that can enter or leave it, is given by connection_capacity. The conversion ratio of input to output can be specified using any of fix_ratio_out_in_connection_flow, max_ratio_out_in_connection_flow, and min_ratio_out_in_connection_flow parameters in the connection__node__node relationship. The delay on a connection, as the time it takes for the energy to go from one end to the other, is given by connection_flow_delay.","category":"page"},{"location":"concept_reference/Object Classes/#model","page":"Object Classes","title":"model","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"An instance of SpineOpt, that specifies general parameters such as the temporal horizon.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: big_m, duration_unit, is_active, max_gap, max_iterations, model_end, model_start, model_type, roll_forward, write_lodf_file, write_mps_file and write_ptdf_file","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: model__default_investment_stochastic_structure, model__default_investment_temporal_block, model__default_stochastic_structure, model__default_temporal_block, model__report, model__stochastic_structure and model__temporal_block","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"The model object holds general information about the optimization problem at hand. Firstly, the modelling horizon is specified on the model object, i.e. the scope of the optimization model, and if applicable the duration of the rolling window (see also model_start, model_end and roll_forward). Secondly, the model works as an overarching assembler - only through linking temporal_blocks and stochastic_structures to a model object via relationships, they become part of the optimization problem, and respectively linked nodes, connections and units. If desired the user can also specify defaults for temporals and stochastic via the designated default relationships (see e.g., model__default_temporal_block). In this case, the default temporal is populated for missing node__temporal_block relationships.  Lastly, the model object contains information about the algorithm used for solving the problem (see model_type).","category":"page"},{"location":"concept_reference/Object Classes/#node","page":"Object Classes","title":"node","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A universal aggregator of commodify flows over units and connections, with storage capabilities.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: balance_type, candidate_storages, demand, downward_reserve, fix_node_pressure, fix_node_state, fix_node_voltage_angle, fix_storages_invested_available, fix_storages_invested, frac_state_loss, fractional_demand, graph_view_position, has_pressure, has_state, has_voltage_angle, is_active, is_non_spinning, is_reserve_node, max_node_pressure, max_voltage_angle, min_node_pressure, min_voltage_angle, minimum_reserve_activation_time, nodal_balance_sense, node_opf_type, node_slack_penalty, node_state_cap, node_state_min, state_coeff, storage_investment_cost, storage_investment_lifetime, storage_investment_variable_type, tax_in_unit_flow, tax_net_unit_flow, tax_out_unit_flow and upward_reserve","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__from_node__user_constraint, connection__from_node, connection__node__node, connection__to_node__user_constraint, connection__to_node, node__commodity, node__investment_stochastic_structure, node__investment_temporal_block, node__node, node__stochastic_structure, node__temporal_block, node__user_constraint, unit__from_node__user_constraint, unit__from_node, unit__node__node, unit__to_node__user_constraint and unit__to_node","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"The node is perhaps the most important object class out of the Systemic object classes, as it is what connects the rest together via the Systemic relationship classes. Essentially, nodes act as points in the modelled commodity network where commodity balance is enforced via the node balance and node injection constraints, tying together the inputs and outputs from units and connections, as well as any external demand. Furthermore, nodes play a crucial role for defining the temporal and stochastic structures of the model via the node__temporal_block and node__stochastic_structure relationships. For more details about the Temporal Framework and the Stochastic Framework, please refer to the dedicated sections.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Since nodes act as the points where commodity balance is enforced, this also makes them a natural fit for implementing storage. The has_state parameter controls whether a node has a node_state variable, which essentially represents the commodity content of the node. The state_coeff parameter tells how the node_state variable relates to all the commodity flows. Storage losses are handled via the frac_state_loss parameter, and potential diffusion of commodity content to other nodes via the diff_coeff parameter for the node__node relationship.","category":"page"},{"location":"concept_reference/Object Classes/#output","page":"Object Classes","title":"output","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A variable name from SpineOpt that can be included in a report.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: is_active","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: report__output","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"An output is essentially a handle for a SpineOpt variable and Objective function to be included in a report and written into an output database. Typically, e.g. the unit_flow variables are desired as output from most models, so creating an output object called unit_flow allows one to designate it as something to be written in the desired report. Note that unless appropriate model__report and report__output relationships are defined, SpineOpt doesn't write any output!","category":"page"},{"location":"concept_reference/Object Classes/#report","page":"Object Classes","title":"report","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A results report from a particular SpineOpt run, including the value of specific variables.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: is_active and output_db_url","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: model__report and report__output","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A report is essentially a group of outputs from a model, that gets written into the output database as a result of running SpineOpt. Note that unless appropriate model__report and report__output relationships are defined, SpineOpt doesn't write any output!","category":"page"},{"location":"concept_reference/Object Classes/#settings","page":"Object Classes","title":"settings","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Internal SpineOpt settings. We kindly advise not to mess with this one.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: version","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"TODO","category":"page"},{"location":"concept_reference/Object Classes/#stochastic_scenario","page":"Object Classes","title":"stochastic_scenario","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A scenario for stochastic optimisation in SpineOpt.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: is_active","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: parent_stochastic_scenario__child_stochastic_scenario and stochastic_structure__stochastic_scenario","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Essentially, a stochastic_scenario is a label for an alternative period of time, describing one possibility of what might come to pass. They are the basic building blocks of the scenario-based Stochastic Framework in SpineOpt.jl, but aren't really meaningful on their own. Only when combined into a stochastic_structure using the stochastic_structure__stochastic_scenario and parent_stochastic_scenario__child_stochastic_scenario relationships, along with Parameters like the weight_relative_to_parents and stochastic_scenario_end, they become meaningful.","category":"page"},{"location":"concept_reference/Object Classes/#stochastic_structure","page":"Object Classes","title":"stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A group of stochastic scenarios that represent a structure.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: is_active","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__investment_stochastic_structure, model__default_investment_stochastic_structure, model__default_stochastic_structure, model__stochastic_structure, node__investment_stochastic_structure, node__stochastic_structure, stochastic_structure__stochastic_scenario, unit__investment_stochastic_structure and units_on__stochastic_structure","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"The stochastic_structure is the key component of the scenario-based Stochastic Framework in SpineOpt.jl, and essentially represents a group of stochastic_scenarios with set Parameters. The stochastic_structure__stochastic_scenario relationship defines which stochastic_scenarios are included in which stochastic_structures, and the weight_relative_to_parents and stochastic_scenario_end Parameters define the exact shape and impact of the stochastic_structure, along with the parent_stochastic_scenario__child_stochastic_scenario relationship.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"The main reason as to why stochastic_structures are so important is, that they act as handles connecting the Stochastic Framework to the modelled system. This is handled using the Structural relationship classes e.g. node__stochastic_structure, which define the stochastic_structure applied to each object describing the modelled system. Connecting each system object to the appropriate stochastic_structure individually can be a bit bothersome at times, so there are also a number of convenience Meta relationship classes like the model__default_stochastic_structure, which allow setting model-wide defaults to be used whenever specific definitions are missing.","category":"page"},{"location":"concept_reference/Object Classes/#temporal_block","page":"Object Classes","title":"temporal_block","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A length of time with a particular resolution.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: block_end, block_start, is_active, representative_periods_mapping, resolution and weight","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__investment_temporal_block, model__default_investment_temporal_block, model__default_temporal_block, model__temporal_block, node__investment_temporal_block, node__temporal_block, unit__investment_temporal_block and units_on__temporal_block","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A temporal block defines the temporal properties of the optimization that is to be solved in the current window. It is the key building block of the Temporal Framework. Most importantly, it holds the necessary information about the resolution and horizon of the optimization. A single model can have multiple temporal blocks, which is one of the main sources of temporal flexibility in Spine: by linking different parts of the model to different temporal blocks, a single model can contain aspects that are solved with different temporal resolutions or time horizons.","category":"page"},{"location":"concept_reference/Object Classes/#unit","page":"Object Classes","title":"unit","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A conversion of one/many comodities between nodes.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: candidate_units, curtailment_cost, fix_units_invested_available, fix_units_invested, fix_units_on, fom_cost, graph_view_position, is_active, min_down_time, min_up_time, number_of_units, online_variable_type, shut_down_cost, start_up_cost, unit_availability_factor, unit_investment_cost, unit_investment_lifetime, unit_investment_variable_type and units_on_non_anticipativity_time","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: unit__commodity, unit__from_node__user_constraint, unit__from_node, unit__investment_stochastic_structure, unit__investment_temporal_block, unit__node__node, unit__to_node__user_constraint, unit__to_node, unit__user_constraint, units_on__stochastic_structure and units_on__temporal_block","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A unit represents an energy conversion process, where energy of one commodity can be converted into energy of another commodity. For example, a gas turbine, a power plant, or even a load, can be modelled using a unit.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A unit always takes energy from one or more nodes, and releases energy to one or more (possibly the same) nodes. The former are specificed through the unit__from_node relationship, and the latter through unit__to_node. Every unit has a temporal and stochastic structures given by the units_on__temporal_block and [units_on__stochastic_structure] relationships. The model will generate unit_flow variables for every combination of unit, node, direction (from node or to node), time slice, and stochastic scenario, according to the above relationships.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"The operation of the unit is specified through a number of parameter values. For example, the capacity of the unit, as the maximum amount of energy that can enter or leave it, is given by unit_capacity. The conversion ratio of input to output can be specified using any of fix_ratio_out_in_unit_flow, max_ratio_out_in_unit_flow, and min_ratio_out_in_unit_flow. The variable operating cost is given by vom_cost.","category":"page"},{"location":"concept_reference/Object Classes/#user_constraint","page":"Object Classes","title":"user_constraint","text":"","category":"section"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"A generic data-driven custom constraint.","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Parameters: constraint_sense, is_active and right_hand_side","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"Related Relationship Classes: connection__from_node__user_constraint, connection__to_node__user_constraint, connection__user_constraint, node__user_constraint, unit__from_node__user_constraint, unit__to_node__user_constraint and unit__user_constraint","category":"page"},{"location":"concept_reference/Object Classes/","page":"Object Classes","title":"Object Classes","text":"TODO","category":"page"},{"location":"concept_reference/max_cum_in_unit_flow_bound/","page":"-","title":"-","text":"To impose a limit on the cumulative in flows to a unit for the entire modelling horizon, e.g. to enforce limits on emissions, the max_cum_in_unit_flow_bound parameter can be used. Defining this parameter triggers the generation of the constraint_max_cum_in_unit_flow_bound.","category":"page"},{"location":"concept_reference/max_cum_in_unit_flow_bound/","page":"-","title":"-","text":"Assuming for instance that the total intake of a unit u_A should not exceed 10MWh for the entire modelling horizon, then the max_cum_in_unit_flow_bound would need to take the value 10. (Assuming here that the unit_flow variable is in MW, and the model duration_unit is hours)","category":"page"},{"location":"concept_reference/fixed_pressure_constant_0/","page":"-","title":"-","text":"For the MILP representation of pressure driven gas transfer, we use an outer approximation approach as described by Schwele et al.. The Weymouth equation is approximated around fixed pressure points, as described by the constraint on fixed node pressure points, constraining the average flow in each direction dependent on the adjacent node pressures. The second fixed pressure constant, which will be multiplied with the pressure of the destination node, is represented by an Array value of the fixed_pressure_constant_0. The first pressure constant corresponds to the related parameter fixed_pressure_constant_1. Note that the fixed_pressure_constant_0 parameter should be defined on a connection__node__node relationship, for which the first node corresponds to the origin node, while the second node corresponds to the destination node. For a typical gas pipeline, the will be a fixed_pressure_constant_1  for both directions of flow.","category":"page"},{"location":"concept_reference/min_ratio_in_in_unit_flow/","page":"-","title":"-","text":"The definition of the min_ratio_in_in_unit_flow parameter triggers the generation of the constraint_min_ratio_in_in_unit_flow and sets a lower bound for the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of in1 over in2, where in1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply.","category":"page"},{"location":"concept_reference/min_ratio_in_in_unit_flow/","page":"-","title":"-","text":"To enforce e.g. for a unit u a minimum share of 0.2 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the min_ratio_in_in_unit_flow parameter would be set to 0.2 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Temporal-Framework","page":"Temporal Framework","title":"Temporal Framework","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Spine Model aims to provide a high degree of flexibility in the temporal dimension across different components of the created model. This means that the user has some freedom to choose how the temporal aspects of different components of the model are defined. This freedom increases the variety of problems that can be tackled in Spine: from very coarse, long term models, to very detailed models with a more limited horizon, or a mix of both. The choice of the user on how this flexibility is used will lead to the temporal structure of the model.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"The main components of flexibility consist of the following parts:","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"The horizon that is modeled: end and start time\nTemporal resolution\nPossibility of a rolling optimization window\nSupport for commonly used methods such as representative days","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Part of the temporal flexibility in Spine is due to the fact that these options mentioned above can be implemented differently across different components of the model, which can be very useful when different markets are coupled in a single model. The resolution and horizon of the gas market can for example be taken differently than that of the electricity market. This documentation aims to give the reader insight in how these aspects are defined, and which objects are used for this.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"We start by introducing the relevant objects with their parameters, and the relevant relationship classes for the temporal structure. Afterwards, we will discuss how this setting creates flexibility and will present some of the practical approaches to create a variety of temporal structures.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Objects,-relationships,-and-their-parameters","page":"Temporal Framework","title":"Objects, relationships, and their parameters","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"In this section, the objects and relationships will be discussed that form the temporal structure together.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Objects-relevant-for-the-temporal-framework","page":"Temporal Framework","title":"Objects relevant for the temporal framework","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"For the objects, the relevant parameters will also be introduced, along with the type of values that are allowed, following the format below:  ","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"'parameter_name' : \"Allowed value type\"","category":"page"},{"location":"advanced_concepts/temporal_framework/#[model](@ref)-object","page":"Temporal Framework","title":"model object","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Each model object holds general information about the model at hand. Here we only discuss the time related parameters:","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"model_start and model_end : \"Date time value\"","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"These two parameters define the model horizon. A Datetime value is to be taken for both parameters, in which case they directly mark respectively the beginning and end of the modeled time horizon.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"duration_unit (optional): \"minute or hour\"","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"This parameters gives the unit of duration that is used in the model calculations. The default value for this parameter is 'minute'.  E.g. if the duration_unit is set to hour, a Duration of one minute gets converted into 1/60 hours for the calculations.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"roll_forward (optional): \"duration value\"","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"This parameter defines how much the optimization window rolls forward in a rolling horizon optimization and should be expressed as a duration. In the practical approaches presented below, the rolling window optimization will be explained in more detail.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[temporal_block](@ref)-object","page":"Temporal Framework","title":"temporal_block  object","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"A temporal block defines the properties of the optimization that is to be solved in the current window. Most importantly, it holds the necessary information about the resolution and horizon of the optimization.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"resolution (optional): \"duration value\" or \"array of duration values\"","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"This parameter specifies the resolution of the temporal block, or in other words: the length of the timesteps used in the optimization run.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"block_start (optional): \"duration value\" or \"Date time value\"","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Indicates the start of this temporal block.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"block_end(optional): \"duration value\" or \"Date time value\"","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Indicates the end of this temporal block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Relationships-relevant-for-the-temporal-framework","page":"Temporal Framework","title":"Relationships relevant for the temporal framework","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#[model__temporal_block](@ref)-relationship","page":"Temporal Framework","title":"model__temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"In this relationship, a model instance is linked to a temporal block. If this relationship doesn't exist - the temporal block is disregarded from this optimization model.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[model__default_temporal_block](@ref)-relationship","page":"Temporal Framework","title":"model__default_temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Defines the default temporal block used for model objects, which will be replaced when a specific relationship is defined for a model in model__temporal_block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[node__temporal_block](@ref)-relationship","page":"Temporal Framework","title":"node__temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"This relationship will link a node to a temporal block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[units_on__temporal_block](@ref)-relationship","page":"Temporal Framework","title":"units_on__temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"This relationship links the units_on variable of a unit to a temporal block and will therefore govern the time-resolution of the unit's online/offline status.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[unit__investment_temporal_block](@ref)-relationship","page":"Temporal Framework","title":"unit__investment_temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"This relationship sets the temporal dimensions for investment decisions of a certain unit. The separation between this relationship and the units_on__temporal_block, allows the user for example to give a much finer resolution to a unit's on- or offline status than to it's investment decisions.","category":"page"},{"location":"advanced_concepts/temporal_framework/#[model__default_investment_temporal_block](@ref)-relationship","page":"Temporal Framework","title":"model__default_investment_temporal_block relationship","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Defines the default temporal block used for investment decisions, which will be replaced when a specific relationship is defined for a unit in unit__investment_temporal_block.","category":"page"},{"location":"advanced_concepts/temporal_framework/#General-principle-of-the-temporal-framework","page":"Temporal Framework","title":"General principle of the temporal framework","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"The general principle of the Spine modeling temporal structure is that different temporal blocks can be defined and linked to different objects in a model. This leads to great flexibility in the temporal structure of the model as a whole. To illustrate this, we will discuss some of the possibilities that arise in this framework.","category":"page"},{"location":"advanced_concepts/temporal_framework/#One-single-temporal_block","page":"Temporal Framework","title":"One single temporal_block","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#Single-solve-with-single-block","page":"Temporal Framework","title":"Single solve with single block","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"The simplest case is a single solve of the entire time horizon (so roll_forward not defined) with a fixed resolution. In this case, only one temporal block has to be defined with a fixed resolution. Each node has to be linked to this temporal_block.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Alternatively, a variable resolution can be defined by choosing an array of durations for the resolution parameter. The sum of the durations in the array then have to match the length of the temporal block. The example below illustrates an optimization that spans one day for which the resolution is hourly in the beginning and then gradually decreases to a 6h resolution at the end.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"temporal_block_1\nblock_start: 0h (Alternative DateTime: e.g. 2030-01-01T00:00:00)\nblock_end: 1D (Alternative DateTime: e.g. 2030-01-02T00:00:00)\nresolution: [1h 1h 1h 1h 2h 2h 2h 4h 4h 6h]","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Note that, as mentioned above, the block_start and block_end parameters can also be entered as absolute values, i.e. DateTime values.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Rolling-window-optimization-with-single-block","page":"Temporal Framework","title":"Rolling window optimization with single block","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"A model with a single temporal_block can also be optimized in a rolling horizon framework. In this case, the roll_forward parameter has to be defined in the model object. The roll_forward parameter will then determine how much the optimization moves forward with every step, while the size of the temporal block will determine how large a time frame is optimized in each step. To see this more clearly, let's take a look at an example.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Suppose we want to model a horizon of one week, with a rolling window size of one day. The roll_forward parameter will then be a duration value of 1d. If we take the temporal_block parameters block_start and block_end to be the duration values 0h and 1d respectively, the model will optimize each day of the week separately. However, we could also take the block_end parameter to be 2d. Now the model will start by optimizing day 1 and day 2 together, after which it keeps only the values obtained for the first day, and moves forward to optimize the second and third day together.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Again, a variable resolution can be implemented for the rolling window optimization. The sum of the durations must in this case match the size of the optimized window.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Advanced-usage:-multiple-temporal_block-objects","page":"Temporal Framework","title":"Advanced usage: multiple temporal_block objects","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#Single-solve-with-multiple-blocks","page":"Temporal Framework","title":"Single solve with multiple blocks","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#Disconnected-time-periods","page":"Temporal Framework","title":"Disconnected time periods","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Multiple temporal blocks can be used to optimize disconnected periods. Let's take a look at an example in which two temporal blocks are defined.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"temporal_block_1\nblock_start: 0h\nblock_end: 4h\ntemporal_block_2\nblock_start: 12h\nblock_end: 16h","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"This example will lead to an optimization of the first four hours of the model horizon, and also of hour 12 to 16. By defining exactly the same relationships for the two temporal blocks, an optimization of disconnected periods is achieved for exactly the same model components. This leads to the possibility of implementing the widely used representative days method. If desired, it is possible to choose a different temporal resolution for the different temporal_blocks.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"It is worth noting that dynamic variables like node_state and units_on merit special attention when using disconnected time periods. By default, when trying to access variables Variables outside the defined temporal_blocks, SpineOpt.jl assumes such variables exist but allows them to take any values within specified bounds. If fixed initial conditions for the disconnected periods are desired, one needs to use parameters such as fix_node_state or fix_units_on.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Different-regions/commodities-in-different-resolutions","page":"Temporal Framework","title":"Different regions/commodities in different resolutions","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Multiple temporal blocks can also be used to model different regions or different commodities with a different resolution. This is especially useful when there is a certain region or commodity of interest, while other elements are connected to this but require less detail. For this kind of usage, the relationships that are defined for the temporal blocks will be different, as shown in the example below.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"temporal_blocks\ntemporal_block_1\nresolution: 1h\ntemporal_block_2\nresolution: 2h\nnodes\nnode_1\nnode_2\nnode_temporal_block relationships\nnode_1_temporal_block_1\nnode_2_temporal_block_2","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Similarly, the on- and offline status of a unit can be modeled with a lower resolution than the actual output of that unit, by defining the units_on_temporal_block relationship with a different temporal block than the one used for the node_temporal_block relationship (of the node to which the unit is connected).","category":"page"},{"location":"advanced_concepts/temporal_framework/#Rolling-horizon-with-multiple-blocks","page":"Temporal Framework","title":"Rolling horizon with multiple blocks","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/#Rolling-horizon-with-different-window-sizes","page":"Temporal Framework","title":"Rolling horizon with different window sizes","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Similar to what has been discussed above in Different regions/commodities in different resolutions, different commodities or regions can be modeled with a different resolution in the rolling horizon setting. The way to do it is completely analogous. Furthermore, when using the rolling horizon framework, a different window size can be chosen for the different modeled components, by simply using a different block_end parameter. However, using different block_ends e.g. for interconnected regions should be treated with care, as the variables for each region will only be generated for their respective temporal_block, which in most cases will lead to inconsistent linking constraints.","category":"page"},{"location":"advanced_concepts/temporal_framework/#Putting-it-all-together:-rolling-horizon-with-variable-resolution-that-differs-for-different-model-components","page":"Temporal Framework","title":"Putting it all together: rolling horizon with variable resolution that differs for different model components","text":"","category":"section"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"Below is an example of an advanced use case in which a rolling horizon optimization is used, and different model components are optimized with a different resolution. By choosing the relevant parameters in the following way:","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"model\nroll_forward: 4h\ntemporal_blocks\ntemporal_block_A\nresolution: [1h 1h 2h 2h 2h 3h 3h]\nblock_end: 14h\ntemporal_block_B\nresolution: [2h 2h 4h 6h]\nblock_end: 14h\nnodes\nnode_1\nnode_2\nnode_temporal_block relationships\nnode_1_temporal_block_A\nnode_2_temporal_block_B","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"The two model components that are considered have a different resolution, and their own resolution is also varying within the optimization window. Note that in this case the two optimization windows have the same size, but this is not strictly necessary. The image below visualizes the first two window optimizations of this model.","category":"page"},{"location":"advanced_concepts/temporal_framework/","page":"Temporal Framework","title":"Temporal Framework","text":"(Image: temporal structure)","category":"page"},{"location":"concept_reference/fix_binary_gas_connection_flow/","page":"-","title":"-","text":"The binary flow of a gas pipelines for pressure driven gas transfer is enables through the binary variable binary_gas_connection_flow and the big_m constant. To fix this binary variable, i.e. pre-define the direction of gas through the pipelines, the fix_binary_gas_connection_flow parameter can be used.","category":"page"},{"location":"concept_reference/connection_capacity/","page":"-","title":"-","text":"Defines the upper bound on the corresponding connection_flow variable. If the connection is a candidate connection, the effective connection_flow upper bound is the product of the investment variable, connections_invested_available and connection_capacity. If ptdf based dc load flow is enabled, connection_capacity represents the normal rating of a connection (line) while connection_emergency_capacity represents the maximum post contingency flow.","category":"page"},{"location":"concept_reference/fix_units_invested/","page":"-","title":"-","text":"Used primarily to fix the value of the units_invested variable which represents the point-in-time unit investment decision variable and how many candidate units are invested-in in a particular timeslice.","category":"page"},{"location":"concept_reference/fix_units_invested/","page":"-","title":"-","text":"See also Investment Optimization, candidate_units and unit_investment_variable_type","category":"page"},{"location":"concept_reference/candidate_connections/","page":"-","title":"-","text":"The candidate_connections parameter denotes the possibility of investing on a certain connection.","category":"page"},{"location":"concept_reference/candidate_connections/","page":"-","title":"-","text":"The default value of nothing means that the connection can't be invested in, because it's already in operation. An integer value represents the maximum investment possible at any point in time, as a factor of the connection_capacity.","category":"page"},{"location":"concept_reference/candidate_connections/","page":"-","title":"-","text":"In other words, candidate_connections is the upper bound of the connections_invested_available variable.","category":"page"},{"location":"concept_reference/connection__to_node__unit_constraint/","page":"-","title":"-","text":"connection__to_node__user_constraint is a three-dimensional relationship between a connection, a node and a user_constraint. The relationship specifies that the connection_flow variable from the specified connection to the specified node is involved in the specified user_constraint. Parameters on this relationship generally apply to this specific connection_flow variable. For example the parameter connection_flow_coefficient defined on connection__to_node__user_constraint represents the coefficient on the specific connection_flow variable in the specified user_constraint","category":"page"},{"location":"concept_reference/is_reserve_node/","page":"-","title":"-","text":"By setting the parameter is_reserve_node to true, a node is treated as a reserve node in the model. Units that are linked through a unit__to_node relationship will be able to provide balancing services to the reserve node, but within their technical feasibility. The mathematical formulation holds a chapter on Ramping and reserve constraints and the general concept of setting up a model with reserves is described in Ramping and Reserves.","category":"page"},{"location":"concept_reference/units_on_non_anticipativity_time/","page":"-","title":"-","text":"The units_on_non_anticipativity_time parameter defines the duration, starting from the begining of the optimisation window, where units_on variables need to be fixed to the result of the previous window.","category":"page"},{"location":"concept_reference/units_on_non_anticipativity_time/","page":"-","title":"-","text":"This is intended to model \"slow\" units whose commitment decision needs to be taken in advance, e.g., in \"day-ahead\" mode, and cannot be changed afterwards.","category":"page"},{"location":"mathematical_formulation/objective_function/#Objective-function","page":"Objective","title":"Objective function","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"The objective function of SpineOpt expresses the minimization of the total system costs associated with maintaining and operating the considered energy system.","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n min obj = v_unit_investment_costs + v_connection_investment_costs + v_storage_investment_costs\r\n + v_fixed_om_costs + v_variable_om_costs + v_fuel_costs  +  v_start_up_costs \r\n + v_shut_down_costs + v_ramp_costs + v_res_proc_costs \r\n + v_renewable_curtailment_costs + v_connection_flow_costs +  v_taxes +\r\nv_objective_penalties\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"Note that each cost term is reflected here as a separate variable that can be expressed mathematically by the equations below. All cost terms are weighted by the associated scenario and temporal block weights. To enhance readability and avoid writing a product of weights in every cost term, all weights are combined in a single weight parameter p_weight(). As such, the indices associated with each weight parameter indicate which weights are included.","category":"page"},{"location":"mathematical_formulation/objective_function/#Unit-investment-costs","page":"Objective","title":"Unit investment costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"To take into account unit investments in the objective function, the parameter unit_investment_cost can be defined. For all tuples of (unit, scenario, timestep) in the set units_invested_available_indices for which this parameter is defined, an investment cost term is added to the objective function if a unit is invested in during the current optimization window. The total unit investment costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_unit_investment_costs \r\n = sum_substack(ust) in units_invested_available_indices\r\n      u in ind(p_unit_investment_cost)\r\n    v_units_invested(u s t) cdot p_unit_investment_cost(ust) cdot p_weight(ust)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Connection-investment-costs","page":"Objective","title":"Connection investment costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"To take into account connection investments in the objective function, the parameter connection_investment_cost can be defined. For all tuples of (connection, scenario, timestep) in the set connections_invested_available_indices for which this parameter is defined, an investment cost term is added to the objective function if a connection is invested in during the current optimization window. The total connection investment costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_connection_investment_costs \r\n = sum_substack(connst) in connections_invested_available_indices  conn in ind(p_connection_investment_cost)\r\n v_connections_invested(conn s t) cdot p_connection_investment_cost(connst) cdot p_weight(connst) \r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Storage-investment-costs","page":"Objective","title":"Storage investment costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"To take into account storage investments in the objective function, the parameter storage_investment_cost can be defined. For all tuples of (node, scenario, timestep) in the set storages_invested_available_indices for which this parameter is defined, an investment cost term is added to the objective function if a node storage is invested in during the current optimization window. The total storage investment costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_storage_investment_costs \r\n = sum_substack(nst) in storages_invested_available_indices n in ind(p_storage_investment_cost)\r\n v_storages_invested(n s t) cdot p_storage_investment_cost(nst) cdot p_weight(nst) \r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Fixed-O-and-M-costs","page":"Objective","title":"Fixed O&M costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"Fixed operation and maintenance costs associated with a specific unit can be accounted for by defining the parameters fom_cost and unit_capacity. For all tuples of (unit, {node,node_group}, direction) for which these parameters are defined, and for which tuples (unit, scenario, timestep) exist in the set units_on_indices, a fixed O&M cost term is added to the objective function. Note that, as the units_on_indices are used to retrieve the relevant time slices, the unit of the fom_cost parameter should be given per resolution of the units_on. The total fixed O&M costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_fixed_om_costs \r\n = sum_substack(und) in ind(p_unit_capacity) u in ind(p_fom_cost)\r\nsum_substack(ust)  in  units_on_indices\r\n p_unit_capacity(undst) cdot p_number_of_units(ust)cdot\r\n p_fom_cost(ust)cdot p_weight(t) cdot\r\n p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Variable-O-and-M-costs","page":"Objective","title":"Variable O&M costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"Variable operation and maintenance costs associated with a specific unit can be accounted for by defining the parameter (vom_cost). For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set unit_flow_indices for which this parameter is defined, a variable O&M cost term is added to the objective function. As the parameter vom_cost is a dynamic parameter, the cost term is multiplied with the duration of each timestep. The total variable O&M costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_variable_om_costs \r\n = sum_substack(undst) in unit_flow_indices (und) in ind(p_vom_cost)\r\n v_unit_flow(u n d s t) cdot  p_vom_cost(undst) cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Fuel-costs","page":"Objective","title":"Fuel costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"Fuel costs associated with a specific unit can be accounted for by defining the parameter fuel_cost. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set unit_flow_indices for which this parameter is defined, a fuel cost term is added to the objective function. As the parameter fuel_cost is a dynamic parameter, the cost term is multiplied with the duration of each timestep. The total fuel costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_fuel_costs \r\n = sum_substack(undst) in unit_flow_indices (und) in ind(p_fuel_cost)\r\n v_unit_flow(u n d s t) cdot  p_fuel_cost(undst) cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Connection-flow-costs","page":"Objective","title":"Connection flow costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"To account for operational costs associated with flows over a specific connection, the connection_flow_cost parameter can be defined. For all tuples of (conn, {node,node_group}, direction, scenario, timestep) in the set connection_flow_indices for which this parameter is defined, a connection flow cost term is added to the objective function. The total connection flow costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_connection_flow_costs \r\n = sum_substack(connndst) in connection_flow_indices  conn in ind(p_connection_flow_cost)\r\nv_connection_flow (conn n d s t) cdot  p_connection_flow_cost(connst) cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Start-up-costs","page":"Objective","title":"Start up costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"Start up costs associated with a specific unit can be included by defining the start_up_cost parameter. For all tuples of (unit, scenario, timestep) in the set units_on_indices for which this parameter is defined, a start up cost term is added to the objective function. The total start up costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_start_up_costs \r\n = sum_substack(ust) in units_on_indices u in ind(p_start_up_cost)\r\n v_units_started_up(u s t) cdot p_start_up_cost(ust)cdot p_weight(ust)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Shut-down-costs","page":"Objective","title":"Shut down costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"Shut down costs associated with a specific unit can be included by defining the shut_down_cost parameter. For all tuples of (unit, scenario, timestep) in the set units_on_indices for which this parameter is defined, a shut down cost term is added to the objective function. The total shut down costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_shut_down_costs \r\n = sum_substack(ust) in units_on_indices u in ind(p_shut_down_cost)\r\nv_units_shut_down(ust) cdot p_start_up_cost(ust)cdot p_weight(ust)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Ramping-costs","page":"Objective","title":"Ramping costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"To account for the ramping costs (up and down) associated with a specific unit, the parameters ramp_up_cost and ramp_down_cost can be defined. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the sets ramp_up_unit_flow_indices and ramp_down_unit_flow_indices for which ramp_up_cost and ramp_down_cost are  defined, respectively, a ramping cost term is added to the objective function. The total ramping costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_ramp_costs \r\n = sum_substack(undst) in ramp_up_unit_flow_indices  (und) in ind(p_ramp_up_cost)\r\nv_ramp_up_unit_flow(u n d s t)cdot p_ramp_up_cost(undst)cdot p_weight(nst)cdot p_duration(t)\r\n  + sum_substack(undst) in ramp_down_unit_flow_indices  (und) in ind(p_ramp_down_cost)\r\n  v_ramp_down_unit_flow(u n d s t) cdot p_ramp_down_cost(undst)cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Reserve-procurement-costs","page":"Objective","title":"Reserve procurement costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"The procurement costs for reserves provided by a specific unit can be accounted for by defining the reserve_procurement_cost parameter. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set unit_flow_indices for which this parameter is defined, a reserve procurement cost term is added to the objective function. The total reserve procurement costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_res_proc_costs \r\n = sum_substack(undst) in unit_flow_indices  (und) in ind(p_reserve_procurement_cost)\r\nv_unit_flow(u n d s t) cdot p_reserve_procurement_cost(undst) cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Renewable-curtailment-costs","page":"Objective","title":"Renewable curtailment costs","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"The curtailment costs of renewable units can be accounted for by defining the parameters curtailment_cost and unit_capacity. For all tuples of (unit,  {node,node_group}, direction) for which these parameters are defined, and for which tuples (unit, scenario, timestep_long) exist in the set units_on_indices, and for which tuples (unit, {node,node_group}, direction, scenario, timestep_short) exist in the set unit_flow_indices, a renewable curtailment cost term is added to the objective function. The total renewable curtailment costs can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_renewable_curtailment_costs \r\n = sum_substack(und) in ind(p_unit_capacity)  u in ind(p_curtailment_cost)\r\nsum_substack(ust_long) in units_on_indices\r\nsum_substack(unst_short) in unit_flow_indices \r\n (  v_units_available(u s t_long)cdot p_unit_capacity(undst_short) cdot  p_unit_conv_cap_to_flow(undst_short) \r\n - v_unit_flow(u n d s t_short) ) \r\n cdot  p_curtailment_cost(ust_short) cdot p_weight(nst_short) cdot p_duration(t_short)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Taxes","page":"Objective","title":"Taxes","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"To account for taxes on certain commodity flows, the tax unit flow parameters (i.e., tax_net_unit_flow, tax_out_unit_flow and tax_in_unit_flow) can be defined. For all tuples of (unit, {node,node_group}, direction, scenario, timestep) in the set unit_flow_indices for which these parameters are defined, a tax term is added to the objective function. The total taxes can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_taxes \r\n = sum_substack(undst) in unit_flow_indices n in ind(p_tax_net_unit_flow)  d=  to_node\r\nv_unit_flow(u n d s t)cdot p_tax_net_unit_flow(nst)cdot p_weight(nst) cdot p_duration(t)\r\n - sum_substack(undst) in unit_flow_indices n in ind(p_tax_net_unit_flow)  d=  from_node\r\nv_unit_flow(u n d s t)cdot p_tax_net_unit_flow(nst)cdot p_weight(nst)cdot p_duration(t)\r\n  + sum_substack(undst) in unit_flow_indices n in ind(p_tax_out_unit_flow)  d=  from_node\r\n v_unit_flow(u n d s t)cdot p_tax_out_unit_flow(nst)cdot p_weight(nst) cdot p_duration(t)\r\n  + sum_substack(undst) in unit_flow_indices n in ind(p_tax_in_unit_flow)  d=  to_node\r\n v_unit_flow(u n d s t)cdot p_tax_in_unit_flow(nst)cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"mathematical_formulation/objective_function/#Objective-penalties","page":"Objective","title":"Objective penalties","text":"","category":"section"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"Penalty cost terms associated with the slack variables of a specific constraint can be accounted for by defining a node_slack_penalty parameter. For all tuples of ({node,node_group}, scenario, timestep) in the set node_slack_indices for which this parameter is defined, a penalty term is added to the objective function. The total objective penalties can be expressed as:","category":"page"},{"location":"mathematical_formulation/objective_function/","page":"Objective","title":"Objective","text":"beginaligned\r\n v_objective_penalties \r\n = sum_substack(ust) in node_slack_indices\r\nleftv_node_slack_neg(n s t)-v_node_slack_pos(n s t) rightcdot p_node_slack_penalty(nst)cdot p_weight(nst) cdot p_duration(t)\r\nendaligned","category":"page"},{"location":"concept_reference/cyclic_condition/","page":"-","title":"-","text":"The cyclic_condition parameter is used to enforce that the storage level at the end of the optimization window is higher or equal to the storage level at the beginning optimization. If the cyclic_condition parameter is set to true for a node__temporal_block relationship, and the has_state parameter of the corrresponding node is set to true, the constraint_cyclic_node_state will be triggered.","category":"page"},{"location":"concept_reference/node__investment_temporal_block/","page":"-","title":"-","text":"node__investment_temporal_block is a two-dimensional relationship between a node and a temporal_block. This relationship defines the temporal resolution and scope of a node's investment decisions (currently only storage invesments). Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__default_investment_temporal_block is specified and no node__investment_temporal_block relationship is specified, the model__default_investment_temporal_block relationship will be used. Conversely if node__investment_temporal_block is specified along with model__temporal_block, this will override model__default_investment_temporal_block for the specified node.","category":"page"},{"location":"concept_reference/node__investment_temporal_block/","page":"-","title":"-","text":"See also Investment Optimization","category":"page"},{"location":"advanced_concepts/investment_optimization/#Investment-Optimization","page":"Investment Optimization","title":"Investment Optimization","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"SpineOpt offers numerous ways to optimise investment decisions energy system models and in particular, offers a number of methologogies for capturing increased detail in investment models while containing the impact on run time. The basic principles of investments will be discussed first and this will be followed by more advanced approaches.","category":"page"},{"location":"advanced_concepts/investment_optimization/#Key-concepts-for-investments","page":"Investment Optimization","title":"Key concepts for investments","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Investment Decisions   These are the investment decisions that SpineOpt currently supports. At a high level, this means that the activity of the entities in question is controlled by an investment decision variable. The current implementation supports investments in :","category":"page"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"unit:\nconnection\nStorage - Note: while the above investment decisions correspond to an object class (i.e.) an investment in a unit or a connection, Storages are not an object class in themselves and are rather a property of a node. As such, a storage investment controls whether a particular node has a state variable or not.  ","category":"page"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Investment Variable Types   In all cases the capacity of the unit or connection or the maximum node state of a node is multuplied by the investment variable which may either be continuous, binary or integer. This is determined, for units, by setting the unit_investment_variable_type parameter accordingly. Similary, for connections and node storages where the connection_investment_variable_type and storage_investment_variable_type are specified.","category":"page"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Identiying Investment Candidate Units, Connections and Storages   The parameter candidate_units represents the number of units of this type that may be invested-in. candidate_units determines the upper bound of the investment variable and setting this to a value greater than 0 identifies the unit as an investment candidate unit in the optimisation. If the unit_investment_variable_type is set to :variable_type_integer, the investment variable can be interpreted as the number of discrete units that may be invested in. However, if unit_investment_variable_type is :variable_type_continuous and the unit_capacity is set to unity, the investment decision variable can then be intpreted as the capacity of the unit rather than the number of units with candidate_units being the maximum capacity that can be invested in. Finally, we can invest in discrete blocks of capacity by setting unit_capacity to the size of the investment capacity blocks and have unit_investment_variable_type set to :variable_type_integer with candidate_units representing the maximum number of capacity blocks that may be invested in. The key points here are:","category":"page"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"The upper bound on the relevant flow variables are determined by the product of the investment variable and the unit_capacity or connection_capacity for connections or node_state_cap for storages.\ncandidate_units sets the upper bound on the investment variable, candidate_connections for connections and candidate_storages for storages\nunit_investment_variable_type determines wheter the investment variable is integer, binary or continuous (connection_investment_variable_type for connections and storage_investment_variable_type for storages).","category":"page"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Investment Costs   Investment costs are specified by setting the appropriate *_investment\\_cost parameter. The investment cost for units are specified by setting the unit unit_investment_cost parameter. This is currently interpreted as the full cost over the investment period for the unit. See the section below on investment temporal structure for setting the investment period. If the investment period is 1 year, then the corresponding unit_investment_cost is the annualised investment cost. For connections and storages, the investment cost parameters are connection_investment_cost and storage_investment_cost, respectively.","category":"page"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Temporal and Stochastic Structure of Investment Decisions   SpineOpt's flexible stochastic and temporal structure extend to investments where individual investment decisions can have their own temporal and stochastic structure indepedent of other investment decisions and other model variables. A global temporal resolution for all investment decisions can be defined by specifying the relationship model__default_investment_temporal_block. If a specific temporal resolution is required for specific investment decisions, then one can specify the following relationships:     - unit__investment_temporal_block for unit     - connection__investment_temporal_block for connection     - node__investment_temporal_block for storages.   Specifying any of the above relationships will override the corresponding model__default_investment_temporal_block.","category":"page"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Similarly, a global stochastic structure can be defined for all investment decisions by specifying the relationship model__default_investment_stochastic_structure. If a specific stochastic structure is required for specific investment decisions, then one can specifying the following relationships:     - unit__investment_stochastic_structure for unit     - connection__investment_stochastic_structure for connection     - node__investment_stochastic_structure for storages Specifying any of the above relationships will override the corresponding model__default_investment_stochastic_structure.","category":"page"},{"location":"advanced_concepts/investment_optimization/#Creating-an-Investment-Candidate-Unit-Example","page":"Investment Optimization","title":"Creating an Investment Candidate Unit Example","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"If we have model that is not currently set up for investments and we wish to create an investment candidate unit, we can take the following steps.","category":"page"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Create the unit object with all the relationships and parameters necessary to describe its function.\nEnsure that the number_of_units parameter is set to zero so that the unit is unavailable unless invested-in\nSet the candidate_units parameter for the unit to 1 to specify that a maximum of 1 new unit of this type may be invested-in by the model.\nSet the unit_investment_variable_type to unit_investment_variable_type_integer to specify that this is a discrete unit investment decision.\nSpecify the unit_investment_lifetime of the unit to, say, 1 year to specify that this is the minimum amount of time this new unit must be in existence after being invested-in.\nSpecify the investment period for this unit's investment decision in one of two ways\nDefine a default investment period for all investment decisions in the model as follows:\ncreate a temporal_block with the appropriate resolution (say 1 year)\nlink this to your [model]{@ref} object by creating the appropriate model__temporal_block relationship\nset it as the default investment temporal block by setting model__default_investment_temporal_block\nOr, define an investment period unique to this investment decision as follows:\ncreating a temporal_block with the appropriate resolution (say 1 year)\nlink this to your model object by creating the appropriate model__temporal_block relationship\nspecify this as the investment period for your unit's investment decision by setting the appropriate unit__investment_temporal_block relationship\nSimilarly to the above, define the stochastic structure for the unit's investment decision by specifying either model__default_investment_stochastic_structure or unit__investment_stochastic_structure\nSpecifying your unit's investment cost by setting the unit_investment_cost parameter. Since we have defined the investment period above as 1 year, this is therefore the unit's annualised investment cost.","category":"page"},{"location":"advanced_concepts/investment_optimization/#Model-Reference","page":"Investment Optimization","title":"Model Reference","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/#Variables-for-investments","page":"Investment Optimization","title":"Variables for investments","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Variable Name Indices Description\nunits_invested_available unit, s, t The number of invested in units that are available at a given (s, t)\nunits_invested unit, s, t The point-in-time investment decision corresponding to the number of units invested in at (s,t)\nunits_mothballed unit, s, t \"Instantaneous\" decision variable to mothball a unit\nconnections_invested_available connection, s, t The number of invested-in connectionss that are available at a given (s, t)\nconnections_invested connection, s, t The point-in-time investment decision corresponding to the number of connectionss invested in at (s,t)\nconnections_decommissioned connection, s, t \"Instantaneous\" decision variable to decommission a connection\nstorages_invested_available node, s, t The number of invested-in storages that are available at a given (s, t)\nstorages_invested node, s, t The point-in-time investment decision corresponding to the number of storages invested in at (s,t)\nstorages_decommissioned node, s, t \"instantaneous\" decision variable to decommission a storage","category":"page"},{"location":"advanced_concepts/investment_optimization/#Relationships-for-investments","page":"Investment Optimization","title":"Relationships for investments","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Relationship Name Related Object Class List Description\nmodel__default_investment_temporal_block model, temporal_block Default temporal resolution for investment decisions effective if unit__investmenttemporalblock is not specified\nmodel__default_investment_stochastic_structure model, stochastic_structure Default stochastic structure for investment decisions effective if unit__investmentstochasticstructure is not specified\nunit__investment_temporal_block unit, temporal_block Set temporal resolution of investment decisions - overrides model__defaultinvestmenttemporal_block\nunit__investment_stochastic_structure unit, stochastic_structure Set stochastic structure for investment decisions - overrides model__defaultinvestmentstochastic_structure","category":"page"},{"location":"advanced_concepts/investment_optimization/#Parameters-for-investments","page":"Investment Optimization","title":"Parameters for investments","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Parameter Name Object Class List Description\ncandidate_units unit The number of additional units of this type that can be invested in\nunit_investment_cost unit The total overnight investment cost per candidate unit over the model horizon\nunit_investment_lifetime unit The investment lifetime of the unit - once invested-in, a unit must exist for at least this amount of time\nunit_investment_variable_type unit Whether the units_invested_available variable is continuous, integer or binary\nfix_units_invested unit Fix the value of units_invested\nfix_units_invested_available unit Fix the value of connections_invested_available\ncandidate_connections connection The number of additional connections of this type that can be invested in\nconnection_investment_cost connection The total overnight investment cost per candidate connection over the model horizon\nconnection_investment_lifetime connection The investment lifetime of the connection - once invested-in, a connection must exist for at least this amount of time\nconnection_investment_variable_type connection Whether the connections_invested_available variable is continuous, integer or binary\nfix_connections_invested connection Fix the value of connections_invested\nfix_connections_invested_available connection Fix the value of connection_invested_available\ncandidate_storages node The number of additional storages of this type that can be invested in at node\nstorage_investment_cost node The total overnight investment cost per candidate storage over the model horizon\nstorage_investment_lifetime node The investment lifetime of the storage - once invested-in, a storage must exist for at least this amount of time\nstorage_investment_variable_type node Whether the storages_invested_available variable is continuous, integer or binary\nfix_storages_invested node Fix the value of storages_invested\nfix_storages_invested_available node Fix the value of storages_invested_available","category":"page"},{"location":"advanced_concepts/investment_optimization/#Related-Model-Files","page":"Investment Optimization","title":"Related Model Files","text":"","category":"section"},{"location":"advanced_concepts/investment_optimization/","page":"Investment Optimization","title":"Investment Optimization","text":"Filename Relative Path Description\nconstraintunitsinvested_available.jl \\constraints constrains units_invested_available to be less than candidate_units\nconstraintunitsinvested_transition.jl \\constraints defines the relationship between units_invested_available, units_invested and units_mothballed. Analagous to units_on, units_started and units_shutdown\nconstraintunitlifetime.jl \\constraints once a unit is invested-in, it must remain in existence for at least unit_investment_lifetime - analagous to min_up_time.\nconstraintunitsavailable.jl \\constraints Enforces units_available is the sum of number_of_units and units_invested_available\nconstraintconnectionsinvested_available.jl \\constraints constrains connections_invested_available to be less than candidate_connections\nconstraintconnectionsinvested_transition.jl \\constraints defines the relationship between connections_invested_available, connections_invested and connections_decommissioned. Analagous to units_on, units_started and units_shutdown\nconstraintconnectionlifetime.jl \\constraints once a connection is invested-in, it must remain in existence for at least connection_investment_lifetime - analagous to min_up_time.\nconstraintstoragesinvested_available.jl \\constraints constrains storages_invested_available to be less than candidate_storages\nconstraintstoragesinvested_transition.jl \\constraints defines the relationship between storages_invested_available, storages_invested and storages_decommissioned. Analagous to units_on, units_started and units_shutdown\nconstraintstoragelifetime.jl \\constraints once a storage is invested-in, it must remain in existence for at least storage_investment_lifetime - analagous to min_up_time.","category":"page"},{"location":"concept_reference/max_startup_ramp/","page":"-","title":"-","text":"The definition of the max_startup_ramp parameter will trigger the creation of the Constraint on upward start up ramp_up. It sets an upper bound on the unit_flow variable for the timestep right after a startup.","category":"page"},{"location":"concept_reference/max_startup_ramp/","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/commodity_ptdf_threshold/","page":"-","title":"-","text":"Given a connection and a node, the power transfer distribution factor (PTDF) is the fraction of the flow injected into the node that will flow on the connection. commodity_ptdf_threshold is the minimum absolute value of the PTDF that is considered meaningful. Any value below this threshold (in absolute value) will be treated as zero.","category":"page"},{"location":"concept_reference/commodity_ptdf_threshold/","page":"-","title":"-","text":"The PTDFs are used to model DC power flow on certain connections. To model DC power flow on a connection, set connection_monitored to true.","category":"page"},{"location":"concept_reference/commodity_ptdf_threshold/","page":"-","title":"-","text":"In addition, define a commodity with commodity_physics set to either commodity_physics_ptdf, or commodity_physics_lodf. and associate that commodity (via node__commodity) to both connections' nodes (given by connection__to_node and connection__from_node).","category":"page"},{"location":"concept_reference/node__node/","page":"-","title":"-","text":"The node__node relationship is used for defining direct interactions between two nodes, like diffusion of commodity content. Note that the node__node relationship is assumed to be one-directional, meaning that","category":"page"},{"location":"concept_reference/node__node/","page":"-","title":"-","text":"node__node(node1=n1, node2=n2) != node__node(node1=n2, node2=n1).","category":"page"},{"location":"concept_reference/node__node/","page":"-","title":"-","text":"Thus, when one wants to define symmetric relationships between two nodes, one needs to define both directions as separate relationships.","category":"page"},{"location":"concept_reference/model_type_list/","page":"-","title":"-","text":"model_type_list holds the possible values for the model parameter model_type parameter. See model_type for more details","category":"page"},{"location":"concept_reference/ramp_up_limit/","page":"-","title":"-","text":"The definition of the ramp_up_limit parameter will trigger the creation of the Constraint on spinning upwards ramp_up. It limits the maximum increase in the unit_flow variable between two consecutive timesteps for which the unit is online.","category":"page"},{"location":"concept_reference/ramp_up_limit/","page":"-","title":"-","text":"It can be defined for unit__to_node or unit__from_node relationships, as well as their counterparts for node groups. It will then impose restrictions on the unit_flow variables that indicate flows between the two members of the relationship for which the parameter is defined. The parameter is given as a fraction of the unit_capacity parameter. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 1.","category":"page"},{"location":"concept_reference/ramp_up_limit/","page":"-","title":"-","text":"For a more complete description of how ramping restrictions can be implemented, see Ramping and Reserves.","category":"page"},{"location":"concept_reference/fix_units_invested_available/","page":"-","title":"-","text":"Used primarily to fix the value of the units_invested_available variable which represents the unit investment decision variable and how many candidate units are invested-in and available at the corresponding node, time step and stochastic scenario. Used also in the decomposition framework to communicate the value of the master problem solution variables to the operational sub-problem.","category":"page"},{"location":"concept_reference/fix_units_invested_available/","page":"-","title":"-","text":"See also Investment Optimization, candidate_units and unit_investment_variable_type","category":"page"},{"location":"concept_reference/node__unit_constraint/","page":"-","title":"-","text":"node__user_constraint is a two-dimensional relationship between a node and a user_constraint. The relationship specifies that a variable associated only with the node (currently only the node_state) is involved in the constraint. For example, the node_state_coefficient defined on node__user_constraint specifies the coefficient of the node's node_state variable in the specified user_constraint.","category":"page"},{"location":"concept_reference/node__unit_constraint/","page":"-","title":"-","text":"See also user_constraint","category":"page"},{"location":"concept_reference/state_coeff/","page":"-","title":"-","text":"The state_coeff parameter acts as a coefficient for the node_state variable in the node injection constraint. Essentially, it tells how the node_state variable should be treated in relation to the commodity flows and demand, and can be used for e.g. scaling or unit conversions. For most use-cases a state_coeff parameter value of 1.0 should suffice, e.g. having a MWh storage connected to MW flows in a model with hour as the basic unit of time.","category":"page"},{"location":"concept_reference/state_coeff/","page":"-","title":"-","text":"Note that in order for the state_coeff parameter to have an impact, the node must first have a node_state variable to begin with, defined using the has_state parameter. By default, the state_coeff is set to zero as a precaution, so that the user always has to set its value explicitly for it to have an impact on the model.","category":"page"},{"location":"concept_reference/commodity/","page":"-","title":"-","text":"Commodities correspond to the type of energy traded. When associated with a node through the node__commodity relationship, a specific form of energy, i.e. commodity, can be associated with a specific location. Furthermore, by linking commodities with units, it is possible to track the flows of a certain commodity and impose limitations on the use of a certain commodity (See also max_cum_in_unit_flow_bound). For the representation of specific commodity physics, related to e.g. the representation of the electric network, designated parameters can be defined to enforce commodity specific behaviour. (See also commodity_physics)","category":"page"},{"location":"concept_reference/demand_coefficient/","page":"-","title":"-","text":"The demand_coefficient is an optional parameter that can be used to include the demand of the a node in a user_constraint via the node__user_constraint relationship. Essentially, demand_coefficient appears as a coefficient for the demand parameter of the connected node in the user constraint.","category":"page"},{"location":"concept_reference/min_voltage_angle/","page":"-","title":"-","text":"If a node has a node_voltage_angle variable (see also the parameter has_voltage_angle and this chapter), a lower bound on the pressure can be introduced through the min_voltage_angle parameter, which triggers the generation of the minimum node voltage angle constraint.","category":"page"},{"location":"concept_reference/fix_storages_invested_available/","page":"-","title":"-","text":"Used primarily to fix the value of the storages_invested_available variable which represents the storages investment decision variable and how many candidate storages are available at the corresponding node, time step and stochastic scenario. Used also in the decomposition framework to communicate the value of the master problem solution variables to the operational sub-problem.","category":"page"},{"location":"concept_reference/fix_storages_invested_available/","page":"-","title":"-","text":"See also candidate_storages and Investment Optimization","category":"page"},{"location":"concept_reference/connection_availability_factor/","page":"-","title":"-","text":"To indicate that a connection is only available to a certain extent or at certain times of the optimization, the connection_availability_factor can be used. A typical use case could be an availability timeseries for connection with expected outage times. By default the availability factor is set to 1. The availability is, among others, used in the constraint_connection_flow_capacity.","category":"page"},{"location":"concept_reference/connection__from_node/","page":"-","title":"-","text":"connection__from_node is a two-dimensional relationship between a connection and a node and implies a connection_flow to the connection from the node. Specifying such a relationship will give rise to a connection_flow_variable with indices connection=connection, node=node, direction=:from_node. Relationships defined on this relationship will generally apply to this specific flow variable. For example, connection_capacity will apply only to this specific flow variable, unless the connection parameter connection_type is specified.","category":"page"},{"location":"concept_reference/fix_nonspin_ramp_up_unit_flow/","page":"-","title":"-","text":"The fix_nonspin_ramp_up_unit_flow parameter simply fixes the value of the nonspin_ramp_up_unit_flow variable to the provided value. As such, it determines directly how much non-spinning upward reserve commodity flows the relevant unit is providing to the node to which it is linked by the unit__to_node relationship.","category":"page"},{"location":"concept_reference/fix_nonspin_ramp_up_unit_flow/","page":"-","title":"-","text":"When a single value is selected, this value is kept constant throughout the model. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/duration_unit_list/","page":"-","title":"-","text":"The duration_unit_list parameter value list contains the possible values for the duration_unit parameter.","category":"page"},{"location":"concept_reference/commodity_physics_list/","page":"-","title":"-","text":"commodity_physics_list holds the possible values for the commodity parameter commodity_physics parameter. See commodity_physics for more details","category":"page"},{"location":"concept_reference/connection_investment_variable_type/","page":"-","title":"-","text":"The connection_investment_variable_type parameter represents the type of the connections_invested_available decision variable.","category":"page"},{"location":"concept_reference/connection_investment_variable_type/","page":"-","title":"-","text":"The default value, variable_type_integer, means that only integer factors of the connection_capacity can be invested in. The value variable_type_continuous means that any fractional factor can also be invested in. The value variable_type_binary means that only a factor of 1 or zero are possible.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_in_in/","page":"-","title":"-","text":"The fix_units_on_coefficient_in_in parameter is an optional coefficient in the unit input-input ratio constraint controlled by the fix_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_in_in/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_out, fix_units_on_coefficient_out_in, and fix_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g. min_units_on_coefficient_in_in and max_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/block_end/","page":"-","title":"-","text":"Indicates the end of this temporal block. The default value is equal to a duration of 0. It is useful to distinguish here between two cases: a single solve, or a rolling window optimization.","category":"page"},{"location":"concept_reference/block_end/","page":"-","title":"-","text":"single solve When a Date time value is chosen, this is directly the end of the optimization for this temporal block. In a single solve optimization, a combination of block_start and block_end can easily be used to run optimizations that cover only part of the model horizon. Multiple temporal_block objects can then be used to create optimizations for disconnected time periods, which is commonly used in the method of representative days. The default value coincides with the model_end.","category":"page"},{"location":"concept_reference/block_end/","page":"-","title":"-","text":"rolling window optimization To create a temporal block that is rolling along with the optimization window, a rolling temporal block, a duration value should be chosen. The block_end parameter will in this case determine the size of the optimization window, with respect to the start of each optimization window. If multiple temporal blocks with different block_end parameters exist, the maximum value will determine the size of the optimization window. Note, this is different from the roll_forward parameter, which determines how much the window moves for after each optimization. For more info, see One single temporal_block. The default value is equal to the roll_forward parameter.","category":"page"},{"location":"concept_reference/model_end/","page":"-","title":"-","text":"Together with the model_start parameter, it is used to define the temporal horizon of the model. In case of a single solve optimization, the parameter marks the end of the last timestep that is possibly part of the optimization. Note that it poses an upper bound, and that the optimization does not necessarily include this timestamp when the block_end parameters are more stringent.","category":"page"},{"location":"concept_reference/model_end/","page":"-","title":"-","text":"In case of a rolling horizon optimization, it will tell to the model to stop rolling forward once an optimization has been performed for which the result of the indicated timestamp has been kept in the final results. For example, assume that a model_end value of 2030-01-01T05:00:00 has been chosen, a block_end of 3h, and a roll_forward of 2h. The roll_forward parameter indicates here that the results of the first two hours of each optimization window are kept as final, therefore the last optimization window will span the timeframe [2030-01-01T04:00:00 - 2030-01-01T06:00:00].","category":"page"},{"location":"concept_reference/model_end/","page":"-","title":"-","text":"A DateTime value should be chosen for this parameter. ","category":"page"},{"location":"concept_reference/model__report/","page":"-","title":"-","text":"The model__report relationship tells which reports are written by which model, where the contents of the reports are defined separately using the report__output relationship. Without appropriately defined model__report and report__output and relationships, SpineOpt doesn't write any output, so be sure to include at least one report connected to all the output variables of interest in the model!","category":"page"},{"location":"concept_reference/min_down_time/","page":"-","title":"-","text":"The definition of the min_down_time parameter will trigger the creation of the Constraint on minimum down time. It sets a lower bound on the period that a unit has to stay offline after a shutdown.","category":"page"},{"location":"concept_reference/min_down_time/","page":"-","title":"-","text":"It can be defined for a unit and will then impose restrictions on the units_on variables that represent the on- or offline status of the unit. The parameter is given as a duration value. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/min_down_time/","page":"-","title":"-","text":"For a more complete description of unit commmitment restrictions, see Unit commitment.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_out_in/","page":"-","title":"-","text":"The max_units_on_coefficient_out_in parameter is an optional coefficient in the unit output-input ratio constraint controlled by the max_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_out_in/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow being constrained: max_units_on_coefficient_in_in, max_units_on_coefficient_in_out, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g. min_units_on_coefficient_out_in and fix_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/fix_node_voltage_angle/","page":"-","title":"-","text":"For a lossless nodal DC power flow network, each node is associated with a node_voltage_angle variable. In order to fix the voltage angle at a certain node or to give initial conditions the fix_node_voltage_angle parameter can be used.","category":"page"},{"location":"concept_reference/overwrite_results_on_rolling/","page":"-","title":"-","text":"The overwrite_results_on_rolling allows one to define whether or not results from further optimisation windows should overwrite those from previous ones. This, of course, is relevant only if optimisation windows overlap, which in turn happens whenever there is a temporal_block that goes beyond the length of the window.","category":"page"},{"location":"concept_reference/overwrite_results_on_rolling/","page":"-","title":"-","text":"If true (the default) then results are written as a time-series. If false, then results are written as a map from analysis time (i.e., the window start) to time-series.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_out_out/","page":"-","title":"-","text":"The fix_units_on_coefficient_out_out parameter is an optional coefficient in the unit output-output ratio constraint controlled by the fix_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for fixing the conversion ratio depending on the amount of online capacity.","category":"page"},{"location":"concept_reference/fix_units_on_coefficient_out_out/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, and fix_units_on_coefficient_out_in, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or maximum conversion rates, e.g.  min_units_on_coefficient_out_out and max_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/node_state_min/","page":"-","title":"-","text":"The node_state_min parameter sets the lower bound for the node_state variable, if one has been enabled by the has_state parameter. For reserve nodes with minimum_reserve_activation_time, the node_state_min is considered also via a special constraint.","category":"page"},{"location":"concept_reference/min_res_shutdown_ramp/","page":"-","title":"-","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning downward reserves are provided by contracted units holding available to shutdown to a downward_reserve node. If a unit is scheduled to provide nonspinning reserve, a limit on the minimum amount of reserves provided can be imposed by defining the parameter min_res_shutdown_ramp on a unit__to_node relationship, which triggers the constraint on minimum downward nonspinning reserve provision. The parameter min_res_shutdown_ramp is given as a fraction of the unit_capacity of the corresponding unit__to_node relationship.","category":"page"},{"location":"concept_reference/min_res_shutdown_ramp/","page":"-","title":"-","text":"Note that to include the provision of nonspinning downward reserves, the parameter max_res_shutdown_ramp needs to be defined on the corresponding unit__to_node relationship, which triggers the generation of the variables nonspin_units_shut_down and nonspin_ramp_down_unit_flow.","category":"page"},{"location":"concept_reference/min_res_shutdown_ramp/","page":"-","title":"-","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/node_slack_penalty/","page":"-","title":"-","text":"node_slack_penalty triggers the creation of node slack variables, node_slack_pos and node_slack_neg. This allows the model to violate the node_balance constraint with these violations penalised in the objective function with a coefficient equal to node_slack_penalty. If node_slack_penalty = 0 the slack variables are created and violations are unpenalised. If set to none or undefined, the variables are not created and violation of the node_balance constraint is  not possible.","category":"page"},{"location":"concept_reference/downward_reserve/","page":"-","title":"-","text":"If a node has a true is_reserve_node parameter, it will be treated as a reserve node in the model. To define whether the node corresponds to an upward or downward reserve commodity, the upward_reserve or the downward_reserve parameter needs to be set to true, respectively.","category":"page"},{"location":"concept_reference/node_opf_type/","page":"-","title":"-","text":"Used to identify the reference node (or slack bus) when ptdf based dc load flow is enabled (commodity_physics set to commodity_physics_ptdf or commodity_physics_lodf. To identify the reference node, set node_opf_type = :node_opf_type_reference","category":"page"},{"location":"concept_reference/node_opf_type/","page":"-","title":"-","text":"See also powerflow.","category":"page"},{"location":"concept_reference/balance_type/","page":"-","title":"-","text":"The balance_type parameter determines whether or not a node needs to be balanced, in the classical sense that the sum of flows entering the node is equal to the sum of flows leaving it.","category":"page"},{"location":"concept_reference/balance_type/","page":"-","title":"-","text":"The values balance_type_node (the default) and balance_type_group mean that the node is always balanced. The only exception is if the node belongs in a group that has itself balance_type equal to balance_type_group. The value balance_type_none means that the node doesn't need to be balanced.","category":"page"},{"location":"advanced_concepts/decomposition/#Decomposition","page":"Decomposition","title":"Decomposition","text":"","category":"section"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"Decomposition approaches take advantage of certain problem structures to separate them into multiple related problems which are each more easily solved. Decomposition also allows us to do the inverse, which is to combine independent problems into a single problem, where each can be solved separately but with communication between them (e.g. investments and operations problems)","category":"page"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"Decomposition thus allows us to do a number of things","category":"page"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"Solve larger problems which are otherwise intractable\nInclude more detail in problems which otherwise need to be simplified\nCombine related problems (e.g. investments/operations) in a more scientific way (rather than ad-hoc).\nEmploy parallel computing methods to solve multiple problems simultaneously.","category":"page"},{"location":"advanced_concepts/decomposition/#High-level-Decomposition-Algorithm","page":"Decomposition","title":"High-level Decomposition Algorithm","text":"","category":"section"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"The high-level algorithm is described below. For a more detailed description please see Benders decomposition","category":"page"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"Model initialisation (preprocessdatastructure, generate temporal structures etc.)\nFor each benders_iteration\nSolve master problem\nProcess master-problem solution:\nset units_invested_bi(unit=u, benders_iteration=bi) equal to a timeseries representing the investment variables solution from the master problem\nRewind and update operations problem\nSolve operations problem loop\nProcess operations sub-problem\nset units_available_mv(unit=u, benders_iteration=bi) equal to a timeseries representing the marginal value of the units_on bound constraint\nTest for convergence\nUpdate master problem\nAdd Benders cuts constraints\nNext benders iteration","category":"page"},{"location":"advanced_concepts/decomposition/#Duals-calculation-for-decomposition","page":"Decomposition","title":"Duals calculation for decomposition","text":"","category":"section"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"The optimize_model!() function has been updated to optionally include an additional step for the calculation of duals. The dual solution to a MIP problem is not well defined. The standard approach to obtaining marginal values from a MIP model is to relax the integer variables, fix them to their last solution value and re-solve the problem as an LP. This is the standard approach in energy system modelling to obtain energy prices. However, although this is the standard approach, it does need to be used with caution (see here for example). The main hazard associated with inferring duals in this way is that the impact on costs of an investment may be overstated. However, since these duals are used in Benders decomposition to obtain a lower bound on costs (i.e. the maximum potential value from an investment), this is ok and can be \"corrected\" in the next iteration. And finally, the benders gap will tell us how close our decomposed problem is to the optimal global solution.","category":"page"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"This additional relaxed LP solve is done as follows:","category":"page"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"add_variable!() stores the list of integer and binary variables in m.ext[:integer_variables]\nthe fix_value for integer variables is set to the last MIP solution value\nthe integer constraints on the integer variables are unset()\nA final LP is solved\nrequired dual values are saved\ninteger constraints on integer variables are set()","category":"page"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"This final fixed LP solve is trigged by specifying calculate_duals=true in the call to optimize_model!()","category":"page"},{"location":"advanced_concepts/decomposition/#Reporting-dual-values:","page":"Decomposition","title":"Reporting dual values:","text":"","category":"section"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"To report the dual of a constraint, one can add an output item with the corresponding constraint name (e.g. constraint_nodal_balance) and add that to a report. This will cause the corresponding constraint's relaxed problem marginal value will be reported in the output DB. When adding a constraint name as an output we need to preface the actual constraint name with constraint_ to avoid ambiguity with variable names (e.g. units_available). So to report the marginal value of units_available we add an output object called constraint_units_available.","category":"page"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"To report the reduced_cost() for a variable which is the marginal value of the associated active bound or fix constraints on that variable, one can add an output object with the variable name prepended by bound_. So, to report the unitson reducedcost value, one would create an output item called bound_units_on. If added to a report, this will cause the reduced cost of unitson in the final fixed LP to be written to the output db. Finally, if any constraint duals or reducedcost values are requested via a report, calculate_duals is set to true and the final fixed LP solve is triggered.","category":"page"},{"location":"advanced_concepts/decomposition/#Using-Decomposition","page":"Decomposition","title":"Using Decomposition","text":"","category":"section"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"The decomposition framework creates a master problem where the investment variables are optimised. The decomposition framework is invoked when a model object with the parameter model_type set to :spineopt_operations is found and a second model object with model_type set to :spineopt_master. Once these conditions are met, all investment decisions in the model are automatically decomposed and optimised in the master problem. This behaviour may change in the future to allow some investment decisions to be optimised in the operations problem and some optimised in the master problem as desired.","category":"page"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"Steps to involke decomposition in an investments problem   Assuming one has set up a conventional investments problem as described in Investment Optimization the following additional steps are required to utilise the decomposition framework:","category":"page"},{"location":"advanced_concepts/decomposition/","page":"Decomposition","title":"Decomposition","text":"Create a new model object to representent the benders master problem\nSet the model_type parameter for the master problem model to spineopt_master.\nSet the model_type parameter for the existing conventional, operations problem model to spineopt_operations.\nSpecify the master problem model parameter, max_gap - This determines the master problem convergence criterion for the relative benders gap. A value of 0.05 will represent a relative benders gap of 5%.\nSpecify the master problem model parameter max_iterations - This determines the master problem convergence criterion for the number of iterations. A value of 10 could be appropriate but this is highly dependent on the size and nature of the problem\nSpecify appropriate model_report relationships to determine which reports are written for which model","category":"page"},{"location":"concept_reference/node__commodity/","page":"-","title":"-","text":"node__commodity is a two-dimensional relationship between a node and a commodity and specifies the commodity that flows to or from the node. Generally, since flows are not dimensioned by commodity, this has no meaning in terms of the variables and constraint equations. However, there are two specific uses for this relationship:","category":"page"},{"location":"concept_reference/node__commodity/","page":"-","title":"-","text":"To specify that specific network physics should apply to the network formed by the member nodes for that commodity. See powerflow\nOnly connection flows that are between nodes of the same or no commodity are included in the node_balance constraint.","category":"page"},{"location":"getting_started/archetypes/#Archetypes","page":"Archetypes","title":"Archetypes","text":"","category":"section"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"Archetypes are essentially ready-made templates for different aspects of SpineOpt.jl. They are intended to serve both as examples for how the data structure in SpineOpt.jl works, as well as pre-made modular parts that can be imported on top of existing model input data.","category":"page"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"The templates/models/basic_model_template.json contains a ready-made template for simple energy system models, with uniform time resolution and deterministic stochastic structure. Essentially, it serves as a basis for testing how the modelled system is set up, without having to worry about setting up the temporal and stochastic structures.","category":"page"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"The rest of the different archetypes are included under templates/archetypes in the SpineOpt.jl repository. Each archetype is stored as a .json file containing the necessary objects, relationships, and parameters to form a functioning pre-made part for a SpineOpt.jl model. The archetypes aren't completely plug-and-play, as there are always some relationships required to connect the archetype to the other input data correctly. Regardless, the following sections explain the different archetypes included in the SpineOpt.jl repository, as well as what steps the user needs to take to connect said archetype to their input data correctly.","category":"page"},{"location":"getting_started/archetypes/#Branching-Stochastic-Tree","page":"Archetypes","title":"Branching Stochastic Tree","text":"","category":"section"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"templates/archetypes/branching_stochastic_tree.json","category":"page"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"This archetype contains the definitions required for an example stochastic_structure called branching, representing a branching scenario tree. The stochastic_structure starts out as a single stochastic_scenario called realistic, which then branches out into three roughly equiprobable stochastic_scenarios called forecast1, forecast2, and forecast3 after 6 hours. This archetype is the final product of following the steps in the Example of branching stochastics part of the Stochastic Framework section.","category":"page"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"Importing this archetype into an input datastore only creates the stochastic_structure, which needs to be connected to the rest of your model using either the model__default_stochastic_structure relationship for a model-wide default, or the other relevant Structural relationship classes. Note that the model-wide default gets superceded by any conflicting definitions via e.g. the node__stochastic_structure.","category":"page"},{"location":"getting_started/archetypes/#Converging-Stochastic-Tree","page":"Archetypes","title":"Converging Stochastic Tree","text":"","category":"section"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"templates/archetypes/converging_stochastic_tree.json","category":"page"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"This archetype contains the definitions required for an example stochastic_structure called converging, representing a converging scenario tree (technically a directed acyclic graph DAG). The stochastic_structure starts out as a single stochastic_scenario called realization, which then branches out into three roughly equiprobable stochastic_scenarios called forecast1, forecast2, and forecast3 after 6 hours. Then, after 24 hours (1 day), these three forecasts converge into a single stochastic_scenario called converged_forecast. This archetype is the final product of following the steps in the Example of converging stochastics part of the Stochastic Framework section.","category":"page"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"Importing this archetype into an input datastore only creates the stochastic_structure, which needs to be connected to the rest of your model using either the model__default_stochastic_structure relationship for a model-wide default, or the other relevant Structural relationship classes. Note that the model-wide default gets superceded by any conflicting definitions via e.g. the node__stochastic_structure.","category":"page"},{"location":"getting_started/archetypes/#Deterministic-Stochastic-Structure","page":"Archetypes","title":"Deterministic Stochastic Structure","text":"","category":"section"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"templates/archetypes/deterministic_stochastic_structure.json","category":"page"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"This archetype contains the definitions required for an example stochastic_structure called deterministic, representing a simple deterministic modelling case. The stochastic_structure contains only a single stochastic_scenario called realization, which continues indefinitely. This archetype is the final product of following the steps in the Example of deterministic stochastics part of the Stochastic Framework section.","category":"page"},{"location":"getting_started/archetypes/","page":"Archetypes","title":"Archetypes","text":"Importing this archetype into an input datastore only creates the stochastic_structure, which needs to be connected to the rest of your model using either the model__default_stochastic_structure relationship for a model-wide default, or the other relevant Structural relationship classes. Note that the model-wide default gets superceded by any conflicting definitions via e.g. the node__stochastic_structure.","category":"page"},{"location":"concept_reference/duration_unit/","page":"-","title":"-","text":"The duration_unit parameter specifies the base unit of time in a model. Two values are currently supported, hour and the default minute. E.g. if the duration_unit is set to hour, a Duration of one minute gets converted into 1/60 hours for the calculations.","category":"page"},{"location":"concept_reference/resolution/","page":"-","title":"-","text":"This parameter specifies the resolution of the temporal block, or in other words: the length of the timesteps used in the optimization run. Generally speaking, variables and constraints are generated for each timestep of an optimization. For example, the nodal balance constraint must hold for each timestep.","category":"page"},{"location":"concept_reference/resolution/","page":"-","title":"-","text":"An array of duration values can be used to have a resolution that varies with time itself. It can for example be used when uncertainty in one of the inputs rises as the optimization moves away from the model start. Think of a forecast of for instance wind power generation, which might be available in quarter hourly detail for one day in the future, and in hourly detail for the next two days. It is possible to take a quarter hourly resolution for the full horizon of three days. However, by lowering the temporal resolution after the first day, the computational burden is lowered substantially.","category":"page"},{"location":"mathematical_formulation/variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"mathematical_formulation/variables/#binary_gas_connection_flow","page":"Variables","title":"binary_gas_connection_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_binary_gas_connection_flow","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (connection=conn, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: binary_gas_connection_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Binary variable with the indices node n over the connection conn in the direction to_node for the stochastic scenario s at timestep t describing if the direction of gas flow for a pressure drive gas transfer is in the indicated direction.  ","category":"page"},{"location":"mathematical_formulation/variables/#connection_flow","page":"Variables","title":"connection_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_connection_flow ","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (connection=conn, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: connection_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Commodity flow associated with node n over the connection conn in the direction d for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#connection_intact_flow","page":"Variables","title":"connection_intact_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_connection_intact_flow","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (connection=conn, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: connection_intact_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Represents the ptdf-based flow on connections where all investment candidate connections are present in the network.","category":"page"},{"location":"mathematical_formulation/variables/#connections_decommissioned","page":"Variables","title":"connections_decommissioned","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_connections_decommissioned","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (connection=conn, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: connections_invested_available_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of decomissioned connections conn for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#connections_invested","page":"Variables","title":"connections_invested","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_connections_invested","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (connection=conn, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: connections_invested_available_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of connections conn invested at timestep t in for the stochastic scenario s","category":"page"},{"location":"mathematical_formulation/variables/#connections_invested_available","page":"Variables","title":"connections_invested_available","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_connections_invested_available","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (connection=conn, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: connections_invested_available_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of invested connections conn  that are available still the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#mp_objective_lowerbound_indices","page":"Variables","title":"mp_objective_lowerbound_indices","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_mp_objective_lowerbound_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: mp_objective_lowerbound_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Updating lowerbound for master problem of Benders decomposition","category":"page"},{"location":"mathematical_formulation/variables/#node_injection","page":"Variables","title":"node_injection","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_node_injection","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: node_injection_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Commodity injections at node n for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#node_pressure","page":"Variables","title":"node_pressure","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_node_pressure","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: node_pressure_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Pressue at a node n for a specific stochastic scenario s  and timestep t. See also: has_pressure","category":"page"},{"location":"mathematical_formulation/variables/#node_slack_neg","page":"Variables","title":"node_slack_neg","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_node_slack_neg","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: node_slack_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Negative slack variable at node n for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#node_slack_pos","page":"Variables","title":"node_slack_pos","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_node_slack_pos","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: node_slack_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Positive slack variable at node n for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#node_state","page":"Variables","title":"node_state","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_node_state","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: node_state_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Storage state at node n for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#node_voltage_angle","page":"Variables","title":"node_voltage_angle","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_node_voltage_angle","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: node_voltage_angle_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Voltage angle at a node n for a specific stochastic scenario s  and timestep t. See also: has_voltage_angle","category":"page"},{"location":"mathematical_formulation/variables/#nonspin_ramp_down_unit_flow","page":"Variables","title":"nonspin_ramp_down_unit_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_nonspin_ramp_down_unit_flow","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: nonspin_ramp_down_unit_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Non-spinning downward reserve commodity flows of unit u at node n  in the direction d for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#nonspin_ramp_up_unit_flow","page":"Variables","title":"nonspin_ramp_up_unit_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_nonspin_ramp_up_unit_flow","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: nonspin_ramp_up_unit_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Non-spinning upward reserve commodity flows of unit u at node n  in the direction d for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#nonspin_units_shut_down","page":"Variables","title":"nonspin_units_shut_down","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_nonspin_units_shut_down","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: nonspin_units_shut_down_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of units u held available for non-spinning downward reserve provision via shutdown to node n  for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#nonspin_units_started_up","page":"Variables","title":"nonspin_units_started_up","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_nonspin_units_started_up","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: nonspin_units_started_up_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of units u held available for non-spinning upward reserve provision via startup to node n  for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#ramp_down_unit_flow","page":"Variables","title":"ramp_down_unit_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_ramp_down_unit_flow","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: ramp_down_unit_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Spinning downward ramp commodity flow associated with node n of unit u  with node n over the connection conn in the direction d for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#ramp_up_unit_flow","page":"Variables","title":"ramp_up_unit_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_ramp_up_unit_flow","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: ramp_up_unit_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Spinning upward ramp commodity flow associated with node n of unit u  with node n over the connection conn in the direction d for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#shut_down_unit_flow","page":"Variables","title":"shut_down_unit_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_shut_down_unit_flow","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: shut_down_unit_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Downward ramp commodity flow during shutdown associated with node n of unit u  with node n over the connection conn in the direction d for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#start_up_unit_flow","page":"Variables","title":"start_up_unit_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_start_up_unit_flow","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: start_up_unit_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Upward ramp commodity flow during start-up associated with node n of unit u  with node n over the connection conn in the direction d for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#storages_decommissioned","page":"Variables","title":"storages_decommissioned","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_storages_decommissioned","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: storages_invested_available_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of decomissioned storage nodes n for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#storages_invested","page":"Variables","title":"storages_invested","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_storages_invested","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: storages_invested_available_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of storage nodes n invested in  at timestep t for the stochastic scenario s","category":"page"},{"location":"mathematical_formulation/variables/#storages_invested_available","page":"Variables","title":"storages_invested_available","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_storages_invested_available","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (node=n, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: storages_invested_available_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of invested storage nodes n  that are available still the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#unit_flow","page":"Variables","title":"unit_flow","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_unit_flow","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, direction=d, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: unit_flow_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Commodity flow associated with node n over the unit u in the direction d for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#unit_flow_op","page":"Variables","title":"unit_flow_op","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_unit_flow_op","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, node=n, direction=d, i=i, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: unit_flow_op_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Contribution of the unit flow assocaited with operating point i","category":"page"},{"location":"mathematical_formulation/variables/#units_available","page":"Variables","title":"units_available","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_units_available","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: units_on_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of available units u for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#units_invested","page":"Variables","title":"units_invested","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_units_invested","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: units_invested_available_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of units u for the stochastic scenario s  invested in at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#units_invested_available","page":"Variables","title":"units_invested_available","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_units_invested_available","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: units_invested_available_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of invested units u  that are available still the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#units_mothballed","page":"Variables","title":"units_mothballed","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_units_mothballed","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: units_invested_available_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of units u for the stochastic scenariocenario s  mothballed at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#units_on","page":"Variables","title":"units_on","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_units_on","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: units_on_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of online units u for the stochastic scenario s at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#units_shut_down","page":"Variables","title":"units_shut_down","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_units_shut_down","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: units_on_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of units u for the stochastic scenario s that switched to offline status at timestep t","category":"page"},{"location":"mathematical_formulation/variables/#units_started_up","page":"Variables","title":"units_started_up","text":"","category":"section"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Math symbol: v_units_started_up","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices: (unit=u, stochastic_scenario=s, t=t)","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Indices function: units_on_indices","category":"page"},{"location":"mathematical_formulation/variables/","page":"Variables","title":"Variables","text":"Number of units u for the stochastic scenario s that switched to online status at timestep t","category":"page"},{"location":"concept_reference/minimum_reserve_activation_time/","page":"-","title":"-","text":"The parameter minimum_reserve_activation_time is the duration a reserve product needs to be online, before it can be replaced by another (slower) reserve product.","category":"page"},{"location":"concept_reference/minimum_reserve_activation_time/","page":"-","title":"-","text":"In SpineOpt, the parameter is used to model reserve provision through storages. If a storage provides reserves to a reserve node (see also is_reserve_node) one needs to ensure that the node state is sufficiently high to provide these scheduled reserves as least for the duration of the minimum_reserve_activation_time. The constraint on the minimum node state with reserve provision is triggered by the existence of the minimum_reserve_activation_time. See also Ramping and Reserves","category":"page"},{"location":"concept_reference/fixed_pressure_constant_1/","page":"-","title":"-","text":"For the MILP representation of pressure driven gas transfer, we use an outer approximation approach as described by Schwele et al.. The Weymouth equation is approximated around fixed pressure points, as described by the constraint on fixed node pressure points, constraining the average flow in each direction dependent on the adjacent node pressures. The first fixed pressure constant, which will be multiplied with the pressure of the origin node, is represented by an Array value of the fixed_pressure_constant_1. The second pressure constant corresponds to the related parameter fixed_pressure_constant_0. Note that the fixed_pressure_constant_1 parameter should be defined on a connection__node__node relationship, for which the first node corresponds to the origin node, while the second node corresponds to the destination node. For a typical gas pipeline, the will be a fixed_pressure_constant_1  for both directions of flow.","category":"page"},{"location":"concept_reference/units_invested_avaiable_coefficient/","page":"-","title":"-","text":"The units_invested_available_coefficient is an optional parameter that can be used to include the units_invested_available variable in a user_constraint via the unit__user_constraint relationship. Essentially, units_invested_available_coefficient appears as a coefficient for the units_invested_available variable in the user constraint. For more information, see the [User Constraints Concept Reference][#User-Constraints]","category":"page"},{"location":"concept_reference/fuel_cost/","page":"-","title":"-","text":"By defining the fuel_cost parameter for a specific unit, node, and direction, a cost term will be added to the objective function to account for costs associated with the unit's fuel usage over the course of its operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/online_variable_type/","page":"-","title":"-","text":"online_variable_type is a method parameter closely related to the number_of_units and can take the values \"unit_online_variable_type_binary\", \"unit_online_variable_type_integer\", \"unit_online_variable_type_linear\". If the binary value is chosen, the units status is modelled as a binary (classic UC). For clustered unit commitment units, the integer type is applicable. Note that if the parameter is not defined, the default will be linear. If the units status is not crucial, this can reduce the computational burden.","category":"page"},{"location":"concept_reference/stochastic_scenario_end/","page":"-","title":"-","text":"The stochastic_scenario_end is a Duration-type parameter, defining when a stochastic_scenario ends relative to the start of the current optimization. As it is a parameter for the stochastic_structure__stochastic_scenario relationship, different stochastic_structures can have different values for the same stochastic_scenario, making it possible to define slightly different stochastic_structures using the same stochastic_scenarios. See the Stochastic Framework section for more information about how different stochastic_structures interact in SpineOpt.jl.","category":"page"},{"location":"concept_reference/stochastic_scenario_end/","page":"-","title":"-","text":"When a stochastic_scenario ends at the point in time defined by the stochastic_scenario_end parameter, it spawns its children according to the parent_stochastic_scenario__child_stochastic_scenario relationship. Note that the children will be inherently assumed to belong to the same stochastic_structure their parent belonged to, even without explicit stochastic_structure__stochastic_scenario relationships! Thus, you might need to define the weight_relative_to_parents parameter for the children.","category":"page"},{"location":"concept_reference/stochastic_scenario_end/","page":"-","title":"-","text":"If no stochastic_scenario_end is defined, the stochastic_scenario is assumed to go on indefinitely.","category":"page"},{"location":"concept_reference/fractional_demand/","page":"-","title":"-","text":"Whenever a node is a member of a group, the fractional_demand parameter represents its share of the group's demand.","category":"page"},{"location":"concept_reference/node/","page":"-","title":"-","text":"The node is perhaps the most important object class out of the Systemic object classes, as it is what connects the rest together via the Systemic relationship classes. Essentially, nodes act as points in the modelled commodity network where commodity balance is enforced via the node balance and node injection constraints, tying together the inputs and outputs from units and connections, as well as any external demand. Furthermore, nodes play a crucial role for defining the temporal and stochastic structures of the model via the node__temporal_block and node__stochastic_structure relationships. For more details about the Temporal Framework and the Stochastic Framework, please refer to the dedicated sections.","category":"page"},{"location":"concept_reference/node/","page":"-","title":"-","text":"Since nodes act as the points where commodity balance is enforced, this also makes them a natural fit for implementing storage. The has_state parameter controls whether a node has a node_state variable, which essentially represents the commodity content of the node. The state_coeff parameter tells how the node_state variable relates to all the commodity flows. Storage losses are handled via the frac_state_loss parameter, and potential diffusion of commodity content to other nodes via the diff_coeff parameter for the node__node relationship.","category":"page"},{"location":"concept_reference/fix_connection_intact_flow/","page":"-","title":"-","text":"The fix_connection_intact_flow parameter can be used to fix the values of the connection_intact_flow variable to preset values. If set to a Scalar type value, the connection_intact_flow variable is fixed to that value for all time steps and stochastic_scenarios. Values for individual time steps can be fixed using TimeSeries type values.","category":"page"},{"location":"concept_reference/node__investment_stochastic_structure/","page":"-","title":"-","text":"The node__investment_stochastic_structure relationship defines the stochastic_structure of node-related investment decisions. Essentially, it sets the stochastic_structure used by the storages_invested_available variable of the node.","category":"page"},{"location":"concept_reference/node__investment_stochastic_structure/","page":"-","title":"-","text":"The node__investment_stochastic_structure relationship uses the model__default_investment_stochastic_structure relationship if not defined.","category":"page"},{"location":"concept_reference/fix_nonspin_ramp_down_unit_flow/","page":"-","title":"-","text":"The fix_nonspin_ramp_down_unit_flow parameter simply fixes the value of the nonspin_ramp_down_unit_flow variable to the provided value. As such, it determines directly how much non-spinning downward reserve commodity flows the relevant unit is providing to the node to which it is linked by the unit__to_node relationship.","category":"page"},{"location":"concept_reference/fix_nonspin_ramp_down_unit_flow/","page":"-","title":"-","text":"When a single value is selected, this value is kept constant throughout the model. It is also possible to provide a timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/min_up_time/","page":"-","title":"-","text":"The definition of the min_up_time parameter will trigger the creation of the Constraint on minimum up time. It sets a lower bound on the period that a unit has to stay online after a startup.","category":"page"},{"location":"concept_reference/min_up_time/","page":"-","title":"-","text":"It can be defined for a unit and will then impose restrictions on the units_on variables that represent the on- or offline status of the unit. The parameter is given as a duration value. When the parameter is not included, the aforementioned constraint will not be created, which is equivalent to choosing a value of 0.","category":"page"},{"location":"concept_reference/min_up_time/","page":"-","title":"-","text":"For a more complete description of unit commmitment restrictions, see Unit commitment.","category":"page"},{"location":"concept_reference/candidate_units/","page":"-","title":"-","text":"Within an investments problem candidate_units determines the upper bound on the unit investment decision variable in constraint units_invested_available. In constraint unit_flow_capacity the maximum unit_flow will be the product of the units_invested_available and the corresponding unit_capacity. Thus, the interpretation of candidate_units depends on unit_investment_variable_type which determines the unit investment decision variable type. If unit_investment_variable_type is integer or binary, then candidate_units represents the maximum number of discrete units that may be invested in. If unit_investment_variable_type is continuous, candidate_units is more analagous to a maximum storage capacity.","category":"page"},{"location":"concept_reference/candidate_units/","page":"-","title":"-","text":"Note that candidate_units is the main investment switch and setting a value other than none/nothing triggers the creation of the investment variable for the unit. Note that a value of zero will still trigger the variable creation but its value will be fixed to zero. This can be useful if an inspection of the related dual variables will yield the value of this resource.","category":"page"},{"location":"concept_reference/candidate_units/","page":"-","title":"-","text":"See also Investment Optimization and unit_investment_variable_type","category":"page"},{"location":"getting_started/installation/#Compatibility","page":"Installation","title":"Compatibility","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"This package requires Julia 1.2 or later.","category":"page"},{"location":"getting_started/installation/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"SpineOpt is cross-platform (Linux, Mac and Windows) and uses other cross-platform tools. The installation process includes several steps, since there are two other pieces of software that make the use of SpineOpt more convenient (Spine Toolbox and Conda) and two programming languages that are needed (Python for Spine Toolbox and Julia for SpineOpt). Python will be installed with Conda while Julia will be setup for Spine Toolbox (explained below). ","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"You may skip parts of the following installation process if you already have some of these software available - but please make sure they are in a clean Conda environment to avoid compatibility issues between different package versions.","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"SpineOpt and Spine Toolbox are under active development and the getting started process could change. If you notice any problems with these instructions, please check if it is a known issue, and if not, then report an issue or start a discussion if you're unsure whether it is an actual issue.","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"The recommended interface to SpineOpt is Spine Toolbox. Install Spine Toolbox following instructions from here: Spine Toolbox installation","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Setup Julia for Spine Toolbox: Start Spine Toolbox. Go to File –> Settings –> Tools. Either select an existing Julia installation, or press Install Julia button and follow the instructions. You can download & install Julia manually from https://julialang.org/downloads/.","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"[Optional] If you want to install and run SpineOpt in a specific Julia project environment (the place for Project.toml and Manifest.toml), you can set the path to the environment folder to the line edit just below the Julia executable line edit (the one that says Using Julia default project when empty).","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"[Optional] Select a Julia Kernel spec. If none exist, you need to install a Julia kernel specification either manually or by using the dialog under Kernel spec editor button. Use the newly installed Julia, give the kernel spec a name and click 'Make kernel specification' button. Installing a kernel spec also installs the IJulia package if missing. The kernel specs allows you to interact with Julia code inside Spine Toolbox using the Julia console.","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Install SpineOpt by clicking the Add/Update SpineOpt button and follow the instructions on screen. You may also install SpineOpt manually by opening a Julia REPL (must be the same Julia that you just selected for Spine Toolbox). Enter the following into the REPL:","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"julia> using Pkg\r\n\r\njulia> pkg\"registry add https://github.com/Spine-project/SpineJuliaRegistry\"\r\n\r\njulia> pkg\"add SpineOpt\"","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"This may take a while and nothing seems to happen, but the installation process should be ongoing.","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"Add SpineOpt tool icons to Spine Toolbox. Go to Plugins –> Install plugins and select and install SpineOpt.","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"You should get a new ribbon in the toolbar with Run SpineOpt and Load template","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"(Image: image)","category":"page"},{"location":"getting_started/installation/","page":"Installation","title":"Installation","text":"After this, you have SpineOpt available as a tool in Spine Toolbox, but next you need to setup a workflow including input and output dabases. Instructions are in the next section here.","category":"page"},{"location":"concept_reference/variable_type_list/","page":"-","title":"-","text":"The variable_type_list parameter value list contains the possible values for the connection_investment_variable_type and storage_investment_variable_type parameters.","category":"page"},{"location":"concept_reference/fom_cost/","page":"-","title":"-","text":"By defining the fom_cost parameter for a specific unit, a cost term will be added to the objective function to account for the fixed operation and maintenance costs associated with that unit during the current optimization window.","category":"page"},{"location":"concept_reference/fix_ramp_up_unit_flow/","page":"-","title":"-","text":"The fix_ramp_up_unit_flow parameter simply fixes the value of the ramp_up_unit_flow variable to the provided value. It is possible to provide an incomplete timeseries of values, which can be used for example to impose initial conditions by providing a value only for the first timestep included in the model.","category":"page"},{"location":"concept_reference/reserve_procurement_cost/","page":"-","title":"-","text":"By defining the reserve_procurement_cost parameter for a specific unit__to_node or unit__from_node relationship, a cost term will be added to the objective function whenever that unit is used over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/max_res_shutdown_ramp/","page":"-","title":"-","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning downward reserves are provided to a downward_reserve node by contracted units holding available to shutdown. To include the provision of nonspinning downward reserves, the parameter max_res_shutdown_ramp needs to be defined on the corresponding unit__to_node relationship. This will trigger the generation of the variables nonspin_units_shut_down and nonspin_ramp_down_unit_flow and the constraint on maximum downward nonspinning reserve provision. Note that max_res_shutdown_ramp is given as a fraction of the unit_capacity.","category":"page"},{"location":"concept_reference/max_res_shutdown_ramp/","page":"-","title":"-","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/max_ratio_out_in_unit_flow/","page":"-","title":"-","text":"The definition of the max_ratio_out_in_unit_flow parameter triggers the generation of the constraint_max_ratio_out_in_unit_flow and enforces an upper bound on the ratio between outgoing and incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the unit, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/max_ratio_out_in_unit_flow/","page":"-","title":"-","text":"To enforce e.g. a maximum ratio of 0.8 for a unit u between its outgoing flows to the node group el_heat (consisting of the two nodes el and heat) and its incoming gas flow from ng the max_ratio_out_in_unit_flow parameter would be set to 0.8 for the relationship u__el_heat__ng.","category":"page"},{"location":"concept_reference/connection__investment_temporal_block/","page":"-","title":"-","text":"connection__investment_temporal_block is a two-dimensional relationship between a connection and a temporal_block. This relationship defines the temporal resolution and scope of a connection's investment decision. Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__default_investment_temporal_block is specified and no connection__investment_temporal_block relationship is specified, the model__default_investment_temporal_block relationship will be used. Conversely if connection__investment_temporal_block is specified along with model__temporal_block, this will override model__default_investment_temporal_block for the specified connection.","category":"page"},{"location":"concept_reference/connection__investment_temporal_block/","page":"-","title":"-","text":"See also Investment Optimization","category":"page"},{"location":"concept_reference/node_state_coefficient/","page":"-","title":"-","text":"The node_state_coefficient is an optional parameter that can be used to include the node_state variable of a node in a user_constraint via the node__user_constraint relationship. Essentially, node_state_coefficient appears as a coefficient for the node_state variable of the node in the user constraint.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#Parameter-Value-Lists","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/#balance_type_list","page":"Parameter Value Lists","title":"balance_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: balance_type_group, balance_type_node and balance_type_none ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"The balance_type_list parameter value list contains the possible values for the balance_type parameter.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#boolean_value_list","page":"Parameter Value Lists","title":"boolean_value_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: false and true ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"A list of boolean values (True or False).","category":"page"},{"location":"concept_reference/Parameter Value Lists/#commodity_physics_list","page":"Parameter Value Lists","title":"commodity_physics_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: commodity_physics_lodf, commodity_physics_none and commodity_physics_ptdf ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"commodity_physics_list holds the possible values for the commodity parameter commodity_physics parameter. See commodity_physics for more details","category":"page"},{"location":"concept_reference/Parameter Value Lists/#connection_investment_variable_type_list","page":"Parameter Value Lists","title":"connection_investment_variable_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: connection_investment_variable_type_continuous and connection_investment_variable_type_integer ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"The connection_investment_variable_type_list holds the possible values for the type of a connection's investment variable which may be chosen between integer or continuous. ","category":"page"},{"location":"concept_reference/Parameter Value Lists/#connection_type_list","page":"Parameter Value Lists","title":"connection_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: connection_type_lossless_bidirectional and connection_type_normal ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"connection_type_list holds the possible values for the connection_type parameter. See connection_type for more details","category":"page"},{"location":"concept_reference/Parameter Value Lists/#constraint_sense_list","page":"Parameter Value Lists","title":"constraint_sense_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: <=, == and >= ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"The constraint_sense_list parameter value list contains the possible values for the constraint_sense parameter.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#duration_unit_list","page":"Parameter Value Lists","title":"duration_unit_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: hour and minute ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"The duration_unit_list parameter value list contains the possible values for the duration_unit parameter.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#model_type_list","page":"Parameter Value Lists","title":"model_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: spineopt_master, spineopt_operations and spineopt_other ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"model_type_list holds the possible values for the model parameter model_type parameter. See model_type for more details","category":"page"},{"location":"concept_reference/Parameter Value Lists/#node_opf_type_list","page":"Parameter Value Lists","title":"node_opf_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: node_opf_type_normal and node_opf_type_reference ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Houses the different possible values for the node_opf_type parameter. To identify the reference node, set node_opf_type = :node_opf_type_reference, while node_opf_type = node_opf_type_normal is the default value for non-reference nodes.","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"See also powerflow.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#unit_investment_variable_type_list","page":"Parameter Value Lists","title":"unit_investment_variable_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: unit_investment_variable_type_continuous and unit_investment_variable_type_integer ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"unit_investment_variable_type_list holds the possible values for the type of a unit's investment variable which may be chosen from integer, binary or continuous. ","category":"page"},{"location":"concept_reference/Parameter Value Lists/#unit_online_variable_type_list","page":"Parameter Value Lists","title":"unit_online_variable_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: unit_online_variable_type_binary, unit_online_variable_type_integer and unit_online_variable_type_linear ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"unit_online_variable_type_list holds the possible values for the type of a unit's commitment status variable which may be chosen from binary, integer, or linear. ","category":"page"},{"location":"concept_reference/Parameter Value Lists/#variable_type_list","page":"Parameter Value Lists","title":"variable_type_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: variable_type_binary, variable_type_continuous and variable_type_integer ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"The variable_type_list parameter value list contains the possible values for the connection_investment_variable_type and storage_investment_variable_type parameters.","category":"page"},{"location":"concept_reference/Parameter Value Lists/#write_mps_file_list","page":"Parameter Value Lists","title":"write_mps_file_list","text":"","category":"section"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Possible values: write_mps_always, write_mps_never and write_mps_on_no_solve ","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"This parameter value list is deprecated and will be removed in a future version.","category":"page"},{"location":"concept_reference/Parameter Value Lists/","page":"Parameter Value Lists","title":"Parameter Value Lists","text":"Houses the different values for the write_mps_file parameter. Possible values include write_mps_always, write\\_mps\\_on\\_no\\_solve, and write\\_mps\\_never.","category":"page"},{"location":"concept_reference/has_pressure/","page":"-","title":"-","text":"If a node is to represent a node in a pressure driven gas network, the boolean parameter has_pressure should be set true, in order to trigger the generation of the node_pressure variable. The pressure at a certain node can also be constrainted through the parameters max_node_pressure and min_node_pressure. More details on the use of pressure driven gas transfer are described here","category":"page"},{"location":"concept_reference/node_opf_type_list/","page":"-","title":"-","text":"Houses the different possible values for the node_opf_type parameter. To identify the reference node, set node_opf_type = :node_opf_type_reference, while node_opf_type = node_opf_type_normal is the default value for non-reference nodes.","category":"page"},{"location":"concept_reference/node_opf_type_list/","page":"-","title":"-","text":"See also powerflow.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_in_in/","page":"-","title":"-","text":"The max_units_on_coefficient_in_in parameter is an optional coefficient in the unit input-input ratio constraint controlled by the max_ratio_in_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the maximum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/max_units_on_coefficient_in_in/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: max_units_on_coefficient_in_out, max_units_on_coefficient_out_in, and max_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting minimum or fixed conversion rates, e.g.  min_units_on_coefficient_in_in and fix_units_on_coefficient_in_in.","category":"page"},{"location":"concept_reference/units_invested_coefficient/","page":"-","title":"-","text":"The units_invested_coefficient is an optional parameter that can be used to include the units_invested variable in a user_constraint via the unit__user_constraint relationship. Essentially, units_invested_coefficient appears as a coefficient for the units_invested variable in the user constraint. For more information, see the [User Constraints Concept Reference][#User-Constraints]","category":"page"},{"location":"concept_reference/unit_start_flow/","page":"-","title":"-","text":"Used to implement unit startup fuel consumption where node 1 is assumed to be input fuel and node 2 is assumed to be output elecrical energy. This is a flow from node 1 that is incurred when the value of the variable unitsstartedup is 1 in the corresponding time period. This flow does not result in additional output flow at node 2. Used in conjunction with unit_incremental_heat_rate. unit_start_flow is only currently considered if unit_incremental_heat_rate is specified. A trivial unit_incremental_heat_rate of zero can be defined if there is no incremental heat rate.","category":"page"},{"location":"concept_reference/connection_investment_variable_type_list/","page":"-","title":"-","text":"The connection_investment_variable_type_list holds the possible values for the type of a connection's investment variable which may be chosen between integer or continuous. ","category":"page"},{"location":"concept_reference/balance_type_list/","page":"-","title":"-","text":"The balance_type_list parameter value list contains the possible values for the balance_type parameter.","category":"page"},{"location":"concept_reference/connection_reactance/","page":"-","title":"-","text":"The per unit reactance of a transmission line. Used in ptdf based dc load flow where the relative reactances of lines determine the ptdfs of the network and in lossless dc powerflow where the flow on a line is given by flow = 1/x(theta_to-theta_from) where x is the reatance of the line, thetato is the voltage angle of the remote node and thetafrom is the voltage angle of the sending node. ","category":"page"},{"location":"concept_reference/fix_node_pressure/","page":"-","title":"-","text":"In a pressure driven gas model, gas network nodes are associated with the node_pressure variable. In order to fix the pressure at a certain node or to give intial conditions the fix_node_pressure parameter can be used.","category":"page"},{"location":"concept_reference/fix_ratio_out_in_connection_flow/","page":"-","title":"-","text":"The definition of the fix_ratio_out_in_connection_flow parameter triggers the generation of the constraint_fix_ratio_out_in_connection_flow and fixes the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection. In most cases the fix_ratio_out_in_connection_flow parameter is set to equal or lower than 1, linking the flows entering to the flows leaving the connection. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the connection_flow variable from the first node in the connection__node__node relationship in a left-to-right order. The parameter can be used to e.g. account for losses over a connection in a certain direction.","category":"page"},{"location":"concept_reference/fix_ratio_out_in_connection_flow/","page":"-","title":"-","text":"To enforce e.g. a fixed ratio of 0.8 for a connection conn between its outgoing electricity flow to node el1 and its incoming flows from the node node el2, the fix_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship u__el1__el2.","category":"page"},{"location":"concept_reference/Relationship Classes/#Relationship-Classes","page":"Relationship Classes","title":"Relationship Classes","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/#connection__from_node","page":"Relationship Classes","title":"connection__from_node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the nodes the connection can take input from, and holds most connection_flow variable specific parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and node","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: connection_capacity, connection_conv_cap_to_flow, connection_emergency_capacity, fix_binary_gas_connection_flow, fix_connection_flow, fix_connection_intact_flow and graph_view_position","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"connection__from_node is a two-dimensional relationship between a connection and a node and implies a connection_flow to the connection from the node. Specifying such a relationship will give rise to a connection_flow_variable with indices connection=connection, node=node, direction=:from_node. Relationships defined on this relationship will generally apply to this specific flow variable. For example, connection_capacity will apply only to this specific flow variable, unless the connection parameter connection_type is specified.","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__from_node__user_constraint","page":"Relationship Classes","title":"connection__from_node__user_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"when specified this relationship allows the relevant flow connection flow variable to be included in the specified user constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection, node and user_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: connection_flow_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__investment_stochastic_structure","page":"Relationship Classes","title":"connection__investment_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the stochastic structure of the connections investments variable","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The connection__investment_stochastic_structure relationship defines the stochastic_structure of connection-related investment decisions. Essentially, it sets the stochastic_structure used by the connections_invested_available variable of the connection.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The connection__investment_stochastic_structure relationship uses the model__default_investment_stochastic_structure relationship if not defined.","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__investment_temporal_block","page":"Relationship Classes","title":"connection__investment_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the temporal resolution of the connections investments variable","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"connection__investment_temporal_block is a two-dimensional relationship between a connection and a temporal_block. This relationship defines the temporal resolution and scope of a connection's investment decision. Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__default_investment_temporal_block is specified and no connection__investment_temporal_block relationship is specified, the model__default_investment_temporal_block relationship will be used. Conversely if connection__investment_temporal_block is specified along with model__temporal_block, this will override model__default_investment_temporal_block for the specified connection.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"See also Investment Optimization","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__node__node","page":"Relationship Classes","title":"connection__node__node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Holds parameters spanning multiple connection_flow variables to and from multiple nodes.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and node","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: compression_factor, connection_flow_delay, connection_linepack_constant, fix_ratio_out_in_connection_flow, fixed_pressure_constant_0, fixed_pressure_constant_1, max_ratio_out_in_connection_flow and min_ratio_out_in_connection_flow","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"connection__node__node is a three-dimensional relationship between a connection, a node (node 1) and another node (node 2). connection__node__node infers a conversion and a direction with respect to that conversion. Node 1 is assumed to be the input node and node 2 is assumed to be the output node. For example, the fix_ratio_out_in_connection_flow parameter defined on connection__node__node relates the output connection_flow to node 2 to the intput connection_flow from node 1","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__to_node","page":"Relationship Classes","title":"connection__to_node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the nodes the connection can output to, and holds most connection_flow variable specific parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and node","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: connection_capacity, connection_conv_cap_to_flow, connection_emergency_capacity, fix_binary_gas_connection_flow, fix_connection_flow, fix_connection_intact_flow and graph_view_position","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"connection__to_node is a two-dimensional relationship between a connection and a node and implies a connection_flow from the connection to the node. Specifying such a relationship will give rise to a connection_flow_variable with indices connection=connection, node=node, direction=:to_node. Relationships defined on this relationship will generally apply to this specific flow variable. For example, connection_capacity will apply only to this specific flow variable, unless the connection parameter connection_type is specified.","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__to_node__user_constraint","page":"Relationship Classes","title":"connection__to_node__user_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"when specified this relationship allows the relevant flow connection flow variable to be included in the specified user constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection, node and user_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: connection_flow_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#connection__user_constraint","page":"Relationship Classes","title":"connection__user_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Relationship required to involve a connections investment variables in a user_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: connection and user_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: connections_invested_available_coefficient and connections_invested_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#model__default_investment_stochastic_structure","page":"Relationship Classes","title":"model__default_investment_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the default stochastic structure used for investment variables, which will be replaced by more specific definitions","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The model__default_investment_stochastic_structure relationship can be used to set model-wide default unit__investment_stochastic_structure, connection__investment_stochastic_structure, and node__investment_stochastic_structure relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific unit__investment_stochastic_structure, connection__investment_stochastic_structure, and node__investment_stochastic_structure relationships take priority over the model__default_investment_stochastic_structure relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#model__default_investment_temporal_block","page":"Relationship Classes","title":"model__default_investment_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the default temporal block used for investment variables, which will be replaced by more specific definitions","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"model__default_investment_temporal_block is a two-dimensional relationship between a model and a temporal_block. This relationship defines the default temporal resolution and scope for all investment decisions in the model (units, connections and storages). Specifying model__default_investment_temporal_block for a model avoids the need to specify individual node__investment_temporal_block, unit__investment_temporal_block and connection__investment_temporal_block relationships. Conversely, if any of these individual relationships are defined (e.g. connection__investment_temporal_block) along with model__temporal_block, these will override model__default_investment_temporal_block.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"See also Investment Optimization","category":"page"},{"location":"concept_reference/Relationship Classes/#model__default_stochastic_structure","page":"Relationship Classes","title":"model__default_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the default stochastic structure used for model variables, which will be replaced by more specific definitions","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The model__default_stochastic_structure relationship can be used to set a model-wide default for the node__stochastic_structure and units_on__stochastic_structure relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific node__stochastic_structure or units_on__stochastic_structure relationships take priority over the model__default_stochastic_structure relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#model__default_temporal_block","page":"Relationship Classes","title":"model__default_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the default temporal block used for model variables, which will be replaced by more specific definitions","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The model__default_temporal_block relationship can be used to set a model-wide default for the node__temporal_block and units_on__temporal_block relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific node__temporal_block or units_on__temporal_block relationships take priority over the model__default_temporal_block relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#model__report","page":"Relationship Classes","title":"model__report","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Determines which reports are written for each model and in turn, which outputs are written for each model","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and report","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The model__report relationship tells which reports are written by which model, where the contents of the reports are defined separately using the report__output relationship. Without appropriately defined model__report and report__output and relationships, SpineOpt doesn't write any output, so be sure to include at least one report connected to all the output variables of interest in the model!","category":"page"},{"location":"concept_reference/Relationship Classes/#model__stochastic_structure","page":"Relationship Classes","title":"model__stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which stochastic_structures are included in which models.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The [model__stochastic_structure] relationship defines which stochastic_structures are active in which models. Essentially, this relationship allows for e.g. attributing multiple node__stochastic_structure relationships for a single node, and switching between them in different models. Any stochastic_structure in the model__default_stochastic_structure relationship is automatically assumed to be active in the connected model, so there's no need to include it in [model__stochastic_structure] separately.","category":"page"},{"location":"concept_reference/Relationship Classes/#model__temporal_block","page":"Relationship Classes","title":"model__temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which temporal_blocks are included in which models.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: model and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The model__temporal_block relationship is used to determine which temporal_blocks are included in a specific model. Note that defining this relationship does not yet imply that any element of the model will be governed by the specified temporal_block, for this to happen additional relationships have to be defined such as the model__default_temporal_block relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__commodity","page":"Relationship Classes","title":"node__commodity","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Define a commodity for a node. Only a single commodity is permitted per node","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: commodity and node","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"node__commodity is a two-dimensional relationship between a node and a commodity and specifies the commodity that flows to or from the node. Generally, since flows are not dimensioned by commodity, this has no meaning in terms of the variables and constraint equations. However, there are two specific uses for this relationship:","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"To specify that specific network physics should apply to the network formed by the member nodes for that commodity. See powerflow\nOnly connection flows that are between nodes of the same or no commodity are included in the node_balance constraint.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__investment_stochastic_structure","page":"Relationship Classes","title":"node__investment_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"defines the stochastic structure for node related investments, currently only storages","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The node__investment_stochastic_structure relationship defines the stochastic_structure of node-related investment decisions. Essentially, it sets the stochastic_structure used by the storages_invested_available variable of the node.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The node__investment_stochastic_structure relationship uses the model__default_investment_stochastic_structure relationship if not defined.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__investment_temporal_block","page":"Relationship Classes","title":"node__investment_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"defines the temporal resolution for node related investments, currently only storages","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"node__investment_temporal_block is a two-dimensional relationship between a node and a temporal_block. This relationship defines the temporal resolution and scope of a node's investment decisions (currently only storage invesments). Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__default_investment_temporal_block is specified and no node__investment_temporal_block relationship is specified, the model__default_investment_temporal_block relationship will be used. Conversely if node__investment_temporal_block is specified along with model__temporal_block, this will override model__default_investment_temporal_block for the specified node.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"See also Investment Optimization","category":"page"},{"location":"concept_reference/Relationship Classes/#node__node","page":"Relationship Classes","title":"node__node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Holds parameters for direct interactions between two nodes, e.g. node_state diffusion coefficients.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: diff_coeff","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The node__node relationship is used for defining direct interactions between two nodes, like diffusion of commodity content. Note that the node__node relationship is assumed to be one-directional, meaning that","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"node__node(node1=n1, node2=n2) != node__node(node1=n2, node2=n1).","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Thus, when one wants to define symmetric relationships between two nodes, one needs to define both directions as separate relationships.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__stochastic_structure","page":"Relationship Classes","title":"node__stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which specific stochastic_structure is used by the node and all flow variables associated with it. Only one stochastic_structure is permitted per node.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The node__stochastic_structure relationship defines which stochastic_structure the node uses. Essentially, it sets the stochastic_structure of all the flow variables connected to the node, as well as the potential node_state variable. Note that only one stochastic_structure can be defined per node per model, as interpreted based on the node__stochastic_structure and model__stochastic_structure relationships. Investment variables use dedicated relationships, as detailed in the Investment Optimization section.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The node__stochastic_structure relationship uses the model__default_stochastic_structure relationship if not specified.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__temporal_block","page":"Relationship Classes","title":"node__temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the temporal_blocks used by the node and all the flow variables associated with it.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: cyclic_condition","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"This relationship links a node to a temporal_block and as such it will determine which temporal block governs the temporal horizon and resolution of the variables associated with this node. Specifically, the resolution of the temporal block will directly imply the duration of the time slices for which both the regular and ramping flow variables and their associated constraints are created.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"For a more detailed description of how the temporal structure in SpineOpt can be created, see Temporal Framework.","category":"page"},{"location":"concept_reference/Relationship Classes/#node__user_constraint","page":"Relationship Classes","title":"node__user_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"specifying this relationship allows a node's demand or node_state to be included in the specified user constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and user_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: demand_coefficient, node_state_coefficient, storages_invested_available_coefficient and storages_invested_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#parent_stochastic_scenario__child_stochastic_scenario","page":"Relationship Classes","title":"parent_stochastic_scenario__child_stochastic_scenario","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the master stochastic direct acyclic graph, meaning how the stochastic_scenarios are related to each other.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: stochastic_scenario","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The parent_stochastic_scenario__child_stochastic_scenario relationship defines how the individual stochastic_scenarios are related to each other, forming what is referred to as the stochastic direct acyclic graph (DAG) in the Stochastic Framework section. It acts as a sort of basis for the stochastic_structures, but doesn't contain any Parameters necessary for describing how it relates to the Temporal Framework or the Objective function.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The parent_stochastic_scenario__child_stochastic_scenario relationship and the stochastic DAG it forms are crucial for Constraint generation with stochastic path indexing. Every finite stochastic DAG has a limited number of unique ways of traversing it, called full stochastic paths, which are used when determining how many different constraints need to be generated over time periods where stochastic_structures branch or converge, or when generating constraints involving different stochastic_structures. See the Stochastic Framework section for more information.","category":"page"},{"location":"concept_reference/Relationship Classes/#report__output","page":"Relationship Classes","title":"report__output","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Output object related to a report object are returned to the output database (if they appear in the model as variables)","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: output and report","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: overwrite_results_on_rolling","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The report__output relationship tells which output variables to include in which report when writing SpineOpt output. Note that the reports also need to be connected to a model using the model__report relationship. Without appropriately defined model__report and report__output and relationships, SpineOpt doesn't write any output, so be sure to include at least one report connected to all the output variables of interest in the model!","category":"page"},{"location":"concept_reference/Relationship Classes/#stochastic_structure__stochastic_scenario","page":"Relationship Classes","title":"stochastic_structure__stochastic_scenario","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which stochastic_scenarios are included in which stochastic_structure, and holds the parameters required for realizing the structure in combination with the temporal_blocks.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: stochastic_scenario and stochastic_structure","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: stochastic_scenario_end and weight_relative_to_parents","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The stochastic_structure__stochastic_scenario relationship defines which stochastic_scenarios are included in which stochastic_structure, as well as holds the stochastic_scenario_end and weight_relative_to_parents Parameters defining how the stochastic_structure interacts with the Temporal Framework and the Objective function. Along with parent_stochastic_scenario__child_stochastic_scenario, this relationship is used to define the exact properties of each stochastic_structure, which are then applied to the objects describing the modelled system according to the Structural relationship classes, like the node__stochastic_structure relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__commodity","page":"Relationship Classes","title":"unit__commodity","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Holds parameters for commodities used by the unit.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: commodity and unit","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: max_cum_in_unit_flow_bound","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"To impose a limit on the cumulative amount of commodity flows, the max_cum_in_unit_flow_bound can be imposed on a unit__commodity relationship. This can be very helpful, e.g. if a certain amount of emissions should not be surpased throughout the optimization.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Note that, next to the unit__commodity relationship, also the nodes connected to the units need to be associated with their corresponding commodities, see node__commodity.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__from_node","page":"Relationship Classes","title":"unit__from_node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the nodes the unit can take input from, and holds most unit_flow variable specific parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and unit","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: fix_nonspin_ramp_up_unit_flow, fix_nonspin_units_started_up, fix_ramp_up_unit_flow, fix_start_up_unit_flow, fix_unit_flow_op, fix_unit_flow, fuel_cost, graph_view_position, max_res_shutdown_ramp, max_res_startup_ramp, max_shutdown_ramp, max_startup_ramp, min_res_shutdown_ramp, min_res_startup_ramp, min_shutdown_ramp, min_startup_ramp, minimum_operating_point, operating_points, ramp_down_cost, ramp_down_limit, ramp_up_cost, ramp_up_limit, reserve_procurement_cost, unit_capacity, unit_conv_cap_to_flow and vom_cost","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The unit__to_node and unit__from_node unit relationships are core elements of SpineOpt. For each unit__to_node or unit__from_node, a unit_flow variable is automatically added to the model, i.e. a commodity flow of a unit to or from a specific node, respectively.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Various parameters can be defined on the unit__from_node relationship, in order to constrain the associated unit flows. In most cases a unit_capacity will be defined for an upper bound on the commodity flows. Apart from that, ramping abilities of a unit can be defined. For further details on ramps see Ramping and Reserves.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"To associate costs with a certain commodity flows, cost terms, such as fuel_costs and vom_costs, can be included for the unit__from_node relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"It is important to note, that the parameters associated with the unit__from_node can be defined either for a specific node, or for a group of nodes. Grouping nodes for the described parameters will result in an aggregation of the unit flows for the triggered constraint, e.g. the definition of the unit_capacity on a group of nodes will result in an upper bound on the sum of all individual unit_flows.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__from_node__user_constraint","page":"Relationship Classes","title":"unit__from_node__user_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which input unit_flows are included in the user_constraint, and holds their parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node, unit and user_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: graph_view_position and unit_flow_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__investment_stochastic_structure","page":"Relationship Classes","title":"unit__investment_stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Sets the stochastic structure for investment decisions - overrides model__default_investment_stochastic_structure.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: stochastic_structure and unit","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The unit__investment_stochastic_structure relationship defines the stochastic_structure of unit-related investment decisions. Essentially, it sets the stochastic_structure used by the units_invested_available variable of the unit.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The unit__investment_stochastic_structure relationship uses the model__default_investment_stochastic_structure relationship if not defined.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__investment_temporal_block","page":"Relationship Classes","title":"unit__investment_temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Sets the temporal resolution of investment decisions - overrides model__default_investment_temporal_block","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: temporal_block and unit","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"unit__investment_temporal_block is a two-dimensional relationship between a unit and a temporal_block. This relationship defines the temporal resolution and scope of a unit's investment decision. Note that in a decomposed investments problem with two model objects, one for the master problem model and another for the operations problem model, the link to the specific model is made indirectly through the model__temporal_block relationship. If a model__default_investment_temporal_block is specified and no unit__investment_temporal_block relationship is specified, the model__default_investment_temporal_block relationship will be used. Conversely if unit__investment_temporal_block is specified along with model__temporal_block, this will override model__default_investment_temporal_block for the specified unit.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"See also Investment Optimization","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__node__node","page":"Relationship Classes","title":"unit__node__node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Holds parameters spanning multiple unit_flow variables to and from multiple nodes.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and unit","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: fix_ratio_in_in_unit_flow, fix_ratio_in_out_unit_flow, fix_ratio_out_in_unit_flow, fix_ratio_out_out_unit_flow, fix_units_on_coefficient_in_in, fix_units_on_coefficient_in_out, fix_units_on_coefficient_out_in, fix_units_on_coefficient_out_out, max_ratio_in_in_unit_flow, max_ratio_in_out_unit_flow, max_ratio_out_in_unit_flow, max_ratio_out_out_unit_flow, max_units_on_coefficient_in_in, max_units_on_coefficient_in_out, max_units_on_coefficient_out_in, max_units_on_coefficient_out_out, min_ratio_in_in_unit_flow, min_ratio_in_out_unit_flow, min_ratio_out_in_unit_flow, min_ratio_out_out_unit_flow, min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, min_units_on_coefficient_out_in, min_units_on_coefficient_out_out, unit_idle_heat_rate, unit_incremental_heat_rate and unit_start_flow","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"While the relationships unit__to_node and unit__to_node take care of the automatic generation of the unit_flow variables, the unit__node__node relationships hold the information how the different commodity flows of a unit interact. Only through this relationship and the associated parameters, the topology of a unit, i.e. which intakes lead to which products etc., becomes unambiguous.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"In almost all cases, at least one of the ..._ratio_... parameters will be defined, e.g. to set a fixed ratio between outgoing and incoming commodity flows of unit (see also e.g. fix_ratio_out_in_unit_flow). Note that the parameters can also be defined on a relationship between groups of objects, e.g. to force a fixed ratio between a group of nodes. In the triggered constraints, this will lead to an aggregation of the individual unit flows.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__to_node","page":"Relationship Classes","title":"unit__to_node","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines the nodes the unit can output to, and holds most unit_flow variable specific parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node and unit","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: fix_nonspin_ramp_down_unit_flow, fix_nonspin_ramp_up_unit_flow, fix_nonspin_units_shut_down, fix_nonspin_units_started_up, fix_ramp_down_unit_flow, fix_ramp_up_unit_flow, fix_shut_down_unit_flow, fix_start_up_unit_flow, fix_unit_flow_op, fix_unit_flow, fuel_cost, graph_view_position, max_res_shutdown_ramp, max_res_startup_ramp, max_shutdown_ramp, max_startup_ramp, min_res_shutdown_ramp, min_res_startup_ramp, min_shutdown_ramp, min_startup_ramp, minimum_operating_point, operating_points, ramp_down_cost, ramp_down_limit, ramp_up_cost, ramp_up_limit, reserve_procurement_cost, unit_capacity, unit_conv_cap_to_flow and vom_cost","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The unit__to_node and unit__from_node unit relationships are core elements of SpineOpt. For each unit__to_node or unit__from_node, a unit_flow variable is automatically added to the model, i.e. a commodity flow of a unit to or from a specific node, respectively.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Various parameters can be defined on the unit__to_node relationship, in order to constrain the associated unit flows. In most cases a unit_capacity will be defined for an upper bound on the commodity flows. Apart from that, ramping abilities of a unit can be defined. For further details on ramps see Ramping and Reserves.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"To associate costs with a certain commodity flow, cost terms, such as fuel_costs and vom_costs, can be included for the unit__to_node relationship.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"It is important to note, that the parameters associated with the unit__to_node can be defined either for a specific node, or for a group of nodes. Grouping nodes for the described parameters will result in an aggregation of the unit flows for the triggered constraint, e.g. the definition of the unit_capacity on a group of nodes will result in an upper bound on the sum of all individual unit_flows.","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__to_node__user_constraint","page":"Relationship Classes","title":"unit__to_node__user_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which output unit_flows are included in the user_constraint, and holds their parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: node, unit and user_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: graph_view_position and unit_flow_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#unit__user_constraint","page":"Relationship Classes","title":"unit__user_constraint","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which units_on variables are included in the user_constraint, and holds their parameters.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: unit and user_constraint","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Parameters: units_invested_available_coefficient, units_invested_coefficient, units_on_coefficient and units_started_up_coefficient","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"TODO","category":"page"},{"location":"concept_reference/Relationship Classes/#units_on__stochastic_structure","page":"Relationship Classes","title":"units_on__stochastic_structure","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which specific stochastic_structure is used for the units_on variable of the unit. Only one stochastic_structure is permitted per unit.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: stochastic_structure and unit","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The units_on__stochastic_structure relationship defines the stochastic_structure used by the units_on variable. Essentially, this relationship permits defining a different stochastic_structure for the online decisions regarding the units_on variable, than what is used for the production unit_flow variables. A common use-case is e.g. using only one units_on variable across multiple stochastic_scenarios for the unit_flow variables. Note that only one units_on__stochastic_structure relationship can be defined per unit per model, as interpreted by the units_on__stochastic_structure and model__stochastic_structure relationships.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"The units_on__stochastic_structure relationship uses the model__default_stochastic_structure relationship if not specified.","category":"page"},{"location":"concept_reference/Relationship Classes/#units_on__temporal_block","page":"Relationship Classes","title":"units_on__temporal_block","text":"","category":"section"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Defines which specific temporal_blocks are used by the units_on variable of the unit.","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"Related Object Classes: temporal_block and unit","category":"page"},{"location":"concept_reference/Relationship Classes/","page":"Relationship Classes","title":"Relationship Classes","text":"units_on__temporal_block is a relationship linking the units_on variable of a unit to a specific temporal_block object. As such, this relationship will determine which temporal block governs the on- and offline status of the unit. The temporal block holds information on the temporal scope and resolution for which the variable should be optimized.  ","category":"page"},{"location":"concept_reference/has_state/","page":"-","title":"-","text":"The has_state parameter is simply a Bool flag for whether a node has a node_state variable. By default, it is set to false, so the nodes enforce instantaneous commodity balance according to the nodal balance and node injection constraints. If set to true, the node will have a node_state variable generated for it, allowing for commodity storage at the node. Note that you'll also have to specify a value for the state_coeff parameter, as otherwise the node_state variable has zero commodity capacity.","category":"page"},{"location":"concept_reference/unit__commodity/","page":"-","title":"-","text":"To impose a limit on the cumulative amount of commodity flows, the max_cum_in_unit_flow_bound can be imposed on a unit__commodity relationship. This can be very helpful, e.g. if a certain amount of emissions should not be surpased throughout the optimization.","category":"page"},{"location":"concept_reference/unit__commodity/","page":"-","title":"-","text":"Note that, next to the unit__commodity relationship, also the nodes connected to the units need to be associated with their corresponding commodities, see node__commodity.","category":"page"},{"location":"concept_reference/model/","page":"-","title":"-","text":"The model object holds general information about the optimization problem at hand. Firstly, the modelling horizon is specified on the model object, i.e. the scope of the optimization model, and if applicable the duration of the rolling window (see also model_start, model_end and roll_forward). Secondly, the model works as an overarching assembler - only through linking temporal_blocks and stochastic_structures to a model object via relationships, they become part of the optimization problem, and respectively linked nodes, connections and units. If desired the user can also specify defaults for temporals and stochastic via the designated default relationships (see e.g., model__default_temporal_block). In this case, the default temporal is populated for missing node__temporal_block relationships.  Lastly, the model object contains information about the algorithm used for solving the problem (see model_type).","category":"page"},{"location":"concept_reference/write_lodf_file/","page":"-","title":"-","text":"If this parameter value is set to true, a diagnostics file containing all the network line outage distributions factors in CSV format will be written to the current directory.","category":"page"},{"location":"concept_reference/storage_investment_cost/","page":"-","title":"-","text":"By defining the storage_investment_cost parameter for a specific node, a cost term will be added to the objective function whenever a storage investment is made during the current optimization window.","category":"page"},{"location":"concept_reference/connection__node__node/","page":"-","title":"-","text":"connection__node__node is a three-dimensional relationship between a connection, a node (node 1) and another node (node 2). connection__node__node infers a conversion and a direction with respect to that conversion. Node 1 is assumed to be the input node and node 2 is assumed to be the output node. For example, the fix_ratio_out_in_connection_flow parameter defined on connection__node__node relates the output connection_flow to node 2 to the intput connection_flow from node 1","category":"page"},{"location":"concept_reference/node_state_cap/","page":"-","title":"-","text":"The node_state_cap parameter represents the maximum allowed value for the node_state variable. Note that in order for a node to have a node_state variable in the first place, the has_state parameter must be set to true. However, if the node has storage investments enabled using the candidate_storages parameter, the node_state_cap parameter acts as a coefficient for the storages_invested_available variable. Essentially, with investments, the node_state_cap parameter represents storage capacity per storage investment.","category":"page"},{"location":"concept_reference/operating_points/","page":"-","title":"-","text":"If operating_points is defined as an array type on a certain unit__to_node or unit__from_node flow, the corresponding unit_flow flow variable is decomposed into a number of sub operating segment variables, unit_flow_op one for each operating segment, with an additional index, i to reference the specific operating segment. Each value in the array represents the upper bound of the operating segment, normalized on unit_capacity for the corresponding unit__to_node or unit__from_node flow. operating_points is used in conjunction with unit_incremental_heat_rate where the array dimension must match and is used to define the normalized operating point bounds for the corresponding incremental heat rate. operating_points is also used in conjunction with user_constraint where the array dimension must match any corresponding piecewise linear unit_flow_coefficient. Here operating_points is used also to define the normalized operating point bounds for the corresponding unit_flow_coefficients.","category":"page"},{"location":"concept_reference/operating_points/","page":"-","title":"-","text":"Note that operating_points is defined on a capacity-normalized basis and the values represent the upper bound of the corresponding operating segment variable. So if operating_points is specified as [0.5, 1], this creates two operating segments, one from zero to 50% of the corresponding unit_capacity and a second from 50% to 100% of the corresponding unit_capacity.","category":"page"},{"location":"concept_reference/tax_out_unit_flow/","page":"-","title":"-","text":"By defining the tax_out_unit_flow parameter for a specific node, a cost term will be added to the objective function to account the taxes associated with all unit_flow variables with direction from_node over the course of the operational dispatch during the current optimization window.","category":"page"},{"location":"concept_reference/model__default_temporal_block/","page":"-","title":"-","text":"The model__default_temporal_block relationship can be used to set a model-wide default for the node__temporal_block and units_on__temporal_block relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific node__temporal_block or units_on__temporal_block relationships take priority over the model__default_temporal_block relationship.","category":"page"},{"location":"concept_reference/connection_emergency_capacity/","page":"-","title":"-","text":"The connection_emergency_capacity parameter represents the maximum post-contingency flow on a monitored connection if ptdf and lodf based security constrained unit commitment is enabled (commodity_physics is set to [commodity_physics_lodf]).","category":"page"},{"location":"concept_reference/connection_emergency_capacity/","page":"-","title":"-","text":"If you set this value, make sure that you also set connection_monitored to true for the involved connection.","category":"page"},{"location":"concept_reference/unit_investment_variable_type_list/","page":"-","title":"-","text":"unit_investment_variable_type_list holds the possible values for the type of a unit's investment variable which may be chosen from integer, binary or continuous. ","category":"page"},{"location":"concept_reference/min_ratio_out_in_connection_flow/","page":"-","title":"-","text":"The definition of the min_ratio_out_in_connection_flow parameter triggers the generation of the constraint_min_ratio_out_in_connection_flow and sets a lower bound on the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the connection_flow variable from the first node in the connection__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/min_ratio_out_in_connection_flow/","page":"-","title":"-","text":"Note that the ratio can also be defined for connection__node__node relationships, where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows.","category":"page"},{"location":"concept_reference/min_ratio_out_in_connection_flow/","page":"-","title":"-","text":"To enforce e.g. a minimum ratio of 0.2 for a connection conn between its outgoing electricity flow to node commodity1 and its incoming flows from the node node commodity2, the min_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship conn__commodity1__commodity2.","category":"page"},{"location":"concept_reference/connection_flow_cost/","page":"-","title":"-","text":"By defining the connection_flow_cost parameter for a specific connection, a cost term will be added to the objective function that values all connection_flow variables associated with that connection during the current optimization window.","category":"page"},{"location":"concept_reference/commodity_lodf_tolerance/","page":"-","title":"-","text":"Given two connections, the line outage distribution factor (LODF) is the fraction of the pre-contingency flow on the first one, that will flow on the second after the contingency. commodity_lodf_tolerance is the minimum absolute value of the LODF that is considered meaningful. Any value below this tolerance (in absolute value) will be treated as zero.","category":"page"},{"location":"concept_reference/commodity_lodf_tolerance/","page":"-","title":"-","text":"The LODFs are used to model contingencies on some connections and their impact on some other connections. To model contingencies on a connection, set connection_contingency to true; to study the impact of such contingencies on another connection, set connection_monitored to true.","category":"page"},{"location":"concept_reference/commodity_lodf_tolerance/","page":"-","title":"-","text":"In addition, define a commodity with commodity_physics set to commodity_physics_lodf, and associate that commodity (via node__commodity) to both connections' nodes (given by connection__to_node and connection__from_node).","category":"page"},{"location":"concept_reference/roll_forward/","page":"-","title":"-","text":"This parameter defines how much the optimization window rolls forward in a rolling horizon optimization and should be expressed as a duration. In a rolling horizon optimization, a (small) part of the model is optimized at each iteration, after which the window rolls forward to optimize a different part. Overlap between consecutive optimization windows is possible. In the practical approaches presented in Temporal Framework, the rolling window optimization will be explained in more detail. The default value of this parameter is the entire model time horizon, which leads to a single optimization for the entire time horizon.","category":"page"},{"location":"concept_reference/write_mps_file_list/","page":"-","title":"-","text":"This parameter value list is deprecated and will be removed in a future version.","category":"page"},{"location":"concept_reference/write_mps_file_list/","page":"-","title":"-","text":"Houses the different values for the write_mps_file parameter. Possible values include write_mps_always, write\\_mps\\_on\\_no\\_solve, and write\\_mps\\_never.","category":"page"},{"location":"concept_reference/graph_view_position/","page":"-","title":"-","text":"The graph_view_position parameter can be used to fix the positions of various objects and relationships when plotted using the Spine Toolbox Graph View. If not defined, Spine Toolbox simply plots the element in question wherever it sees fit in the graph.","category":"page"},{"location":"concept_reference/model__stochastic_structure/","page":"-","title":"-","text":"The [model__stochastic_structure] relationship defines which stochastic_structures are active in which models. Essentially, this relationship allows for e.g. attributing multiple node__stochastic_structure relationships for a single node, and switching between them in different models. Any stochastic_structure in the model__default_stochastic_structure relationship is automatically assumed to be active in the connected model, so there's no need to include it in [model__stochastic_structure] separately.","category":"page"},{"location":"concept_reference/unit__from_node__unit_constraint/","page":"-","title":"-","text":"unit__from_node__user_constraint is a three-dimensional relationship between a unit, a node and a user_constraint. The relationship specifies that the unit_flow variable to the specified unit from the specified node is involved in the specified user_constraint. Parameters on this relationship generally apply to this specific unit_flow variable. For example the parameter unit_flow_coefficient defined on unit__from_node__user_constraint represents the coefficient on the specific unit_flow variable in the specified user_constraint","category":"page"},{"location":"advanced_concepts/powerflow/#ptdf-based-powerflow","page":"PTDF-Based Powerflow","title":"Power transfer distribution factors (PTDF) based DC power flow","text":"","category":"section"},{"location":"advanced_concepts/powerflow/","page":"PTDF-Based Powerflow","title":"PTDF-Based Powerflow","text":"There are two main methodologies for directly including DC powerflow in unit commitment/energy system models. One method is to directly include the bus voltage angles as variables in the model. This method is described in Nodal lossless DC Powerflow.","category":"page"},{"location":"advanced_concepts/powerflow/","page":"PTDF-Based Powerflow","title":"PTDF-Based Powerflow","text":"Here we discuss the method of using power transfer distribution factors (PTDF) for DC power flow and line outage distribution factors (lodf) for security constrained unit commitment.","category":"page"},{"location":"advanced_concepts/powerflow/#key-concepts-advanced-ptdf-DC","page":"PTDF-Based Powerflow","title":"Key concepts","text":"","category":"section"},{"location":"advanced_concepts/powerflow/","page":"PTDF-Based Powerflow","title":"PTDF-Based Powerflow","text":"ptdf: The power transfer distribution factors are a property of the network reactances and their derivation may be found here. ptdf(n, c) represents the fraction of an injection at node n that will flow on connection c. The flow on connection c is then the sum over all nodes of ptdf(n, c)*net_injection(c). The advantage of this method is that it introduces no additional variables into the problem and instead, introduces only one constraint for each connection whose flow we are interested in monitoring.\nlodf: Line outage distribution factors are a function of the network ptdfs and their derivation is also found here. lodf(c_contingency, c_monitored) represents the fraction of the pre-contingency flow on connection c_contingency that will flow on c_monitored if c_contingency is disconnected. Therefore, the post contingency flow on connection c_monitored is the pre_contingency flow plus lodf(c_contingency, c_monitored)\\*pre_contingency_flow(c_contingency)). Therefore, consideration of N contingencies on M monitored lines introduces N x M constraints into the model. Usually one wishes to contain this number and methods are given below to achieve this.\nDefining your network To identify the network for which ptdfs, lodfs and connection_flows will be calculated according to the ptdf method, one does the following:\nCreate node objects for each bus in the model.\nCreate connection objects representing each line of the network: For each connection specify the connection_reactance parameter and the connection_type parameter. Setting connection_type=connection_type_lossless_bidirectional simplifies the amount of data that needs to be specified for an eletrical network. See connection_type for more details   \nSet the connection__to_node and connection__from_node relationships to define the topology of each connection along with the connection_capacity parameter on one or both of these relationships.\nSet the connection_emergency_capacity parameter to define the post contingency rating if lodf-based N-1 security constraints are to be included\nCreate a commodity object and node__commodity relationships for all the nodes that comprise the electrical network for which PTDFs are to be calculated.\nSpecify the commodity_physics parameter for the commodity to :commodity_physics_ptdf if ptdf-based DC load flow is desired with no N-1 security constraints or to :commodity_physics_lodf if it is desired to include lodf-based N-1 security constraints\nTo identify the reference bus(node) specify the node_opf_type parameter for the appropriate node with the value node_opf_type_reference.\nControlling problem size","category":"page"},{"location":"advanced_concepts/powerflow/","page":"PTDF-Based Powerflow","title":"PTDF-Based Powerflow","text":"The lines to be monitored are specified by setting the connection_monitored property for each connection for which a flow constraint is to be generated\nThe contingencies to be considered are specified by setting the connection_contingency property for the appropriate connections. For N contingencies and M monitored lines, N x M constraints will be generated.\nIf the lodf(c_contingency, c_monitored) is very small, it means the outage of c_contingency has a small impact on the flow on c_monitoredand there is little point in including this constraint in the model. This can be achieved by setting the commodity_lodf_tolerance commodity parameter. Contingency / Monotired line combinations with lodfs below this value will be ignored, reducing the size of the model.\nIf ptdf(n, c) is very small, it means an injection at n has a small impact on the flow on c and there is little point in considering it. This can be achieved by setting the commodity_ptdf_threshold commodity parameter. Node / Monotired line combinations with ptdfs below this value will be ignored, reducing the number of coefficients in the model.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/#pressure-driven-gas-transfer","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"","category":"section"},{"location":"advanced_concepts/pressure_driven_gas_transfer/","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"The generic formulation of SpineOpt is based on a trade based model. However, network physics can be different depending on the traded commodity. This chapter specifically addresses the use of pressure driven gas transfer models and enabling linepack flexibility in SpineOpt. To this date, investments in pressure driven pipelines are not yet supported within SpineOpt. The use of multiple feed-in nodes, e.g. to represent multiple commodity flows through a pipeline is not yet supported.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"For the representation of pressure driven gas transfer, we use the MILP formulation, as described in Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling. Here, the non-linearities associated with the Weymouth equation are convexified through an outer approximation of the Weymouth equation through fixed pressure points.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/#key-concepts-advanced-gas","page":"Pressure driven gas transfer","title":"Key concept","text":"","category":"section"},{"location":"advanced_concepts/pressure_driven_gas_transfer/","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"Here, we briefly describe the key objects and relationships required to model pressure driven gas transfers in SpineOpt.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"connection: A connection represents the gas pipeline being modelled. Usually the direction of flow is not known a priory. To ensure that the flow through the gas pipeline is unidirectional, the parameter has_binary_gas_flow needs to be set to true.\nnode: Nodes with different characteristics are used for the representation of pressure driven gas transfer.\nFor each connection, there will be two nodes representing the start and end point of the pipeline. Associated with these nodes are the following parameters: the has_pressure parameter, which needs to be set to true, in order to create the variable node_pressure; the max_node_pressure and min_node_pressure to constrain the pressure variable.\nTo leverage linepack flexibility, a third node is introduced representing the linepack storage of the pipeline. To trigger the storage linepack and hence, node_state variables, the has_state parameter needs to be set to true.\nconnection__to_node and connection__from_node To enable flows through the pipeline and into the linepack storage, each node has to have both these relationships in common with the connection pipeline. These relationships will trigger the generation of connection_flow variables in all possible directions.\nconnection__node__node This relationship is key to the pressure driven gas transfer, holding the information about the pipeline characteristics and bringing the elements into interaction.\nThe parameter connection_linepack_constant holds the linepack constant and triggers the generation of the line pack storage constraint. Note that the first node should be the linepack storage node, while the second node should be a node_group of both, the start and the end node of the pipeline.\nThe linearization of the Weymouth equation through outer approximation relies on the use of fixed pressure points. For this purpose, the two parameters fixed_pressure_constant_1 and fixed_pressure_constant_0 hold the fixed pressure constants and trigger the generation of the constraint_fix_node_pressure_point. The constraint introduces the relationship between pressure and gas flows. Note, that the pressure constants should be entered in a way, that the first node represents the origin node, the second node the destination node. Each connection should have a connection__node__node to each combination of its start and end nodes (and associated parameters). (See Schwele - Coordination of Power and Natural Gas Systems: Convexification Approaches for Linepack Modeling)\nBy default, pipelines are considered to be passive. However, a compression station between two pipeline pressure nodes can be represented by defining a compression_factor. The relationship should be defined in such a manner, that the first node represents the sending node, the second node represents the receiving node, which pressure is equal or smaller to the pressure at the sending node times the compression factor.\nLastly, to ensure the balance between incoming/outgoing flows and flows into the linepack, the ratio between the flows need to be fixed. The average incoming flows of the node group (of the pressure start and end nodes) have to equal the flows into the linepack storage, and vice versa. Therefore, the fix_ratio_out_in_connection_flow needs to be set to a value (typically 1) for the (pressure group, linepack storage) node pair, and for the (linepack storage, pressure group) node pair.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"A gas pipeline and its connected nodes are illustrated below. A complete mathematical formulation can be found here.","category":"page"},{"location":"advanced_concepts/pressure_driven_gas_transfer/","page":"Pressure driven gas transfer","title":"Pressure driven gas transfer","text":"(Image: Illustration of gas pipeline)","category":"page"},{"location":"concept_reference/block_start/","page":"-","title":"-","text":"Indicates the start of this temporal block. The main use of this parameter is to create an offset from the model start. The default value is equal to a duration of 0. It is useful to distinguish here between two cases: a single solve, or a rolling window optimization.","category":"page"},{"location":"concept_reference/block_start/","page":"-","title":"-","text":"single solve When a Date time value is chosen, this is directly the start of the optimization for this temporal block. When a duration is chosen, it is added to the model_start to obtain the start of this temporal_block. In the case of a duration, the chosen value directly marks the offset of the optimization with respect to the model_start. The default value for this parameter is the model_start.","category":"page"},{"location":"concept_reference/block_start/","page":"-","title":"-","text":"rolling window optimization To create a temporal block that is rolling along with the optimization window, a rolling temporal block, a duration value should be chosen. The temporal block_start will again mark the offset of the optimization start but now with respect to the start of each optimization window.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_out_in/","page":"-","title":"-","text":"The min_units_on_coefficient_out_in parameter is an optional coefficient in the unit output-input ratio constraint controlled by the min_ratio_out_in_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_out_in/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_out_in and fix_units_on_coefficient_out_in.","category":"page"},{"location":"concept_reference/max_ratio_out_in_connection_flow/","page":"-","title":"-","text":"The definition of the max_ratio_out_in_connection_flow parameter triggers the generation of the constraint_max_ratio_out_in_connection_flow and sets an upper bound on the ratio between outgoing and incoming flows of a connection. The parameter is defined on the relationship class connection__node__node, where the first node (or group of nodes) in this relationship represents the to_node, i.e. the outgoing flow from the connection, and the second node (or group of nodes), represents the from_node, i.e. the incoming flows to the connection. The ratio parameter is interpreted such that it constrains the ratio of out over in, where out is the connection_flow variable from the first node in the connection__node__node relationship in a left-to-right reading order.","category":"page"},{"location":"concept_reference/max_ratio_out_in_connection_flow/","page":"-","title":"-","text":"To enforce e.g. a maximum ratio of 0.8 for a connection conn between its outgoing electricity flow to node commodity1 and its incoming flows from the node node commodity2, the max_ratio_out_in_connection_flow parameter would be set to 0.8 for the relationship conn__commodity1__commodity2.","category":"page"},{"location":"concept_reference/max_ratio_out_in_connection_flow/","page":"-","title":"-","text":"Note that the ratio can also be defined for connection__node__node relationships where one or both of the nodes correspond to node groups in order to impose a ratio on aggregated connection flows.","category":"page"},{"location":"concept_reference/boolean_value_list/","page":"-","title":"-","text":"A list of boolean values (True or False).","category":"page"},{"location":"concept_reference/frac_state_loss/","page":"-","title":"-","text":"The frac_state_loss parameter allows setting self-discharge losses for nodes with the node_state variables enabled using the has_state variable. Effectively, the frac_state_loss parameter acts as a coefficient on the node_state variable in the node injection constraint, imposing losses for the node. In simple cases, storage losses are typically fractional, e.g. a frac_state_loss parameter value of 0.01 would represent 1% of node_state lost per unit of time. However, a more general definition of what the frac_state_loss parameter represents in SpineOpt would be loss power per unit of node_state.","category":"page"},{"location":"concept_reference/connections_invested_avaiable_coefficient/","page":"-","title":"-","text":"The connections_invested_available_coefficient is an optional parameter that can be used to include the connections_invested_available variable in a user_constraint via the connection__user_constraint relationship. Essentially, connections_invested_available_coefficient appears as a coefficient for the connections_invested_available variable in the user constraint.","category":"page"},{"location":"concept_reference/unit_capacity/","page":"-","title":"-","text":"To set an upper bound on the commodity flow of a unit in a certain direction, the unit_capacity constraint needs to be defined on a unit__to_node or unit__from_node relationship. By defining the parameter, the unit_flow variables to or from a node or a group of nodes will be constrained by the capacity constraint.","category":"page"},{"location":"concept_reference/unit_capacity/","page":"-","title":"-","text":"Note that if the unit_capacity parameter is defined on a node group, the sum of all unit_flows within the specified node group will be constrained by the unit_capacity.","category":"page"},{"location":"#Introduction","page":"Introduction","title":"Introduction","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"SpineOpt.jl is an integrated energy systems optimization model created as part of the  Spine project, striving towards adaptability for a multitude of modelling purposes. The data-driven model structure allows for highly customizable energy system descriptions, as well as flexible temporal and stochastic structures, without the need to alter the model source code directly. The methodology is based on mixed-integer linear programming (MILP), and SpineOpt relies on JuMP.jl for interfacing with the different solvers.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"While, in principle, it is possible to run SpineOpt by itself, it has been designed to be used through the Spine toolbox, and take maximum advantage of the data and modelling workflow management tools therein. Thus, we highly recommend installing Spine toolbox as well, as outlined in the Installation guide.","category":"page"},{"location":"#Contents","page":"Introduction","title":"Contents","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"In order to make it easier for you to familiarize yourself with the documentation, here's a list of all the different chapters, as well as descriptions of what they're about.","category":"page"},{"location":"#Getting-Started","page":"Introduction","title":"Getting Started","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"As the name implies, this chapter contains guides for starting to use SpineOpt.jl for the first time. The Installation section contains a step-by-step guide for how to install SpineOpt.jl and Spine Toolbox on your computer. The Setting up a workflow for SpineOpt in Spine Toolbox section explains how to set up and run SpineOpt.jl from Spine Toolbox. The Creating Your Own Model section explains how to create a new model from scratch. This includes a list of the necessary Object Classes and Relationship Classes, but for more information, you will probably need to consult the Concept Reference chapter.","category":"page"},{"location":"#Concept-Reference","page":"Introduction","title":"Concept Reference","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This chapter lists and explains all the important data and model structure related concepts to understand in SpineOpt.jl. For a mathematical modelling point of view, see the Mathematical Formulation chapter instead. The Basics of the model structure section briefly explains the general purpose of the most important concepts, like Object Classes and Relationship Classes. Meanwhile, the Object Classes, Relationship Classes, Parameters, and Parameter Value Lists sections contain detailed explanations of each and every aspect of SpineOpt.jl, organized into the respective sections for clarity.","category":"page"},{"location":"#Mathematical-Formulation","page":"Introduction","title":"Mathematical Formulation","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This chapter provides the mathematical view of SpineOpt.jl, as some of the methodology-related aspects of the model are more easily understood as math than Julia code. The Variables section explains the purpose of each variable in the model, as well as how the variables are related to the different Object Classes and Relationship Classes. The Constraints section contains the mathematical formulation of each constraint, as well as explanations to their purpose and how they are controlled via different Parameters. Finally, the Objective section explains the default objective function used in SpineOpt.jl.","category":"page"},{"location":"#Advanced-Concepts","page":"Introduction","title":"Advanced Concepts","text":"","category":"section"},{"location":"","page":"Introduction","title":"Introduction","text":"This chapter explains some of the more complicated aspects of SpineOpt.jl in more detail, hopefully making it easier for you to better understand and apply them in your own modelling. The first few sections focus on aspects of SpineOpt.jl that most users are likely to use, or which are more or less required to understand for advanced use. The Temporal Framework section explains how defining time works in SpineOpt.jl, and how it can be used for different purposes. The Stochastic Framework section details how different stochastic structures can be defined, how they interact with each other, and how this impacts writing Constraints in SpineOpt.jl. The Unit commitment section explains how clustered unit-commitment is defined, while the Ramping and Reserves section explains how to enable these operational details in your model. The Investment Optimization section explains how to include investment variables in your models, while the User Constraints section details how to include generic data-driven custom constraints.","category":"page"},{"location":"","page":"Introduction","title":"Introduction","text":"The last few sections focus on highly specialized use-cases for SpineOpt.jl, which are unlikely to be relevant for simple modelling tasks. The Decomposition section explains the Benders decomposition implementation included in SpineOpt.jl, as well as how to use it. The remaining sections, namely PTDF-Based Powerflow, Pressure driven gas transfer, Lossless nodal DC power flows, and Representative days with seasonal storages, explain various use-case specific modelling approaches supported by SpineOpt.jl.","category":"page"},{"location":"concept_reference/output/","page":"-","title":"-","text":"An output is essentially a handle for a SpineOpt variable and Objective function to be included in a report and written into an output database. Typically, e.g. the unit_flow variables are desired as output from most models, so creating an output object called unit_flow allows one to designate it as something to be written in the desired report. Note that unless appropriate model__report and report__output relationships are defined, SpineOpt doesn't write any output!","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Ramping-and-Reserves","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"To enable the representation of units with a high level of technical detail, the ramping ability of units can be constrained in SpineOpt. This means that the user has the freedom to impose restrictions on the change in output of units between consecutive timesteps, for online (spinning) units, units starting up and units shutting down. In this section, the concept of ramps in SpineOpt will be introduced. Furthermore, the use of reserves will be explained.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Relevant-objects,-relationships-and-parameters","page":"Ramping and Reserves","title":"Relevant objects, relationships and parameters","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"Everything that is related to ramping is defined in parameters of either the unit__to_node, unit__from_node, or unit__to_node_group relationship. Generally speaking, the ramping constraints will impose restrictions on the change in the unit_flow variable between two consecutive timesteps.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"All parameters that limit the ramping abilities of a unit are expressed as a fraction of the unit capacity. This means that a value of 1 indicates the full capacity of a unit.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"The discussion here will be kept conceptual, for the mathematical formulation the reader is referred to the Ramping and reserve constraints","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Constraining-spinning-ramps","page":"Ramping and Reserves","title":"Constraining spinning ramps","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"unit_capacity: limit the maximum value of the unit_flow variable for a unit which is currently online. Inclusion of this parameter will trigger the creation of the Define unit/technology capacity constraint.\nramp_up_limit : limit the maximum increase in the unit_flow variable between two consecutive timesteps for which the unit is online. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on spinning upwards ramp_up\nramp_down_limit : limit the maximum decrease in the unit_flow variable between two consecutive timesteps for which the unit is online. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on spinning downward ramps","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"ramp_up_cost : cost associated with upward ramping\nramp_down_cost : cost associated with downward ramping","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Constraining-shutdown-ramps","page":"Ramping and Reserves","title":"Constraining shutdown ramps","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_shutdown_ramp : limit the maximum of the unit_flow variable for the timestep right before a shutdown. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on maximum downward shut down ramps\nmin_shutdown_ramp : limit the minimum of the unit_flow variable for the timestep right before a shutdown. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on minimum downward shut down ramps","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Constraining-startup-ramps","page":"Ramping and Reserves","title":"Constraining startup ramps","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_startup_ramp : limit the maximum of the unit_flow variable for the timestep right after a start-up. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on maximum upward start up ramp_up\nmin_startup_ramp : limit the minimum of the unit_flow variable for the timestep right after a start-up. The parameter is given as a fraction of the unit_capacity parameter. Inclusion of this parameter will trigger the creation of the Constraint on minimum upward start up ramp_up","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#General-principle-and-example-use-cases","page":"Ramping and Reserves","title":"General principle and example use cases","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"The general principle of the Spine modelling ramping constraints is that all of these parameters can be defined separately for each unit. This allows the user to incorporate different units (which can either represent a single unit or a technology type) with different flexibility characteristics.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"It should be noted that it is perfectly possible to omit all of the constraining parameters mentioned above. However, once either of the ramping parameters is defined, it is necessary to also assign values to the other parameters. E.g. if a user only wants to restrict the spinning ramp up capability of a unit, one also has to assign values to the max_startup_ramp, min_Shutdown_Ramp etc.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Illustrative-examples","page":"Ramping and Reserves","title":"Illustrative examples","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#Step-1:-Simple-case-of-unrestricted-unit","page":"Ramping and Reserves","title":"Step 1: Simple case of unrestricted unit","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"When none of the ramping parameters mentioned above are defined, the unit is considered to have full ramping flexibility. This means that in any given timestep, its output can be any value between 0 and its capacity, regardless of what the output of the unit was in the previous timestep, and regardless of the on- or offline status or the unit in the previous timestep. Provided that this does not conflict with the Unit commitment restrictions that are defined for this unit. Parameter values for a unit__node relationship are illustratively given below.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_shutdown_ramp  : 1\nmin_shutdown_ramp  : 0\nmax_start_up_ramp  : 1\nmin_start_up_ramp  : 0\nramp_up_limit      : 1\nramp_down_limit    : 1\nunit_capacity      : 200","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Step-2:-Spinning-ramp-restriction","page":"Ramping and Reserves","title":"Step 2: Spinning ramp restriction","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"A unit which is only restricted in spinning ramping can be created by changing the ramp_up/down_limit parameters:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"ramp_up_limit      : 0.2\nramp_down_limit    : 0.4","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"This parameter choice implies that the unit's output between two consecutive timesteps can change with no more than 02  * 200 and no less than 04 * 200. For example, when the unit is running at an output of 100 in some timestep t, its output for the next timestep must be somewhere in the interval 20140. Unless it shuts down completely.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Step-3:-Shutdown-restrictions","page":"Ramping and Reserves","title":"Step 3: Shutdown restrictions","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"By changing the parameter max_shutdown_ramp in the previous example, an additional restriction is imposed on the maximum output of the unit from which it can go offline.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_shutdown_ramp      : 0.5\nmin_shutdown_ramp    :   0.3","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"When this unit goes offline in a given timestep t+1, the output of the unit must be below 05*200 = 100 in the timestep t before that.  Similarly, the parameter min_shutdown_ramp can be used to impose a minimum output value in the timestep  before a shutdown. For example, a value of 03 in this example would mean that the unit can not be running below an output of 60 in timestep t.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Step-4:-Startup-restrictions","page":"Ramping and Reserves","title":"Step 4: Startup restrictions","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"The startup restrictions are very similar to the shutdown restrictions, but of course apply to units that are starting up. Consider for example the same unit as in the example above, but now with a max_start_up_ramp equal to 04 and min_start_up_ramp equal to 02:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_start_up_ramp      : 0.4\nmin_start_up_ramp    :   0.2","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"When the unit is offline in timestep t and comes online in timestep t+1, its output in timestep t+1 will be restricted to the interval 4080.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Reserve-concept","page":"Ramping and Reserves","title":"Reserve concept","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"To include a requirement of reserve provision in a model, SpineOpt offers the possibility of creating reserve nodes. Of course reserve provision is different from regular operation, because the reserved capacity does not actually get activated. In this section, we will take a look at the things that are particular for a reserve node.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Defining-a-reserve-node","page":"Ramping and Reserves","title":"Defining a reserve node","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"To define a reserve node, the following parameters have to be defined for the relevant node:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"is_reserve_node  : this boolean parameter indicates that this node is a reserve node.\nupward_reserve   : this boolean parameter indicates that the demand for reserve provision of this node concerns upward reserves.\ndownward_reserve  : this boolean parameter indicates that the demand for reserve provision of this node concerns downward reserves.\nreserve_procurement_cost: (optional) this parameter indicates the procurement cost of a unit for a certain reserve product and can be define on a unit__to_node or unit__from_node relationship.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Defining-a-node-group","page":"Ramping and Reserves","title":"Defining a node group","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"SpineOpt allows the user to constrain ramping abilities of units that are linked to multiple nodes by defining node groups. This is especially relevant for reserve provision because a unit that provides reserves is linked to a regular, as well as a reserve node. It is then possible to constrain the unit's ramping for the combination of regular operation and reserve provision.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"Since reserve provision in fact literally reserves part of the capacity of a unit, the demand of the reserve node will be subtracted from the part that is available for regular operation. The section below will discuss how this works in SpineOpt by means of an example.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"Since the demand of the nodes is defined on the individual node level (and the node group has no demand), the balance type of the group node should be set to balance_type_none.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Ramping-constraints-on-a-node-group-with-one-reserve-node","page":"Ramping and Reserves","title":"Ramping constraints on a node group with one reserve node","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/#Reserves-step-1:-simple-case-of-unrestricted-unit","page":"Ramping and Reserves","title":"Reserves step 1: simple case of unrestricted unit","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"Let's assume that we have one unit and two nodes in a model, one for reserves and one for regular demand. The unit is then linked by the unit__to_node relationships to each node individually, and on top of that, it is linked to a node group containing both nodes.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"The ramping of the unit can now be constrained by defining the same parameters as before, but now for the node group. As before, the simplest case is a unit that is only restricted by its capacity:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_shutdown_ramp  : 1\nmin_shutdown_ramp  : 0\nmax_start_up_ramp  : 1\nmin_start_up_ramp  : 0\nramp_up_limit      : 1\nramp_down_limit    : 1\nunit_capacity      : 200","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"The capacity restriction now implies that the sum of the reserve demand and regular demand cannot exceed the capacity of the unit. For example: when the reserve node has a demand of 10 in timestep t, the unit_flow variable to the regular node must be smaller than or equal to 190.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Reserves-step-2:-Spinning-ramp-restriction","page":"Ramping and Reserves","title":"Reserves step 2: Spinning ramp restriction","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"The unit can be restricted only in spinning ramping, as in the previous example, by defining the ramp_up/down_limit parameters in the unit__to_node relationship for the node group:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"ramp_up_limit      : 0.2\nramp_down_limit    : 0.4","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"This parameter choice implies that the unit's flow to the regular demand node between two consecutive timesteps can change with no more than 02  * 200 - upward_reserve_demand and no less than 04 * 200 - downward_reserve_demand. For example, when the unit is running at an output of 100 in some timestep t, and there is an upward reserve demand of 10 its output for the next timestep must be somewhere in the interval 20130.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"It can be seen in this example that the demand for reserves is subtracted from both the generation capacity, and the ramping capacity of the unit that is available for regular operation. This stems from the fact that in providing reserve capacity, the unit is expected to be able to provide the demanded reserve within one timestep.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Reserves-Step-3:-Non-spinning-reserves","page":"Ramping and Reserves","title":"Reserves Step 3: Non-spinning reserves","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"Units can also be allowed to provide non-spinning reserves, through shutdowns and startups. This can be done by using the following parameters in the unit__to_node relationship for the reserve node :  ","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_res_startup_ramp\nmin_res_startup_ramp","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_res_shutdown_ramp\nmin_res_shutdown_ramp","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"unit_capacity","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"These parameters are constraining reserve provision in exactly the same way as their equivalents for regular operation. Note that it is now necessary to define a capacity of the unit with respect to the reserve node. The ramping parameters will then be interpreted as fractions of this specific capacity. The unit's overall capacity can be different than its capacity for reserve provision.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"A unit which can provide both spinning and non-spinning reserves can be defined as follows:","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"Parameters to be defined for unit to node group relationship","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_shutdown_ramp  : 1\nmin_shutdown_ramp  : 0\nmax_start_up_ramp  : 1\nmin_start_up_ramp  : 0\nramp_up_limit      : 0.2\nramp_down_limit    : 0.4\nunit_capacity      : 200","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"Parameters to be defined for unit to reserve node relationship","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"max_res_startup_ramp: 0.5\nmin_res_startup_ramp: 0.1\nunit_capacity: 150","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"The spinning reserve and ramping restrictions now remain the same as above, but on top of that the unit is able to provide non-spinning upward reserves when it is offline. In this particular example, the contribution of the offline unit to upward reserves can be anything in the interval [15,75].","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/#Using-node_groups-for-both-combined-and-individual-restrictions","page":"Ramping and Reserves","title":"Using node_groups for both combined and individual restrictions","text":"","category":"section"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"It can be seen from the example above that when a node group is defined, ramping restrictions can be imposed both on the group level (thus for the unit as a whole) as well as for the individual nodes. If, for example a ramp-up-limit is defined for the node group, the sum of upward ramping of the two nodes will be restricted by this parameter, but it is still possible to limit the individual flows to the nodes as well. We will now discuss an example of this for the ramp_up_limit, but this also holds for other parameters.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"Let's continue with the example above, where an online unit is capable of ramping up by 20% of its capacity and down by 40%. We might want to impose tighter restrictions for upward reserve provision than the ramping in overall operation (e.g. because the reserved capacity has to be available in a shorter time than the duration_unit). One can then simply define an additional parameter for the unit to reserve node relationship as follows.","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"ramp_up_limit  : 0.15","category":"page"},{"location":"advanced_concepts/ramping_and_reserves/","page":"Ramping and Reserves","title":"Ramping and Reserves","text":"Which now restricts the spinning upward ramping provision of the unit to 15% of its capacity, as defined for the reserve node. In this case, the change in the unit's flow to the regular demand node between two consecutive timesteps is still limited to the interval 02  * 200 - upward_reserve_demand 04 * 200 - downward_reserve_demand. But the upward reserves that it can provide has an upper bound of `150 * 015.","category":"page"},{"location":"concept_reference/connection_conv_cap_to_flow/","page":"-","title":"-","text":"The connection_conv_cap_to_flow can be used to perform the conversion between the measurement unit of the connection_capacity to the measurement unit of the connection_flow variable. The default of this parameter is 1, i.e. assuming that both are given in the same measurement unit.","category":"page"},{"location":"concept_reference/max_voltage_angle/","page":"-","title":"-","text":"If a node has a node_voltage_angle variable (see also the parameter has_voltage_angle and this chapter), an upper bound on the voltage angle can be introduced through the max_voltage_angle parameter, which triggers the generation of the maximum node voltage angle constraint.","category":"page"},{"location":"concept_reference/stochastic_structure/","page":"-","title":"-","text":"The stochastic_structure is the key component of the scenario-based Stochastic Framework in SpineOpt.jl, and essentially represents a group of stochastic_scenarios with set Parameters. The stochastic_structure__stochastic_scenario relationship defines which stochastic_scenarios are included in which stochastic_structures, and the weight_relative_to_parents and stochastic_scenario_end Parameters define the exact shape and impact of the stochastic_structure, along with the parent_stochastic_scenario__child_stochastic_scenario relationship.","category":"page"},{"location":"concept_reference/stochastic_structure/","page":"-","title":"-","text":"The main reason as to why stochastic_structures are so important is, that they act as handles connecting the Stochastic Framework to the modelled system. This is handled using the Structural relationship classes e.g. node__stochastic_structure, which define the stochastic_structure applied to each object describing the modelled system. Connecting each system object to the appropriate stochastic_structure individually can be a bit bothersome at times, so there are also a number of convenience Meta relationship classes like the model__default_stochastic_structure, which allow setting model-wide defaults to be used whenever specific definitions are missing.","category":"page"},{"location":"concept_reference/connections_invested_coefficient/","page":"-","title":"-","text":"The connections_invested_coefficient is an optional parameter that can be used to include the connections_invested variable in a user_constraint via the connection__user_constraint relationship. Essentially, connections_invested_coefficient appears as a coefficient for the connections_invested variable in the user constraint.","category":"page"},{"location":"concept_reference/connection_flow_delay/","page":"-","title":"-","text":"The connection_flow_delay parameter denotes the amount of time that it takes for the flow to go through a connection. In other words, the flow that enters the connection is only seen at the other side after connection_flow_delay units of time.","category":"page"},{"location":"concept_reference/constraint_sense_list/","page":"-","title":"-","text":"The constraint_sense_list parameter value list contains the possible values for the constraint_sense parameter.","category":"page"},{"location":"concept_reference/min_res_startup_ramp/","page":"-","title":"-","text":"A unit can provide spinning and nonspinning reserves to a reserve node. These reserves can be either upward_reserve or downward_reserve. Nonspinning upward reserves are provided to an upward_reserve node by contracted offline units holding available to startup. If a unit is scheduled to provide nonspinning reserve, a limit on the minimum amount of reserves provided can be imposed by defining the parameter min_res_startup_ramp on a unit__to_node relationship, which triggers the constraint on minimum upward nonspinning reserve provision. The parameter min_res_startup_ramp is given as a fraction of the unit_capacity of the corresponding unit__to_node relationship.","category":"page"},{"location":"concept_reference/min_res_startup_ramp/","page":"-","title":"-","text":"Note that to include the provision of nonspinning upward reserves, the parameter max_res_startup_ramp needs to be defined on the corresponding unit__to_node relationship, which triggers the generation of the variables nonspin_units_started_up and nonspin_ramp_up_unit_flow.","category":"page"},{"location":"concept_reference/min_res_startup_ramp/","page":"-","title":"-","text":"A detailed description of the usage of ramps and reserves is given in the chapter Ramping and Reserves. The chapter Ramping and reserve constraints in the Mathematical Formulation presents the equations related to ramps and reserves.","category":"page"},{"location":"concept_reference/parent_stochastic_scenario__child_stochastic_scenario/","page":"-","title":"-","text":"The parent_stochastic_scenario__child_stochastic_scenario relationship defines how the individual stochastic_scenarios are related to each other, forming what is referred to as the stochastic direct acyclic graph (DAG) in the Stochastic Framework section. It acts as a sort of basis for the stochastic_structures, but doesn't contain any Parameters necessary for describing how it relates to the Temporal Framework or the Objective function.","category":"page"},{"location":"concept_reference/parent_stochastic_scenario__child_stochastic_scenario/","page":"-","title":"-","text":"The parent_stochastic_scenario__child_stochastic_scenario relationship and the stochastic DAG it forms are crucial for Constraint generation with stochastic path indexing. Every finite stochastic DAG has a limited number of unique ways of traversing it, called full stochastic paths, which are used when determining how many different constraints need to be generated over time periods where stochastic_structures branch or converge, or when generating constraints involving different stochastic_structures. See the Stochastic Framework section for more information.","category":"page"},{"location":"concept_reference/connection_linepack_constant/","page":"-","title":"-","text":"The linepack constant is a physical property of a connection representing a pipeline and holds information on how the linepack flexibility relates to pressures of the adjacent nodes. If, and only if, this parameter is defined, the linepack flexibility of a pipeline can be modelled. The existence of the parameter triggers the generation of the constraint on line pack storage. The connection_linepack_constant should always be defined on the tuple (connection pipeline, linepack storage node, node group (containing both pressure nodes, i.e. start and end of the pipeline)). See also.","category":"page"},{"location":"concept_reference/temporal_block/","page":"-","title":"-","text":"A temporal block defines the temporal properties of the optimization that is to be solved in the current window. It is the key building block of the Temporal Framework. Most importantly, it holds the necessary information about the resolution and horizon of the optimization. A single model can have multiple temporal blocks, which is one of the main sources of temporal flexibility in Spine: by linking different parts of the model to different temporal blocks, a single model can contain aspects that are solved with different temporal resolutions or time horizons.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_out_out/","page":"-","title":"-","text":"The min_units_on_coefficient_out_out parameter is an optional coefficient in the unit output-output ratio constraint controlled by the min_ratio_out_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_out_out/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_in_out, and min_units_on_coefficient_out_in, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g.  max_units_on_coefficient_out_out and fix_units_on_coefficient_out_out.","category":"page"},{"location":"concept_reference/fix_ratio_in_out_unit_flow/","page":"-","title":"-","text":"The definition of the fix_ratio_in_out_unit_flow parameter triggers the generation of the constraint_fix_ratio_in_out_unit_flow and fixes the ratio between incoming and outgoing flows of a unit. The parameter is defined on the relationship class unit__node__node, where the first node (or group of nodes) in this relationship represents the from_node,i i.e. the incoming flows to the unit, and the second node (or group of nodes), represents the to_node i.e. the outgoing flow from the unit. The ratio parameter is interpreted such that it constrains the ratio of in over out, where in is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right order.","category":"page"},{"location":"concept_reference/fix_ratio_in_out_unit_flow/","page":"-","title":"-","text":"To enforce e.g. a fixed ratio of 1.4 for a unit u between its incoming gas flow from the node ng and its outgoing flows to the node group el_heat (consisting of the two nodes el and heat), the fix_ratio_in_out_unit_flow parameter would be set to 1.4 for the relationship u__ng__el_heat.","category":"page"},{"location":"concept_reference/right_hand_side/","page":"-","title":"-","text":"Used to specify the right-hand-side, constant term in a user_constraint. See also user_constraint.","category":"page"},{"location":"concept_reference/model__temporal_block/","page":"-","title":"-","text":"The model__temporal_block relationship is used to determine which temporal_blocks are included in a specific model. Note that defining this relationship does not yet imply that any element of the model will be governed by the specified temporal_block, for this to happen additional relationships have to be defined such as the model__default_temporal_block relationship.","category":"page"},{"location":"concept_reference/unit_incremental_heat_rate/","page":"-","title":"-","text":"Used to implement simple or piecewise linear incremental heat rate functions. Used in the constraint unit_pw_heat_rate - the input fuel flow at node 1 is the sum of the electrical MW output at node 2 times the incremental heat rate over all heat rate segments, plus the unit_idle_heat_rate. The units are detmerined by the data, but generally, incremental heat rates are given in GJ/MWh. Note that the formulation assumes a convex, monitonically increasing heat rate function. The formulation relies on optimality to load the heat rate segments in the correct order and no additional integer variables are created to enforce the correct loading order. The heat rate segment MW operating points are defined by operating_points.","category":"page"},{"location":"concept_reference/unit_incremental_heat_rate/","page":"-","title":"-","text":"To implement a simple incremental heat rate function,unit_incremental_heat_rate should be given as a simple scalar representing the incremental heat rate over the entire operating range of the unit. To implement a piecewise linear heat rate function, unit_incremental_heat_rate should be specified as an array type. It is then used in conjunction with the unit parameter operating_points which should also be defined as an array type of equal dimension. When defined as an array type unit_incremental_heat_rate[i] is the effective incremental heat rate between operating_points [i-1] (or zero if i=1) and operating_points[i]. Note that operating_points is defined on a capacity-normalized basis so if operating_points is specified as [0.5, 1], this creates two operating segments, one from zero to 50% of the corresponding unit_capacity and a second from 50% to 100% of the corresponding unit_capacity.","category":"page"},{"location":"advanced_concepts/Lossless_DC_power_flow/#Lossless-nodal-DC-power-flows","page":"Lossless nodal DC power flows","title":"Lossless nodal DC power flows","text":"","category":"section"},{"location":"advanced_concepts/Lossless_DC_power_flow/","page":"Lossless nodal DC power flows","title":"Lossless nodal DC power flows","text":"Currently, there are two different methods to represent lossless DC power flows. In the following the implementation of the nodal model is presented, based of node voltage angles.","category":"page"},{"location":"advanced_concepts/Lossless_DC_power_flow/#key-concepts-advanced-nodal-DC","page":"Lossless nodal DC power flows","title":"Key concepts","text":"","category":"section"},{"location":"advanced_concepts/Lossless_DC_power_flow/","page":"Lossless nodal DC power flows","title":"Lossless nodal DC power flows","text":"In the following, it is described how to set up a connection in order to represent a nodal lossless DC power flow network. Therefore, key object - and relationship classes as well as parameters are introduced.","category":"page"},{"location":"advanced_concepts/Lossless_DC_power_flow/","page":"Lossless nodal DC power flows","title":"Lossless nodal DC power flows","text":"connection: A connection represents the electricity line being modelled. A physical property of a connection is its connection_reactance, which is defined on the connection object. Furthermore, if the reactance is given in a p.u. different from the standard unit used (e.g. p.u. = 100MVA), the parameter connection_reactance_base can be used to perform this conversion.\nnode: In a lossless DC power flow model, nodes correspond to buses. To use voltage angles for the representation of a lossless DC model, the has_voltage_angle needs to be true for these nodes (which will trigger the generation of the node_voltage_angle variable). Limits on the voltage angle can be enforced through the max_voltage_angle and min_voltage_angle parameters. The reference node of the system should have a voltage angle equal to zero, assigned through the parameter fix_node_voltage_angle.\nconnection__to_node and connection__from_node : These relationships need to be introduced between the connection and each node, in order to allow power flows (i.e. connection_flow). Furthermore, a capacity limit on the connection line can be introduced on these relationships through the parameter connection_capacity.\nconnection__node__node: To ensure energy conservation across the power line, a fixed ratio between incoming and outgoing flows should be given. The fix_ratio_out_in_connection_flow parameter enforces a fixed ratio between outgoing flows (i.e. to_node) and incoming flows (i.e. from_node). This parameter should be defined for both flow direction.","category":"page"},{"location":"advanced_concepts/Lossless_DC_power_flow/","page":"Lossless nodal DC power flows","title":"Lossless nodal DC power flows","text":"The mathematical formulation of the lossless DC power flow model using voltage angles is fully described here.","category":"page"},{"location":"concept_reference/max_ratio_in_in_unit_flow/","page":"-","title":"-","text":"The definition of the max_ratio_in_in_unit_flow parameter triggers the generation of the constraint_max_ratio_in_in_unit_flow and enforces an upper bound on the ratio between incoming flows of a unit. The parameter is defined on the relationship class unit__node__node, where both nodes (or group of nodes) in this relationship represent from_nodes, i.e. the incoming flows to the unit. The ratio parameter is interpreted such that it constrains the ratio of in1 over in2, where in1 is the unit_flow variable from the first node in the unit__node__node relationship in a left-to-right reading order. This parameter can be useful, for instance if a unit requires a specific commodity mix as a fuel supply.","category":"page"},{"location":"concept_reference/max_ratio_in_in_unit_flow/","page":"-","title":"-","text":"To enforce e.g. for a unit u a maximum share of 0.8 of its incoming flow from the node supply_fuel_1 compared to its incoming flow from the node group supply_fuel_2 (consisting of the two nodes supply_fuel_2_component_a and supply_fuel_2_component_b) the max_ratio_in_in_unit_flow parameter would be set to 0.8 for the relationship u__supply_fuel_1__supply_fuel_2.","category":"page"},{"location":"concept_reference/model__default_stochastic_structure/","page":"-","title":"-","text":"The model__default_stochastic_structure relationship can be used to set a model-wide default for the node__stochastic_structure and units_on__stochastic_structure relationships. Its main purpose is to allow users to avoid defining each relationship individually, and instead allow them to focus on defining only the exceptions. As such, any specific node__stochastic_structure or units_on__stochastic_structure relationships take priority over the model__default_stochastic_structure relationship.","category":"page"},{"location":"concept_reference/connection__from_node__unit_constraint/","page":"-","title":"-","text":"connection__from_node__user_constraint is a three-dimensional relationship between a connection, a node and a user_constraint. The relationship specifies that the connection_flow variable to the specified connection from the specified node is involved in the specified user_constraint. Parameters on this relationship generally apply to this specific connection_flow variable. For example the parameter connection_flow_coefficient defined on connection__from_node__user_constraint represents the coefficient on the specific connection_flow variable in the specified user_constraint","category":"page"},{"location":"concept_reference/storage_investment_lifetime/","page":"-","title":"-","text":"Duration parameter that determines the minimum duration of storage investment decisions. Once a storage has been invested-in, it must remain invested-in for storage_investment_lifetime. Note that storage_investment_lifetime is a dynamic parameter that will impact the amount of solution history that must remain available to the optimisation in each step - this may impact performance.","category":"page"},{"location":"concept_reference/storage_investment_lifetime/","page":"-","title":"-","text":"See also Investment Optimization and candidate_storages","category":"page"},{"location":"concept_reference/unit_flow_coefficient/","page":"-","title":"-","text":"The unit_flow_coefficient is an optional parameter that can be used to include the unit_flow or unit_flow_op variables from or to a node in a user_constraint via the unit__from_node__user_constraint and unit__to_node__user_constraint relationships. Essentially, unit_flow_coefficient appears as a coefficient for the unit_flow and unit_flow_op variables from or to the node in the user constraint.","category":"page"},{"location":"concept_reference/unit_flow_coefficient/","page":"-","title":"-","text":"Note that the unit_flow_op variables are a bit of a special case, defined using the operating_points parameter.","category":"page"},{"location":"concept_reference/max_iterations/","page":"-","title":"-","text":"When the model in question is of type :spineopt_master, this determines the maximum number of Benders iterations.","category":"page"},{"location":"concept_reference/storages_invested_avaiable_coefficient/","page":"-","title":"-","text":"The storages_invested_available_coefficient is an optional parameter that can be used to include the storages_invested_available variable in a user_constraint via the node__user_constraint relationship. Essentially, storages_invested_available_coefficient appears as a coefficient for the storages_invested_available variable in the user constraint. For more information, see the [User Constraints Concept Reference][#User-Constraints]","category":"page"},{"location":"concept_reference/unit_conv_cap_to_flow/","page":"-","title":"-","text":"The unit_conv_cap_to_flow, as defined for a unit__to_node or unit__from_node, allows the user to align between unit_flow variables and the unit_capacity parameter, which may be expressed in different units. An example would be when the unit_capacity is expressed in GWh, while the demand on the node is expressed in MWh. In that case, a unit_conv_cap_to_flow parameter of 1000 would be applicable.  ","category":"page"},{"location":"concept_reference/weight_relative_to_parents/","page":"-","title":"-","text":"The weight_relative_to_parents parameter defines how much weight the stochastic_scenario gets in the Objective function. As a stochastic_structure__stochastic_scenario relationship parameter, different  stochastic_structures can use different weights for the same stochastic_scenario. Note that every stochastic_scenario that appears in the model must have a weight_relative_to_parents defined for it related to the used stochastic_structure! See the Stochastic Framework section for more information about how different stochastic_structures interact in SpineOpt.jl.)","category":"page"},{"location":"concept_reference/weight_relative_to_parents/","page":"-","title":"-","text":"Since the Stochastic Framework in SpineOpt.jl supports stochastic directed acyclic graphs instead of simple stochastic trees, it is possible to define stochastic_structures with converging stochastic_scenarios. In these cases, the child stochastic_scenarios inherint the weight of all of their parents, and the final weight that will appear in the Objective function is calculated as shown below:","category":"page"},{"location":"concept_reference/weight_relative_to_parents/","page":"-","title":"-","text":"# For root `stochastic_scenarios` (meaning no parents)\n\nweight(scenario) = weight_relative_to_parents(scenario)\n\n# If not a root `stochastic_scenario`\n\nweight(scenario) = sum([weight(parent) * weight_relative_to_parents(scenario)] for parent in parents)","category":"page"},{"location":"concept_reference/weight_relative_to_parents/","page":"-","title":"-","text":"The above calculation is performed starting from the roots, generation by generation, until the leaves of the stochastic DAG. Thus, the final weight of each stochastic_scenario is dependent on the weight_relative_to_parents Parameters of all its ancestors.","category":"page"},{"location":"concept_reference/unit__investment_stochastic_structure/","page":"-","title":"-","text":"The unit__investment_stochastic_structure relationship defines the stochastic_structure of unit-related investment decisions. Essentially, it sets the stochastic_structure used by the units_invested_available variable of the unit.","category":"page"},{"location":"concept_reference/unit__investment_stochastic_structure/","page":"-","title":"-","text":"The unit__investment_stochastic_structure relationship uses the model__default_investment_stochastic_structure relationship if not defined.","category":"page"},{"location":"concept_reference/connection__to_node/","page":"-","title":"-","text":"connection__to_node is a two-dimensional relationship between a connection and a node and implies a connection_flow from the connection to the node. Specifying such a relationship will give rise to a connection_flow_variable with indices connection=connection, node=node, direction=:to_node. Relationships defined on this relationship will generally apply to this specific flow variable. For example, connection_capacity will apply only to this specific flow variable, unless the connection parameter connection_type is specified.","category":"page"},{"location":"concept_reference/stochastic_structure__stochastic_scenario/","page":"-","title":"-","text":"The stochastic_structure__stochastic_scenario relationship defines which stochastic_scenarios are included in which stochastic_structure, as well as holds the stochastic_scenario_end and weight_relative_to_parents Parameters defining how the stochastic_structure interacts with the Temporal Framework and the Objective function. Along with parent_stochastic_scenario__child_stochastic_scenario, this relationship is used to define the exact properties of each stochastic_structure, which are then applied to the objects describing the modelled system according to the Structural relationship classes, like the node__stochastic_structure relationship.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_in_out/","page":"-","title":"-","text":"The min_units_on_coefficient_in_out parameter is an optional coefficient in the unit input-output ratio constraint controlled by the min_ratio_in_out_unit_flow parameter. Essentially, it acts as a coefficient for the units_on variable in the constraint, allowing for making the minimum conversion ratio dependent on the amount of online capacity.","category":"page"},{"location":"concept_reference/min_units_on_coefficient_in_out/","page":"-","title":"-","text":"Note that there are different parameters depending on the directions of the unit_flow variables being constrained: min_units_on_coefficient_in_in, min_units_on_coefficient_out_in, and min_units_on_coefficient_out_out, all of which apply to their respective constraints. Similarly, there are different parameters for setting maximum or fixed conversion rates, e.g. max_units_on_coefficient_in_out and fix_units_on_coefficient_in_out.","category":"page"}]
}
